
标题：helux，一个鼓励服务注入的响应式react状态库
作者：fantasticsoul
发布日期：发布于 6 天前
文章内容：<h2>关于helux</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是一个鼓励服务注入，并支持响应式变更react的全新数据流方案，它的前身是<a href="https://github.com/concentjs/concent">concent</a>（一个类vue开发体验的高性能状态管理框架），但concent自身因为需要兼容class和function保持一致的语法，且为了对其<code>setup</code>功能，导致内部代码量实在太大，压缩后有<code>70</code>多kb，api暴露得也非常多，导致学习难度急剧上升，为了更符合现在非常流行的<code>DDD</code>围绕业务概念构建领域模型的编码趋势，<code>helux</code>一开始就设计为<code>鼓励服务注入</code>、<code>支持响应式变更</code>、<code>支持依赖收集</code>的轻量级react数据流方案。</p>
<p>它拥有以下优势：</p>
<ul>
<li>轻量，压缩后2kb</li>
<li>简单，仅暴露7个api，高频使用的仅<code>createShared</code>、<code>useObject</code>、<code>useSharedObject</code>、<code>useService</code>4个接口</li>
<li>高性能，自带依赖收集</li>
<li>响应式，支持创建响应式对象，在视图之外变更对象将同步更新视图</li>
<li>服务注入，配合<code>useService</code>接口轻松控制复杂业务逻辑，总是返回稳定的引用，可完全避免<code>useCallback</code>依赖烦扰了</li>
<li>状态提升0改动，所以地方仅需将<code>useObject</code>换为<code>useSharedObject</code>即可提升状态共享到其他组件</li>
<li>避免forwordRef 地狱，内置的<code>exposeService</code>模式将轻松解决父掉子时的<code>ref</code>转发晦涩理解问题和传染性（隔代组件需要层层转发）</li>
<li>ts友好，100% ts 编写，为你提供全方位类型提示</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88176d2bc14643e8b81d29fd72902a9d~tplv-k3u1fbpfcp-watermark.image?" alt="2.gif"></p>
<blockquote>
<p>该gif图和以下所有api均对应有在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>,欢迎fork并修改体验。</p>
</blockquote>
<p>为什么起名<code>helux</code>，虽然内心上我是把它作为<code>concent</code> v3版本去开发的，但因为它的变化实在太大，除了依赖收集不继承任何<code>concent</code>的特性，同时它也是伴随我开发的<a href="https://github.com/tnfe/hel">hel-micro</a>诞生一款作品，我期望它成为 hel-micro 生态的 luxury 级别的贡献，就将 hel-micro 和 luxury 两个词拼一起成为了 <code>helux</code>。</p>
<p>欢迎点星关注<a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>，它虽然较新，但已在我自己的使用场景中发挥功不可没的作用，现已加入hel-micro生态大仓，期待能成为你愿意挑选的一款可心数据流方案。</p>
<h2>快速上手</h2>
<p>极致的简单是helux最大的优势，了解以下6个api后，你可以轻松应付任何复杂场景，最大的魅力在于<code>useSharedObject</code>和<code>useService</code>两个接口，且看如下api介绍，或访问在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>fork并修改来体验。</p>
<h3>useObject</h3>
<p>使用 useObject 有两个好处</p>
<ul>
<li>1 方便定义多个状态值时，少写很多 useState</li>
<li>2 内部做了 unmount 判断，让异步函数也可以安全的调用 setState，避免 react 出现警告 :
“Called SetState() on an Unmounted Component” Errors</li>
</ul>
<pre class="prettyprint language-ts"><code>// 基于对象初始化一个视图状态
const [state, setState] = useObject({a:1});
// 基于函数初始化一个视图状态
const [state, setState] = useObject(()=&gt;({a:1}));
</code></pre><h3>useForceUpdate</h3>
<p>强制更新当前组件视图，某些特殊的场景可以使用它来做视图重刷新</p>
<pre class="prettyprint language-ts"><code>const forUpdate = useForceUpdate();
</code></pre><h3>createSharedObject</h3>
<p>创建一个共享对象，可透传给 <code>useSharedObject</code>，具体使用见 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const sharedObj = createSharedObject({a:1, b:2});
// 基于函数初始化一个共享对象
const sharedObj = createSharedObject(()=&gt;({a:1, b:2}));
</code></pre><h3>createReactiveSharedObject</h3>
<p>创建一个响应式的共享对象，可透传给 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const [reactiveObj, setState] = createReactiveSharedObject({a:1, b:2});

sharedObj.a = 111; // 任意地方修改 a 属性，触发视图渲染
setSharedObj({a: 111}); // 使用此方法修改 a 属性，同样也能触发视图渲染，深层次的数据修改可使用此方法
</code></pre><h3>createShared</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function createShared&lt;T extends Dict = Dict&gt;(
  rawState: T | (() =&gt; T),
  enableReactive?: boolean,
): {
  state: SharedObject&lt;T&gt;;
  call: &lt;A extends any[] = any[]&gt;(
    srvFn: (ctx: { args: A; state: T; setState: (partialState: Partial&lt;T&gt;) =&gt; void }) =&gt; Promise&lt;Partial&lt;T&gt;&gt; | Partial&lt;T&gt; | void,
    ...args: A
  ) =&gt; void;
  setState: (partialState: Partial&lt;T&gt;) =&gt; void;
};
</code></pre><p>创建一个响应式的共享对象，可透传给 useSharedObject，它是<code>createReactiveSharedObject</code>和<code>createSharedObject</code>的结合体，当需要调用脱离函数上下文的服务函数时（即不需要感知组件props时），可使用该接口，第二位参数为是否创建响应式状态，为 true 时效果同 <code>createReactiveSharedObject</code> 返回的 sharedObj</p>
<pre class="prettyprint"><code> const ret = createShared({ a: 100, b: 2 });
 const ret2 = createShared({ a: 100, b: 2 }, true); // 创建响应式状态
 // ret.state 可透传给 useSharedObject
 // ret.setState 可以直接修改状态
 // ret.call 可以调用服务函数，并透传上下文
</code></pre><p>以下将举例两种具体的定义服务函数的方式，之后用户便可在其他其他地方任意调用这些服务函数修改共享状态了，如需感知组件上下文，则需要用到下面介绍的<code>useService</code>接口去定义服务函数。</p>
<pre class="prettyprint"><code>// 调用服务函数第一种方式，直接调用定义的函数，配合 ret.setState 修改状态
function changeAv2(a: number, b: number) {
   ret.setState({ a, b });
}
*
// 第二种方式，使用 ret.call(srvFn, ...args) 调用定义在call函数参数第一位的服务函数
function changeA(a: number, b: number) {
   ret.call(async function (ctx) { // ctx 即是透传的调用上下文，
     // args：使用 call 调用函数时透传的参数列表，state：状态，setState：更新状态句柄
     // 此处可全部感知到具体的类型
     // const { args, state, setState } = ctx;
     return { a, b };
   }, a, b);
 }
</code></pre><h3>useSharedObject</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function useSharedObject&lt;T extends Dict = Dict&gt;(sharedObject: T, enableReactive?: boolean): [
  SharedObject&lt;T&gt;,
  (partialState: Partial&lt;T&gt;) =&gt; void,
]
</code></pre><p>接收一个共享对象，多个视图里将共享此对象，内部有依赖收集机制，不依赖到的数据变更将不会影响当前组件更新</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
</code></pre><p><code>useSharedObject</code>默认返回非响应式状态，如需要使用响应式状态，透传第二位参数为true即可</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
// now obj is reactive
 setInterval(()=&gt;{
  state.a = Date.now(); // 触发视图更新
 }, 2000);
</code></pre><h3>useService</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>/**
 * 使用用服务模式开发 react 组件：
 * @param compCtx
 * @param serviceImpl
 */
function useService&lt;P extends Dict = Dict, S extends Dict = Dict, T extends Dict = Dict&gt;(
  compCtx: {
    props: P;
    state: S;
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
  },
  serviceImpl: T,
): T &amp; {
  ctx: {
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
    getState: () =&gt; S;
    getProps: () =&gt; P;
  };
}
</code></pre><p>它可搭配<code>useObject</code>和<code>useSharedObject</code>一起使用，会创建服务对象并返回，该服务对象是一个稳定的引用，且它包含的所有方法也是稳定的引用，可安全方法交给其它组件且不会破会组件的pros比较规则，避免烦恼的<code>useMemo</code>和<code>useCallback</code>遗漏相关依赖</p>
<p>搭配<code>useObject</code>时</p>
<pre class="prettyprint language-ts"><code>function DemoUseService(props: any) {
  const [state, setState] = useObject({ a: 100, b: 2 );
  // srv本身和它包含的方法是一个稳定的引用，
  // 可安全的将 srv.change 方法交给其它组件且不会破会组件的pros比较规则
  const srv = useService({ props, state, setState }, {
    change(a: number) {
      srv.ctx.setState({ a });
    },
  });
  
  return &lt;div&gt;
    DemoUseService:
    &lt;button onClick={() =&gt; srv.change(Date.now())}&gt;change a&lt;/button&gt;
  &lt;/div&gt;;
}
</code></pre><p>搭配<code>useSharedObject</code>时，只需替换<code>useObject</code>即可，其他代码不用做任何改变</p>
<pre class="prettyprint language-diff"><code>+ const sharedObj = createSharedObject({a:100, b:2})

function DemoUseService(props: any) {
-  const [state, setState] = useObject({ a: 100, b: 2 );
+  const [state, setState] = useSharedObject(sharedObj);
</code></pre><h4>getState 和 getProps</h4>
<p>因 <code>state</code> 和 <code>props</code> 是不稳定的，所以服务内部函数取的时候需从<code>srv.ctx.getState</code>或<code>srv.ctx.getProps</code></p>
<pre class="prettyprint language-ts"><code>// 抽象服务函数
export function useChildService(compCtx: {
  props: IProps;
  state: S;
  setState: (partialState: Partial&lt;S&gt;) =&gt; void;
}) {
  const srv = useService&lt;IProps, S&gt;(compCtx, {
    change(label: string) {
      // !!! do not use compCtx.state or compCtx.state due to closure trap
      // console.log("expired state:", compCtx.state.label);

      // get latest state
      const state = srv.ctx.getState();
      console.log("the latest label in state:", state.label);
      // get latest props
      const props = srv.ctx.getProps();
      console.log("the latest props when calling change", props);

      // your logic
      compCtx.setState({ label });
    }
  });
  return srv;
}

export function ChildComp(props: IProps) {
  const [state, setState] = useObject(initFn);
  const srv = useChildService({ props, state, setState });
}

 return (
    &lt;div&gt;
      i am child &lt;br /&gt;
      &lt;button onClick={() =&gt; srv.change(`self:${Date.now()}`)}&gt;
        change by myself
      &lt;/button&gt;
      &lt;h1&gt;{state.label}&lt;/h1&gt;;
    &lt;/div&gt;
  );
</code></pre><h4>exposeService</h4>
<p>当孩子组件props上透传了<code>exposeService</code>函数时，<code>useService</code> 将自动透传服务对象给父亲组件，是一种比较方便的逃离<code>forwardRef</code>完成父调子的模式</p>
<pre class="prettyprint language-ts"><code>import { ChildSrv, Child } from "./Child";

function App() {
  // 保存孩子的服务
  const childSrv = React.useRef&lt;{ srv?: ChildSrv }&gt;({});
  const seeState = () =&gt; {
    console.log("seeState", childSrv.current.srv?.ctx.getState());
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; childSrv.current.srv?.change(`${Date.now()}`)}&gt;
        call child logic
      &lt;/button&gt;
      &lt;Child
        unstableProp={`${Date.now()}`}
        exposeService={(srv) =&gt; (childSrv.current.srv = srv)}
      /&gt;
    &lt;/div&gt;
  );
}
</code></pre><h2>结语</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是把<a href="https://github.com/concentjs/concent">concent</a>内部精华全部萃取提炼再加工后的全新作品，期望能得到你的喜欢与鼓励。❤️</p>







标题：fabric.js开发图片编辑器可以实现哪些功能？多图
作者：nihaojob
发布日期：发布于 6 天前
文章内容：<p>最近使用fabric.js开发了一个图形编辑器并开源了，已收到900+star，<strong>很多开发者咨询fabric.js能实现哪些功能</strong>，今天就用文字加动图的形式直观的分享出来，帮助大家做参考。</p>
<p>fabric.js 提供强大的底层能力，可实现<strong>自定义模板、素材、字体，图片滤镜、辅助线、组合、裁剪等功能，也提供了自定义元素等高级的用法</strong>。</p>
<p>项目：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>
<p>预览：<a href="https://nihaojob.github.io/vue-fabric-editor/#/">https://nihaojob.github.io/vue-fabric-editor/#/</a></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89169a52052245839413826e3a9b9ac0~tplv-k3u1fbpfcp-watermark.image?" alt="screenshot-20230415-142257.png"></p>
<h2>画布功能</h2>
<p><strong>画布属性：尺寸、预设大小、背景色。</strong>
支持修改画布尺寸，也有预常用预设的画布尺寸，可以便捷设置，有背景色修改属性，同时提供常用颜色的快捷修改。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044e2d09049f489f9341263862674fb9~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415120741_rec_.gif"></p>
<p><strong>画布缩放：放大、缩小、自动适应、鼠标滚轮缩放。</strong>
支持画布放大缩小操作，可按照1:1尺寸展示或自适应展示，页面窗口改变时会根据窗口大小自适应展示；滑动鼠标滚轮时可快捷缩放画布。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6950ef15074c494e9d277a5b46c2c9f2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415121804_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570f0c1bb2434593949b65234972f1b4~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122049_rec_.gif"></p>
<p><strong>其他细节：拖拽画布、画布区域外显示控制条。</strong>
画布支持拖拽操作，按住alt快捷键，可以拖动画布；当元素拖拽到画布外区域时，仍然展示控制条，但元素并不会被展示出来，所见即所得。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b050ef702a4449dbce41b27a525a7e2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122246_rec_.gif"></p>
<h2>辅助功能</h2>
<p><strong>控制条：</strong> 在满足元素缩放、旋转的基础上尽量让其简洁，提供了2种样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bba9a276e24db99653513bafb23f75~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123406_rec_.gif"></p>
<p><strong>标尺：</strong> 标尺与辅助线可以满足我们更高要求的设计场景。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3489af30b75e4ecdbd037f7dddfbd10a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123622_rec_.gif"></p>
<p><strong>快捷调整：</strong> 图层管理、右键菜单、快捷键。
图层可以直观的定位元素的层级顺序，右键菜单提供了常用的快捷功能，还支持复制、删除等快捷键操作，提高操作效率。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b2176cb3e4ce0bc973d27cd58d705~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415125124_rec_.gif"></p>
<h2>基础元素</h2>
<p><strong>字体元素：</strong> 字体元素有普通字体、框字体，框字体可调整外边框，自动换行。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2dd53747534bbba5273787cced287a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130158_rec_.gif"></p>
<p><strong>基础形状：</strong> 有矩形、圆形、三角形、多边形，可直接点击或拖拽添加到画布。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa5a10f62049cdbd7a6f0d10760e29~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130303_rec_.gif"></p>
<p><strong>线条元素：</strong> 支持箭头、线条元素绘制。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1209cdaee70b4f38b7eef8987d6d676d~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131152_rec_.gif"></p>
<p><strong>插入元素：</strong> 支持插入多种图片类型，图片图片、SVG元素、SVG字符串。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba18715bb24d46719d8883a90d127152~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130901_rec_.gif"></p>
<p><strong>自定义素材：</strong> 素材在左侧分类展示，可定义图片素材、字体样式素材。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97231aaa1f145f1965c1a7ee935e442~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131012_rec_.gif"></p>
<h2>文件功能</h2>
<p><strong>数据保存：</strong> 支持导出/导出JSON文件方便存储数据，可自定义设计模板。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff449fe3b9b4f08b5e51f5072b164ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131754_rec_.gif"></p>
<p><strong>图片保存：</strong> 可清空画布、预览图片、保存图片文件。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9b6eef8f2d46a284acccaa15710f39~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131852_rec_.gif"></p>
<h2>属性设置</h2>
<p><strong>基础操作：</strong> 所有元素都可以在属性面板调整透明度、坐标、旋转角度。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b96af734d4a03bfeb003de4d04865~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133918_rec_.gif"></p>
<p><strong>锁定与组合：</strong> 锁定元素后元素将不会收到其他操作影响；可将多个元素组合为一个组元素，也可以将组元素拆分为多个元素。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d836659d849d0ba115a5ec2e3b959~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132328_rec_.gif"></p>
<p><strong>元素对齐：</strong> 单个元素支持相对于画布的水平、垂直、水平垂直居中，多个元素支持上、下、左、右对齐，水平居中、垂直居中、垂直平均分布、水平平均分布功能。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71eae7cab77489d8ffb51edb3c66f11~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132516_rec_.gif">
**自定义字体：**可自定义字体、对齐方式、行高、背景色、下划线、删除线等信息。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eae4c5d03474d28b25fa64e82ef87e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>渐变配置：</strong> 渐变是设计的重要形式之一，支持为元素、字体设置渐变颜色。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf12add8983481cb2a11bcd0a33614e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>边框设置：</strong> 支持为元素增加边框样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349ce94cbc0f4aae99ec59d72ea73346~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415134137_rec_.gif"></p>
<p><strong>图片操作：</strong> 快捷替换、简单滤镜、复杂滤镜。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4998294d7f11404fad58321bfb4f22ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133617_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21f01ec7ccd40458693d0e0b8cb43a7~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133505_rec_.gif"></p>
<h2>总结</h2>
<p>fabric.js 的底层能力非常强大，这依赖于灵活的底层接口，但是太过灵活也有一个弊端，那就是我们必须掌握更多的细节才能用起来得心应手，这对于开发者来说并不会太轻松。</p>
<p><a href="https://github.com/nihaojob/vue-fabric-editor">vue-fabric-editor</a>项目致力于打造一个开箱即用的web图片编辑器应用，同时<strong>沉淀一个介于web图片编辑器应用与fabric.js之间的封装层</strong>，期望封装层面向开发者设计，<strong>提供更简单的接口，让开发者可以轻松的实现图片应用开发</strong>。</p>
<h2>邀请</h2>
<p>通过技术社区和开源的方式和大家相识是一种很奇妙的体验，大部分都是在使用fabric.js做项目的开发者，我们组建了fabric.js开发者交流群，一起抱团取暖互相支招，一边吐槽文档，一起实现功能，欢迎你的加入交流群。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e358ff17a16e4f6e946291c7beeac0d4~tplv-k3u1fbpfcp-watermark.image?" alt="WechatIMG391.jpeg"></p>
<p>我们离目标还有很长的距离，如果你对这件事情感兴趣，真诚的邀请你加入，我们一起沉淀fabric.js的最佳实践，<strong>你会得到包括不限于以下列表的收获，你只要会简单的Git和Javascript语法就可以</strong>。</p>
<ul>
<li>熟悉开源协作方式，成为项目贡献者。</li>
<li>Vue3 + TS实践，边学边开发。</li>
<li>fabric.js开发，边学边开发。</li>
<li>入门单元测试，边学边开发。</li>
<li>众多的fabric.js开发者交流。</li>
</ul>
<p>我自己是第一次搞开源项目，感谢项目的贡献者的帮助和社区的推动，<strong>这是一个很新的项目和社区，期待你的加入，希望我们一起边走边学，在未来一起成为知名开源项目的开发者</strong>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d96501901c48c8ba76d6a64ca4a185~tplv-k3u1fbpfcp-watermark.image?" alt="海报.png"></p>







标题：聊聊 WebCodecs 实现 GIF 视频转码
作者：kinglisky
发布日期：发布于 8 天前
文章内容：<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d9d33079b840e3aa3d7d0b603139eb~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt=""></p>
<p>被裁了，最近在摸鱼写文档，这两天研究了下浏览器环境下摆脱 ffmpeg.wasm 实现 GIF 转视频的功能，现在浏览器提供的 API 越来越靠近底层，浏览器在发展个几年可能真没 Electron 啥事了 [狗头] 。</p>
<p>不重复发文了，发掘金了：<a href="https://juejin.cn/post/7221557738537549879">聊聊 WebCodecs 实现 GIF 视频转码</a></p>
<p>欢迎大佬们指教~</p>







标题：自己开发了编程课程搜索的小程序，基本慕课网的课程都能搜到
作者：mikfake
发布日期：发布于 9 天前
文章内容：<p>小程序使用uniapp开发，后端使用java。因为实后端java开发，前端不擅长，有一些地方写的不是很合理。不过主要目的还是分享免费的编程课程。正在找编程资源的可以看看，可能你要的就能搜到，每天都会更新一些资源。
<img src="//static.cnodejs.org/FmBeKhXk1La4M-1xzwnIiLRZq_Ip" alt="素材1.png">
<img src="//static.cnodejs.org/FgF93KX8qwHSlleM5X6Gmug5RFo2" alt="素材2.png">
<img src="//static.cnodejs.org/Fo3cR9S0MO2OPOBe9X1Mhb7M7GXg" alt="素材3.png">
<img src="//static.cnodejs.org/FnMtv4MbZU0NRrn1Q8Ql1gRYJDCc" alt="素材4.png">
<img src="//static.cnodejs.org/Fl4_GBEs_KDU3A8PzuqpHtym9FFg" alt="二维码.jpg"></p>







标题：NodeJS+Sequelize在生产环境下，最合适的建立连接池的方式是？
作者：monkeytwins
发布日期：发布于 15 天前
文章内容：<p>看官网文档里提到关于多进程的情况下，必须为每一个进程都创建sequelize实例：</p>
<blockquote>
<p>If you’re connecting to the database from multiple processes, you’ll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected.</p>
</blockquote>
<p>生产环境下，肯定是多负载多进程的情况，并且一般用cluster模块去进行进程处理</p>
<pre class="prettyprint language-js"><code>if (cluster.isMaster) {
    for (var i = 0; i &lt; env.CPU; i++) {
        cluster.fork();
    }

    cluster.on('fork', worker =&gt; {
        log(`worker ${worker.process.pid} forked success`, 'info', logOptions);
    });

    cluster.on('online', worker =&gt; {
        log(`worker ${worker.process.pid} responded after it was forked`, 'info', logOptions);
    });

    cluster.on('exit', function (worker, code, signal) {
        log(`worker ${worker.process.pid} died (${signal || code})`, 'warn', logOptions);
        cluster.fork();
    });
} else {
    require('../app.js');
}
</code></pre><p>想请教下这种情况下，Sequelize的实例初始化应该在什么阶段？</p>







标题：置顶



        Node.js 18 新特性解读
作者：atian25
发布日期：发布于 1 年前
文章内容：<h2>概述</h2>
<p>Node.js 刚刚发布了 18.0.0 版本，内置了 <code>fetch</code>、<code>node:test</code> 等标准模块。</p>
<p><strong>一句话点评：std lib 在标准化，user lib 在精细化。</strong></p>
<blockquote>
<p>原文地址：<a href="https://zhuanlan.zhihu.com/p/502951532">EggJS 知乎专栏</a>，求点赞。</p>
</blockquote>
<hr>
<h2>如何快速体验</h2>
<p>推荐用 <a href="https://github.com/Schniz/fnm">fnm</a>，<a href="https://github.com/jasongin/nvs">nvs</a>，<a href="https://github.com/nvm-sh/nvm">nvm</a> 等 Node.js 版本管理器。</p>
<pre class="prettyprint language-bash"><code>$ fnm install 18
Installing Node v18.0.0 (arm64)

$ fnm use 18
Using Node v18.0.0

$ node -v
v18.0.0
</code></pre><p>需要注意的是，该版本不是 LTS 版本，请勿在生产环境使用，需要等到 2022-10-25 才会成为 LTS 版本。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012135a1091b40ef807c8b6e3919bcce~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png" title="https://github.com/nodejs/Release"></p>
<h2>Looking to the future</h2>
<blockquote>
<p>The project is also continuing its ‘Next 10’ effort.  The goal of this effort is to reflect on what led to success in the first 10 years of Node.js and set the direction for success in the next 10.</p>
</blockquote>
<p>Node.js 官方启动了 <a href="https://github.com/nodejs/next-10">next-10</a> 工作，并讨论出了<a href="https://github.com/nodejs/node/blob/master/doc/contributing/technical-priorities.md">未来重要的几件事</a>：</p>
<ul>
<li>现代化的 HTTP</li>
<li>友好的类型支持</li>
<li>对初学者更友好的渐进式文档</li>
<li>对 ECMAScript 规范的支持和及时跟进</li>
<li>可观测性，包括 logging/metrics/tracing，以及 APM 等</li>
<li>更好的多线程支持</li>
<li>支持打包为单文件的分发方式</li>
</ul>
<p>譬如前面说的 Fetch 就和 Modern HTTP 的会议讨论有关，<a href="https://github.com/nodejs/next-10/blob/main/meetings/summit-jan-2022.md">相关纪要</a>。</p>
<blockquote>
<p>6 月份的 OpenJS World 会议中将分享 ESM 和 Observability 进展，可以关注下相关动态。</p>
</blockquote>
<hr>
<h2>Fetch API</h2>
<p>前端同学应该都很熟悉<code>fetch()</code>这个 API，它提供了标准的网络请求能力，取代了远古的  XMLHttpRequest 。</p>
<p>反观 Node.js 侧，官方提供的 <a href="https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback">http.request()</a>，太底层太基础了，用起来往往需要大量的封装。譬如 302 后自动跳转、文件上传、响应结果解析等等。</p>
<p>因此在 Node.js 社区有非常多的上层请求库封装：</p>
<ul>
<li>曾经广受社区欢迎的 request 库去年<a href="https://github.com/request/request/issues/3142">宣布停止维护</a>后，也引起了社区比较大的混乱。。</li>
<li>我们 Egg 内置的是 <a href="https://www.npmjs.com/package/urllib">urllib</a>，沉淀了阿里多年在网络请求上踩的坑，足够稳定，不过代码也有点久远了。</li>
<li>更多参见 <a href="https://github.com/request/request/issues/3143">Alternative libraries to request</a> 以及 <a href="https://zhuanlan.zhihu.com/p/415361629">《天猪：那些你应该说再见的 npm 祖传老库》</a>。</li>
</ul>
<p><strong>去年 Node.js 官方推出了 <strong><a href="https://undici.nodejs.org/"><strong>undici</strong></a></strong>，一个非常现代化的库，具备优越的性能，良好的扩展性，内置的 mock 等能力，集大成者。</strong></p>
<blockquote>
<p>undici 的命名也很有趣：A HTTP/1.1 client → 11 → Eleven → Undici，即意大利语的 11。</p>
</blockquote>
<p>从而 <strong>Node.js 终于内置了新的请求库</strong>，它遵循 <a href="https://fetch.spec.whatwg.org/">Fetch 规范</a>，底层就是基于 undici 来实现的。</p>
<pre class="prettyprint language-javascript"><code>const res = await fetch('https://nodejs.org/api/documentation.json');
if (res.ok) {
  const data = await res.json();
  console.log(data);
}
</code></pre><p>就这么简单，比 <a href="https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httprequesturl-options-callback">http.request()</a> 那一坨 callback-style 代码简洁多了，平时写个脚本啥的，不用再引入额外的类库了。</p>
<p>全局增加了 fetch, FormData, Headers, Request, Response 这几个 API，以及 Web Streams API。</p>
<p>目前还处于默认开启的实验性特性阶段，文档在 <a href="https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#fetch">Globals</a> 章节，近乎没有，有需要直接看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">MDN 文档</a> 即可。</p>
<p>可能是为了遵循规范， undici 的很多能力如 Mock，Proxy，Pool 等都没有提供出来。</p>
<hr>
<h2>Test Runner</h2>
<p>单元测试很重要，很多新兴的编程语言都是会内置对应的能力，但前端这块一直都是由社区来实现，前端同学耳熟能详的 Test Runner 有 <a href="https://mochajs.org/">Mocha</a>、<a href="https://jestjs.io/">Jest</a>。</p>
<pre class="prettyprint language-javascript"><code>// mocha showcase
import assert from 'assert/strict';

describe('test/index.test.js', () =&gt; {
  it('test1', async () =&gt; {
    const res = await fetch('https://nodejs.org/api/documentation.json');
    assert(res.ok);
  });
  
  it.skip('skip some test', () =&gt; {});
});
</code></pre><p>终于，Node.js 在 18.x 里官方支持了 <a href="https://nodejs.org/dist/latest-v18.x/docs/api/test.html">Test 能力</a>：</p>
<pre class="prettyprint language-javascript"><code>import test from 'node:test';
import assert from 'assert/strict';

// 等价于 describe()
test('asynchronous passing test', async () =&gt; {
  const res = await fetch('https://nodejs.org/api/documentation.json');
  assert(res.ok);
});

test('multi level test', async (t) =&gt; {
  // 等价于 it()
  await t.test('subtest 1', (t) =&gt; {
    assert.strictEqual(1, 1);
  });

  await t.test('subtest 2', (t) =&gt; {
    assert.strictEqual(2, 2);
  });
});

// 等价于 describe.skip() / it.skip()
test('skip option', { skip: true }, () =&gt; {});

// 等价于 describe.only() / it.only()
test('only option', { only: true }, () =&gt; {});
</code></pre><p>可以看到：</p>
<ul>
<li>语法其实差不多，会更简洁一点，就一个 <code>test()</code>，options 除了 skip 和 only 外，还支持 concurrency 并发。</li>
<li>无需启动器，每一个文件都是一个可执行的 Node.js 代码。</li>
<li>暂未支持 <code>before/after/beforeEach/afterEach</code> 能力，看 issue 描述会后续支持。</li>
<li>暂未支持 Reporter，但日志输出为标准 <a href="https://testanything.org/">TAP</a> 格式，所以应该很容易能复用现有的社区生态。</li>
</ul>
<p>类似覆盖率的演进过程，以前我们需要通过 nyc 对代码转译打桩，现在变为的 Node.js 内置覆盖率输出，nyc 变为 c8 这样的覆盖率报告生成工具。</p>
<p>后续 mocha 等估计会变为类似的上层封装，提供批量执行 和 Reporter 等能力。</p>
<hr>
<h2>Build-time user-land snapshot</h2>
<p>简单的说，可以把某个 js 直接编译成 v8 snapshot，从而可以极大的提速启动时间。</p>
<p>目前这个版本，还只能通过 Node.js 源码来编译，且只能编译成 Node.js Runtime 的方式，即 Build-time。</p>
<pre class="prettyprint language-bash"><code># 把一段 markdown 渲染的逻辑，直接打包到 Node Runtime
$ cd /path/to/node/source
$ ./configure --node-snapshot-main=marked.js
$ make node

# 执行编译好的 Node Runtime
$ out/Release/node
&gt; const html = globalThis.marked('# this is title');
</code></pre><p>秋怡正在继续推进<a href="https://github.com/nodejs/node/issues/35711">该能力</a>，未来可以无需编译 Node.js 源码：</p>
<pre class="prettyprint language-bash"><code>$ node --build-snapshot --snapshot-blob marked.blob marked.js 
$ node --snapshot-blob marked.blob
</code></pre><p>PS：这个能力用在命令行 CLI 的独立打包好像也不错。<a href="https://github.com/nodejs/node/issues/42566">https://github.com/nodejs/node/issues/42566</a></p>
<hr>
<h2>V8 引擎升级</h2>
<p>内置的 V8 引擎升级到 10.1 版本，值得注意的特性：</p>
<ul>
<li>class fields 和 private class methods 的性能优化。</li>
<li><a href="https://v8.dev/blog/v8-release-99#intl.locale-extensions">Intl 规范</a> 的支持，在做日期的本地化，字符串处理的时候非常有用。</li>
<li>数组支持 findLast() 和 findLastIndex() 等。</li>
</ul>
<p>秋怡也写了一篇文章 <a href="https://v8.dev/blog/faster-class-features">Faster initialization of instances with new class features</a> 分享了背后的实现。</p>
<p>PS：<a href="https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw">ECMAScript 双月报告：装饰器提案进入 Stage 3</a> ，阿里的 Node 架构团队今年会推动 Decorator 方案在 V8 的落地实现，不过肯定赶不上了，只能 Node.js 20.x 见了。</p>
<hr>
<h2>ESM 的支持</h2>
<p>虽然在 18.x 中没有新的内容，但在过去的几个月中一直在持续推动 ECMAScript模块实现：</p>
<ul>
<li>对 <a href="https://github.com/tc39/proposal-import-assertions">JSON Import Assertions</a> 的支持。</li>
<li>JSON 模块的正式支持。</li>
<li>对 HTTPS 和 HTTP 导入的实验性支持。</li>
<li><a href="https://github.com/nodejs/loaders">Node.js 加载器团队</a>也在继续开发 ECMAScript 模块加载器实现。</li>
</ul>
<hr>
<h2>工具链和编译器的升级</h2>
<ul>
<li>Linux 版是在 RHEL8 上构建的，要求 glibc 2.28 以上版本。</li>
<li>macOS 要求 10.15 以上版本。</li>
<li>Windows 很多旧版本也不支持了。</li>
</ul>
<p>PS：CentOS 7 官方不再维护了，它对应的 glibc 版本太低，所以升不了。。。</p>
<ul>
<li><a href="https://developer.aliyun.com/article/780803">centos7和8不维护停止更新之后，服务器选择使用什么系统好？</a></li>
<li><a href="https://github.com/nodejs/node/pull/42659">doc: update minimum glibc requirements for Linux by richardlau</a></li>
</ul>
<hr>
<h2>相关资料</h2>
<ul>
<li><a href="https://nodejs.org/en/blog/announcements/v18-release-announce">https://nodejs.org/en/blog/announcements/v18-release-announce</a></li>
<li><a href="https://nodejs.org/en/blog/release/v18.0.0/">https://nodejs.org/en/blog/release/v18.0.0/</a></li>
</ul>







标题：置顶



        CNode - TG 频道
作者：thonatos
发布日期：发布于 4 个月前
文章内容：<p>CNode TG Channel 开启 !</p>
<p>Channel 将定期推送最新技术文章、资讯以及活动，欢迎订阅！</p>
<p><a href="https://t.me/cnode_js">https://t.me/cnode_js</a></p>
<p><img src="//static.cnodejs.org/FkwbDvoUIeRAccpPd6f53rgXwrDz" alt="qrcode_tg_channel_cnode.png"></p>
<blockquote>
<p>Tips: 订阅后点击 “设置- View Discussion” 即可加入交流群!</p>
</blockquote>







标题：置顶



        阿里巴巴 Noslate 正式开源 - 面向云原生的 JavaScript 容器方案
作者：mariodu
发布日期：发布于 6 个月前
文章内容：<p>继 2019 年开源 Midway 框架之后，阿里一直在 Node.js 的前沿进行深度研究，除了加入 TC39 参与标准化建设，向上游 Node.js 项目持续贡献，与龙蜥社区合作优化之外，也在 Serverless 领域有了不小的成果。</p>
<p>今天，向大家介绍我们最新的面向云原生场景，面向 Serverless 架构下的新产品， 代号 <strong>Noslate</strong>。</p>
<h2>Noslate 是什么？</h2>
<p>欢迎访问项目了解更多内容：<a href="https://github.com/noslate-project/noslate">Noslate</a>
<img src="https://gw.alicdn.com/imgextra/i4/O1CN01hh1Db41sqh60CiNhD_!!6000000005818-2-tps-1324-390.png" alt="Noslate">
JavaScript 是开发者数量最庞大的编程语言，早些年 Node.js 等技术的出现，让 JavaScript 可以轻松地处理各类服务端任务。</p>
<p>但随着云原生/Serverless 等新架构概念的引导，弹性效率成为了全新的架构设计目标。为了能够让 JavaScript 任务拥有更高的弹性效率，进而满足在泛终端、全栈交付等领域的效率期待。我们逐步深入探索的过程中逐渐形成了 Noslate Project，旨在提升云原生场景下 JavaScript 的被调度性能，解决诊断性黑盒问题。</p>
<p>Noslate 它主要由三个子项目组成，分别体现了我们在提升 Javascript 任务弹性效率过程中碰到的问题以及解决方式：</p>
<ol>
<li>Node.js Distribution：初期针对函数计算冷启动场景优化，降低 Node.js 用户代码加载耗时，形成了针对性的 Node.js 发行版本。</li>
<li>Noslate Workers：随着探索的深入，我们设计了面向轻量端云同构场景的 W3C Web-interoperable JavaScript 轻量化容器方案。在交付灵活度上和资源、执行效率上形成平衡，现在主要应用于中心化的 SSR 渲染等轻量任务场景，效果显著。</li>
<li>Noslate Debugger：在落地业务过程中，我们发现在弹性效率提升后，对于异常和崩溃变得难以定位，得益于 Linux 系统 Coredump 机制的启发，我们设计了基于 Corefile 对问题进行离线诊断的 Noslate Debugger 产品，帮助用户实现问题的回溯和实时定位。</li>
</ol>
<p>简而言之，Noslate 目标是通过提供完整的技术产品方案， 将 JavaScript 打造成云原生时代最灵活的交付语言。</p>
<h2>为什么开源？</h2>
<p>一方面我们希望通过开源加强项目产品化程度；另一方面希望在社区中吸收更多的实践场景进而继续完善产品设计，也欢迎大家参与到项目中来。
同时，依托阿里云龙蜥社区和 Anolis 操作系统的合作关系，我们得以在底层探索，实现技术的演进。</p>
<h3>一、Noslate Workers</h3>
<p><img src="https://gw.alicdn.com/imgextra/i4/O1CN01L6QLHh1NRjQD5l5PE_!!6000000001567-2-tps-1270-339.png" alt="Noslate Workers">
W3C Web-interoperable 运行时 Aworker，提供了一个轻量，近乎 0 冷启动的 JavaScript Serverless 运行环境。通过它，可以轻松的在已有的架构中集成轻量化类 Serverless 的能力。
<img src="https://gw.alicdn.com/imgextra/i2/O1CN015XmQ8e20OlsVamGdC_!!6000000006840-2-tps-1729-672.png" alt="Noslate Workers 架构">
与传统的 FaaS 架构不同，这是一个在普通应用容器之上的轻量任务单位。得益于良好的动态任务高密度混部和隔离特性、以及基于任务状态拷贝 API 带来的近乎 0 冷启动特性，可以实现任务的即用即启与即停即抛，进而无需关心在整个大集群中任务节点的编排问题。
与既有架构的关系：
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01hwla1u1WSUch3qhT0_!!6000000002787-0-tps-3337-1879.jpg" alt="弹性架构分层">
Noslate Workers 由两个主要组件组成：</p>
<ol>
<li>Aworker - 轻量、Web-interoperable JavaScript Runtime</li>
<li>Noslated - Serverless 化的 Aworker 调度管控实现</li>
</ol>
<h4>关于 Aworker</h4>
<p>提供 Web API 标准的 Web-interoperable JavaScript 运行时，适合不直接依赖系统接口的业务逻辑部署。 Aworker 实现了近似&nbsp;<a href="https://www.w3.org/TR/service-workers/">Service Worker API</a>&nbsp;的规范，提供了基本的&nbsp;<a href="https://www.w3.org/TR/service-workers/#fetchevent">Request-Response</a>&nbsp;服务 API。
因为提供了相比于 Node.js 的 API 更加高层次、抽象的定义，不会泄漏系统底层状态，Aworker 通过 Startup Snapshot 和 Warmfork 能力， 实现了更快的水平及垂直扩容，能够在毫秒级启动并处理流量，具备更高的弹性效率。</p>
<h5>亮点特性一、Warmfork</h5>
<p>熟悉 Linux 系统编程的同学都知道 fork(2) 系统调用有几个优势：</p>
<ol>
<li>新进程可以继承母进程的当前状态，而无需从 main() 开始初始化；</li>
<li>pcb、栈、内存页，页表都是纯内存复制，所以进程创建快 (&lt;1ms)；</li>
<li>CopyOnWrite，新进程可以继承母进程的静态页表，可节省系统内存；</li>
</ol>
<p>对于 Node.js 来说，因为其无法在主线程持有所有多线程的状态 (如锁，信号量等)，所以 Node.js 进行 fork 的修改难度很大。其多线程设计主要 来源于 libuv 库和 V8 Platform Worker 线程：</p>
<ol>
<li>因部分 IO 操作存在同步调用，如 dns，文件读写等，所以 libuv 使用 IO 线程将同步操作转换成异步操作；</li>
<li>Node.js 的 V8 默认配置为多线程 GC、Background Compilation/Optimization 的方式；</li>
</ol>
<p>Node.js 的单进程多线程模型可以由下图表示：
<img src="https://gw.alicdn.com/imgextra/i1/O1CN01f3vkhU1gZxESjIBhq_!!6000000004157-2-tps-767-267.png" alt="Node.js 单进程多线程模型">
Aworker 的设计是采用单进程单线程的模型，也就是将上述模型中的 worker thread 单独抽出放到一独立进程中。Worker 因此可支持 fork，从而避免从 main() 开始的启动消耗，达到快速启动的目的。
<img src="https://gw.alicdn.com/imgextra/i1/O1CN01vaKK3b1NniQw29c7a_!!6000000001615-2-tps-734-266.png" alt="Aworker 单进程单线程模型">
为了支持单线程，Aworker 还做了如下修改：</p>
<ol>
<li>使用了 Linux AIO 特性替掉了 libuv 中同步的文件系统操作（不是 POSIX AIO，两者有区别。Posix AIO 类似于 libuv 现有的实现）；</li>
<li>使用 V8 的 SingleThread 模式，这是一个给低端设备（Low-end devices）实现的能力，不过非常符合 Serverless 资源模型；</li>
</ol>
<p>而为了管理、隔离这些工作进程，我们设计了一个轻量的业务进程容器管理组件 Turf ，该组件能通过 Warmfork 方式创建新的 Aworker 服务进程，并能提供一定的资源、环境的隔离能力，同时兼容 OCI。区别于传统 runc, rund 的容器，turf 旨在承载如 Aworker 这类轻 JS Runtime，它无需镜像运行，开销更低，可以支持更高的部署密度。</p>
<p>Warmfork 具体的对比：
<img src="https://gw.alicdn.com/imgextra/i2/O1CN01cLR5kd1JGVFa2tPic_!!6000000001001-2-tps-480-391.png" alt="warmfork">
提供 “被复制” 的进程，称为 “种子进程”，其他服务进程都是该进程的克隆。譬如 Aworker 作为种子进程，它需要确定自己一个 “可被克隆” 的时间点，将自己的所在状态（内存）作为克隆进程的初始状态。</p>
<p>Warmfork 的系统时序如下：
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01dTl9w71ZcW8TdBOon_!!6000000003215-2-tps-675-386.png" alt="warmfork 时序"></p>
<h5>亮点特性二、Startup Snapshot</h5>
<p>Warmfork 能实现了单机上服务进程的快速启动，而对于优化冷机启动加载速度，需要采用 Startup Snapshot 方案。
Startup Snapshot 和 CodeCache 的区别在于 Startup Snapshot 能够保存用户代码逻辑执行状态，而 CodeCache 只保存代码解析结果、仍然需要重新执行 用户代码逻辑。</p>
<p>设计上，Startup Snapshot 可提供携带用户代码逻辑的快速恢复，但是也有局限性：</p>
<ol>
<li>Startup Snapshot 对内存开销敏感，如果应用启动阶段用了大量内存，可能造成负优化；</li>
<li>用户代码启动需要没有歧义的状态，比如 IP 地址、日期、连接状态、服务发现结果等，针对这些歧义内容用户代码需要在进程恢复时有修正能力；</li>
</ol>
<p>V8 的 Startup Snapshot Serializer 就是一个类似于 GC 的对象遍历器。这个遍历器通过遍历加入到 Snapshot 中的 Root 对象，遍历它所对应的对象图并按照对象关系生成一系列的反序列化指令。</p>
<p>Startup Snapshot 相当于从 V8 Context 对象与它的&nbsp;globalThis&nbsp;开始，遍历堆中所有的对象并将对象关系与引用序列化成 特有的字节码，形成一个线性的可存储状态。并在恢复时，解释执行这些字节码，恢复堆中的对象内容与他们之间的引用关系。
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01VbTxVV1j7xsJEqEGB_!!6000000004502-2-tps-750-390.png" alt="V8 对象">
上述的两类和被调度性能相关的特性被统一归类为状态拷贝 API，具体使用可以参考官网文档中的<a href="https://noslate.midwayjs.org/docs/noslate_workers/aworker/serialize-api">《状态拷贝 API》</a>章节，详细介绍了命令行参数和程序内的 Events。</p>
<h4>Noslated</h4>
<p>Noslate Container Deamon，作为 Noslate Workers 解决方案的核心管控程序，提供了实例调度、弹性扩缩容、配置管理、流量管理等能力。</p>
<p>基于健壮性考虑，它由两个角色组成：控制面（Control Plane）、数据面（Data Plane）
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01OGE8Xk1hEiU0mY4Nw_!!6000000004246-2-tps-2845-1351.png" alt="Noslated 架构">
Noslated 对于实例的管控主要有三个模式：</p>
<ol>
<li>基础模式 - 基于流量的扩缩容</li>
<li>即抛模式 - 运行完即销毁</li>
<li>预留模式 - 面向历史场景兼容，在此不额外展开，详情可以查阅官网<a href="https://noslate.midwayjs.org/docs/noslate_workers/references/scale/#%E4%B8%89%E9%A2%84%E7%95%99%E7%AD%96%E7%95%A5">【预留策略】</a>。</li>
</ol>
<h5>一、基础模式</h5>
<p>当流量进入 Data Plane 后，如果没有能够处理请求的 Worker 实例，会通过&nbsp;requestQueueing&nbsp;事件通知 Control Plane，它会根据当前水位决定扩容数量，如果当前已无法创建 Worker 实例，会返回资源上限报错。新的 Worker 实例启动后，会自动连接到 Data Plane，Data Plane 发现新的 Worker 实例连接后会主动触发初始化请求，初始化成功后开始消费请求队列里堆积的请求。</p>
<p>当 Worker 实例闲置一段时间后，Control Plane 会主动发起 GC 操作，告知 Data Plane 关闭流量，流量关闭后，Control Plane 会通知 Turf 关闭 Worker 实例，清理资源残留。
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01TWklUC1OusEnQ5ENK_!!6000000001766-2-tps-1207-1020.png" alt="基础弹性模式"></p>
<h5>二、即抛模式</h5>
<p>针对特定的灵活场景，一次性的轻量用户脚本执行（比如特别高密度的混部执行二方任务如 SSR），为了隔离不同请求间的上下文，可以针对每个请求创建一个实例，并在执行后销毁。
<img src="https://gw.alicdn.com/imgextra/i3/O1CN01k7ZGMG1DHWQzoQWSV_!!6000000000191-2-tps-1207-1020.png" alt="即抛模式">
在常规 Node.js 实例带上业务逻辑启动一般都不会太快，如果直接用于响应用户流量 RT 会难以接受。得益于 Aworker 运行时的 Warmfork 以及 Startup Snapshot 能力，把部分业务初始化逻辑放置到 Warmfrok 特性中，进而让新实例都是更快的启动并具备响应能力，这才让高密度混部二方任务成为可能。</p>
<h2>二、Noslate Debugger</h2>
<p><img src="https://gw.alicdn.com/imgextra/i1/O1CN010OWgpL1yU9IWuE5XG_!!6000000006581-2-tps-1270-339.png" alt="Noslate Debugger">
Noslate Debugger 是针对 V8 应用的离线分析工具，它可以分析 Node.js 等应用程序产生的 Corefile (Core 文件)：</p>
<ol>
<li>检查 Node.js/V8 应用程序的结构体、堆栈等内容</li>
<li>检查 V8 堆内的各种对象信息</li>
<li>从 Corefile 中导出 Heap Snapshot</li>
<li>业务无感获取 Corefile (通过 Arthur 工具)</li>
<li>已支持 Node.js / AWorker LTS 官方发行版</li>
</ol>
<p>为了更好的解决问题而不是造轮子，在未来的几个月 Noslate Debugger 也会和国内社区 Node.js 稳定性领域优秀的开源软件 Easy Monitor 共建整合，在 Node.js/V8 的问题诊断领域形成合力，也是值得期待的事情。</p>
<h5>优点一：基于 Corefile 的 “快照” 更适应 Serverless</h5>
<p>Serverless 应用通常会使用大量生命周期短、规格小的任务实例，但在此类任务实例上获得调试诊断能力并不容易，这使得 Serverless 应用长期处于较为黑盒的窘境。比如，Inspector 需要稳定和长时的网络连接、运行时 Heap Snapshot 需要较多的计算和内存资源，都是和 Serverless 架构背道而驰的。</p>
<p>不管是 V8 的对象还是堆快照，它都是 “信息” 在内存中的存储，而 Inspector 功能就是可以在 “运行时” 能提取这些信息。Noslate Debugger 通过 Corefile 将这部分调试诊断能力转移到了离线时进行，让原有实时性要求高的在线诊断调试转化为只需简单文件上传即可集成使用。</p>
<p>在用户本地或云端服务上提供接近用户本地开发时的调试诊断体感：
<img src="https://gw.alicdn.com/imgextra/i2/O1CN01OCIltT1LGcaAR4r8G_!!6000000001272-2-tps-861-519.png" alt="调试流程"></p>
<blockquote>
<p>Corefile (特指 GNU Corefile 格式) 主要记录的是 Node.js 进程的内存和寄存器转储(CoreDump: 内存到磁盘的过程)。所以它也是进程完整“信息”，被用于 Linux 系统应用&nbsp;Crash(有损)&nbsp;的调试载体，也可用于&nbsp;GCore(无损)&nbsp;产生进程快照用于离线分析。</p>
</blockquote>
<h5>优点二：更小的业务影响​</h5>
<p>对比原有线上 “堆快照” 对业务的影响长达数分钟，到只影响业务 RT 秒级（通过&nbsp;GCore），甚至只有几十毫秒 （通过&nbsp;Arthur 工具）。Corefile&nbsp;快照也不会有任何运行时的"添油加醋"，所以它也适合那些还未被GC的对象定位，譬如诊断已经结束了的业务处理等。</p>
<p>Arthur&nbsp;是 Noslate Debugger 中用于低影响获取&nbsp;core文件的工具，利用 fork 减少进程暂停时间，LZ4 压缩减少转储体积。带业务流量的线上环境抓取，业务影响 31.106 毫秒，Corefile 大小为 338 MB （进程原使用 1.44GB 物理内存）。</p>
<h2>三、Node.js 发行版</h2>
<p><img src="https://gw.alicdn.com/imgextra/i1/O1CN01wxGn641fHLWa312QP_!!6000000003981-2-tps-1270-339.png" alt="Anode">
我们还对 Node.js 的实例进行了定向弹性场景的优化，提高了用户代码的加载速度，从而降低了冷启动时间。主要包括 Require 关系加速、Bytecode Cache，优化效果提升可高达 100% ~ 200%。该发行版，同时包含来自阿里云基础软件团队在 ARM 架构的性能优化特性。</p>
<h3>冷启动优化</h3>
<p>PGO（Profile Guided Optimization），是一种根据运行时 Profiling Data 来进行编译优化的技术，这里我们借鉴了这一概念。主要是通过执行一遍之后收集启动阶段的热点数据生成缓存文件，后续通过内存映射直接加载高效的缓存文件，即可获得提升在 100% ~ 200% 的用户代码冷启动优化效果。
<img src="https://gw.alicdn.com/imgextra/i4/O1CN01nHx1UD1yE7Qqlfef6_!!6000000006546-2-tps-1164-930.png" alt="PGO 流程"></p>
<h3>面向特定平台架构优化</h3>
<p>Node.js 支持包括 x64、arm64 等在内的多种架构。 但针对 ARM 芯片的快速发展，上游版本往往仅提供基础适配，缺少针对新指令集的优化，导致在 ARM 芯片上无法获得潜在的性能提升。当下主流云厂商大都提供了 ARM 架构、高性价比的运行环境。 Noslate Node.js 发行版针对 ARM 等平台的优化可以让应用在这些架构上获得更高的性能和效率。
目前 Noslate Node.js 发行版已经在进行针对阿里云 Ampere、阿里云倚天的定制优化，未来计划包括支持龙蜥社区中的其他架构。主要包括：zlib 特性优化、其他一些利用 SIMD 的性能提升都在 PR 合并和准别中。
上面是对 Noslate Project 的简单介绍，如果想要详细了解可通过下述方式：
● GitHub: <a href="https://github.com/noslate-project/noslate">https://github.com/noslate-project/noslate </a>
● 网站：<a href="https://noslate.midwayjs.org/">https://noslate.midwayjs.org/</a>
● 龙蜥社区 SIG（特殊兴趣小组，有钉钉群）：<a href="https://openanolis.cn/sig/web-platform">https://openanolis.cn/sig/web-platform</a>
● 邮件列表：noslate-support@list.alibaba-inc.com</p>
<p>致谢
感谢阿里巴巴集团内业务方的支持，同时还要特别感谢所有给本项目贡献过代码、一起探索过技术方向伙伴们（包括不限于 legendecas、mariodu、zhaolei0505、XadillaX、umuoy1、oraluben、hyj1991 等）。</p>







标题：这个主打「听歌」功能的 web app，UI 发生了重大变化...
作者：enzeberg
发布日期：发布于 8 天前
文章内容：<p><img src="//static.cnodejs.org/Fg5rNitzL2mSiYAzDadW9o9XIvTy" alt="index.JPG">
<em>首页 (引入侧边栏，全局显示用户的歌单列表)</em></p>
<p><img src="//static.cnodejs.org/Fg3V7-Y2Zr6MBKD_t0WG1kIic-6I" alt="搜索薛之谦.JPG">
<em>搜索"薛之谦"</em></p>
<p><img src="//static.cnodejs.org/Fk9wkSI6nS73Jo4jwfjaorlGqy7h" alt="搜索巴赫旧约.JPG">
<em>搜索"巴赫旧约"</em></p>
<p><img src="//static.cnodejs.org/FnJo-Q2Yp71yR7fmmBtqxx5F0paD" alt="导入狂飙.JPG">
<em>导入专辑 《狂飙》OST</em></p>
<p><img src="//static.cnodejs.org/FkcB-uAPkV_FE8Dy6ZiVAn1507WW" alt="歌词_播放列表.JPG">
<em>歌词 &amp; 播放列表</em></p>
<p><strong><a href="https://tonzhon.com">https://tonzhon.com</a></strong>
GitHub: <a href="https://github.com/enzeberg/tonzhon-music">https://github.com/enzeberg/tonzhon-music</a></p>
<p>这个音乐 Web App 现在用上了 <strong>侧边栏</strong>，专门显示用户的歌单列表，并使其保持全局显示，从而强调用户自身的重要性，弱化环境的重要性。“一切以用户为中心”是它的宗旨。</p>
<p>它还把灰色背景改成了白色，把白色卡片改成了灰色线框 (有些左侧边框用上了其他颜色，便于用户区分不同的卡片)…</p>
<p>期待大家的建议~</p>







标题：最近找了一圈，没有一个好的crud，大家有啥好推荐吗？
作者：i5ting
发布日期：发布于 4 天前
文章内容：<p>技术栈
1、mysql
2、react
3、node框架（koa、fastify，midway）</p>
<p>cool-admin我看过。其他，大家有啥好推荐吗？</p>







标题：大家伙平时是怎么判断“基本数据类型”的？
作者：daGaiGuanYu
发布日期：发布于 9 天前
文章内容：<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values">mdn 上说</a>:</p>
<blockquote>
<p>All primitive types, except null, can be tested by the typeof operator. typeof null returns “object”, so one has to use === null to test for null.</p>
</blockquote>
<p>那么可不可以这样：</p>
<pre class="prettyprint language- js"><code>function isPrimative(target) {
  return typeof target != 'object' &amp;&amp; typeof target != 'function' || target === null
}
</code></pre><p>大家有没有想到什么反例，或更简洁的方式，感谢指导！</p>







标题：helux，一个鼓励服务注入的响应式react状态库
作者：fantasticsoul
发布日期：发布于 6 天前
文章内容：<h2>关于helux</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是一个鼓励服务注入，并支持响应式变更react的全新数据流方案，它的前身是<a href="https://github.com/concentjs/concent">concent</a>（一个类vue开发体验的高性能状态管理框架），但concent自身因为需要兼容class和function保持一致的语法，且为了对其<code>setup</code>功能，导致内部代码量实在太大，压缩后有<code>70</code>多kb，api暴露得也非常多，导致学习难度急剧上升，为了更符合现在非常流行的<code>DDD</code>围绕业务概念构建领域模型的编码趋势，<code>helux</code>一开始就设计为<code>鼓励服务注入</code>、<code>支持响应式变更</code>、<code>支持依赖收集</code>的轻量级react数据流方案。</p>
<p>它拥有以下优势：</p>
<ul>
<li>轻量，压缩后2kb</li>
<li>简单，仅暴露7个api，高频使用的仅<code>createShared</code>、<code>useObject</code>、<code>useSharedObject</code>、<code>useService</code>4个接口</li>
<li>高性能，自带依赖收集</li>
<li>响应式，支持创建响应式对象，在视图之外变更对象将同步更新视图</li>
<li>服务注入，配合<code>useService</code>接口轻松控制复杂业务逻辑，总是返回稳定的引用，可完全避免<code>useCallback</code>依赖烦扰了</li>
<li>状态提升0改动，所以地方仅需将<code>useObject</code>换为<code>useSharedObject</code>即可提升状态共享到其他组件</li>
<li>避免forwordRef 地狱，内置的<code>exposeService</code>模式将轻松解决父掉子时的<code>ref</code>转发晦涩理解问题和传染性（隔代组件需要层层转发）</li>
<li>ts友好，100% ts 编写，为你提供全方位类型提示</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88176d2bc14643e8b81d29fd72902a9d~tplv-k3u1fbpfcp-watermark.image?" alt="2.gif"></p>
<blockquote>
<p>该gif图和以下所有api均对应有在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>,欢迎fork并修改体验。</p>
</blockquote>
<p>为什么起名<code>helux</code>，虽然内心上我是把它作为<code>concent</code> v3版本去开发的，但因为它的变化实在太大，除了依赖收集不继承任何<code>concent</code>的特性，同时它也是伴随我开发的<a href="https://github.com/tnfe/hel">hel-micro</a>诞生一款作品，我期望它成为 hel-micro 生态的 luxury 级别的贡献，就将 hel-micro 和 luxury 两个词拼一起成为了 <code>helux</code>。</p>
<p>欢迎点星关注<a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>，它虽然较新，但已在我自己的使用场景中发挥功不可没的作用，现已加入hel-micro生态大仓，期待能成为你愿意挑选的一款可心数据流方案。</p>
<h2>快速上手</h2>
<p>极致的简单是helux最大的优势，了解以下6个api后，你可以轻松应付任何复杂场景，最大的魅力在于<code>useSharedObject</code>和<code>useService</code>两个接口，且看如下api介绍，或访问在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>fork并修改来体验。</p>
<h3>useObject</h3>
<p>使用 useObject 有两个好处</p>
<ul>
<li>1 方便定义多个状态值时，少写很多 useState</li>
<li>2 内部做了 unmount 判断，让异步函数也可以安全的调用 setState，避免 react 出现警告 :
“Called SetState() on an Unmounted Component” Errors</li>
</ul>
<pre class="prettyprint language-ts"><code>// 基于对象初始化一个视图状态
const [state, setState] = useObject({a:1});
// 基于函数初始化一个视图状态
const [state, setState] = useObject(()=&gt;({a:1}));
</code></pre><h3>useForceUpdate</h3>
<p>强制更新当前组件视图，某些特殊的场景可以使用它来做视图重刷新</p>
<pre class="prettyprint language-ts"><code>const forUpdate = useForceUpdate();
</code></pre><h3>createSharedObject</h3>
<p>创建一个共享对象，可透传给 <code>useSharedObject</code>，具体使用见 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const sharedObj = createSharedObject({a:1, b:2});
// 基于函数初始化一个共享对象
const sharedObj = createSharedObject(()=&gt;({a:1, b:2}));
</code></pre><h3>createReactiveSharedObject</h3>
<p>创建一个响应式的共享对象，可透传给 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const [reactiveObj, setState] = createReactiveSharedObject({a:1, b:2});

sharedObj.a = 111; // 任意地方修改 a 属性，触发视图渲染
setSharedObj({a: 111}); // 使用此方法修改 a 属性，同样也能触发视图渲染，深层次的数据修改可使用此方法
</code></pre><h3>createShared</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function createShared&lt;T extends Dict = Dict&gt;(
  rawState: T | (() =&gt; T),
  enableReactive?: boolean,
): {
  state: SharedObject&lt;T&gt;;
  call: &lt;A extends any[] = any[]&gt;(
    srvFn: (ctx: { args: A; state: T; setState: (partialState: Partial&lt;T&gt;) =&gt; void }) =&gt; Promise&lt;Partial&lt;T&gt;&gt; | Partial&lt;T&gt; | void,
    ...args: A
  ) =&gt; void;
  setState: (partialState: Partial&lt;T&gt;) =&gt; void;
};
</code></pre><p>创建一个响应式的共享对象，可透传给 useSharedObject，它是<code>createReactiveSharedObject</code>和<code>createSharedObject</code>的结合体，当需要调用脱离函数上下文的服务函数时（即不需要感知组件props时），可使用该接口，第二位参数为是否创建响应式状态，为 true 时效果同 <code>createReactiveSharedObject</code> 返回的 sharedObj</p>
<pre class="prettyprint"><code> const ret = createShared({ a: 100, b: 2 });
 const ret2 = createShared({ a: 100, b: 2 }, true); // 创建响应式状态
 // ret.state 可透传给 useSharedObject
 // ret.setState 可以直接修改状态
 // ret.call 可以调用服务函数，并透传上下文
</code></pre><p>以下将举例两种具体的定义服务函数的方式，之后用户便可在其他其他地方任意调用这些服务函数修改共享状态了，如需感知组件上下文，则需要用到下面介绍的<code>useService</code>接口去定义服务函数。</p>
<pre class="prettyprint"><code>// 调用服务函数第一种方式，直接调用定义的函数，配合 ret.setState 修改状态
function changeAv2(a: number, b: number) {
   ret.setState({ a, b });
}
*
// 第二种方式，使用 ret.call(srvFn, ...args) 调用定义在call函数参数第一位的服务函数
function changeA(a: number, b: number) {
   ret.call(async function (ctx) { // ctx 即是透传的调用上下文，
     // args：使用 call 调用函数时透传的参数列表，state：状态，setState：更新状态句柄
     // 此处可全部感知到具体的类型
     // const { args, state, setState } = ctx;
     return { a, b };
   }, a, b);
 }
</code></pre><h3>useSharedObject</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function useSharedObject&lt;T extends Dict = Dict&gt;(sharedObject: T, enableReactive?: boolean): [
  SharedObject&lt;T&gt;,
  (partialState: Partial&lt;T&gt;) =&gt; void,
]
</code></pre><p>接收一个共享对象，多个视图里将共享此对象，内部有依赖收集机制，不依赖到的数据变更将不会影响当前组件更新</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
</code></pre><p><code>useSharedObject</code>默认返回非响应式状态，如需要使用响应式状态，透传第二位参数为true即可</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
// now obj is reactive
 setInterval(()=&gt;{
  state.a = Date.now(); // 触发视图更新
 }, 2000);
</code></pre><h3>useService</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>/**
 * 使用用服务模式开发 react 组件：
 * @param compCtx
 * @param serviceImpl
 */
function useService&lt;P extends Dict = Dict, S extends Dict = Dict, T extends Dict = Dict&gt;(
  compCtx: {
    props: P;
    state: S;
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
  },
  serviceImpl: T,
): T &amp; {
  ctx: {
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
    getState: () =&gt; S;
    getProps: () =&gt; P;
  };
}
</code></pre><p>它可搭配<code>useObject</code>和<code>useSharedObject</code>一起使用，会创建服务对象并返回，该服务对象是一个稳定的引用，且它包含的所有方法也是稳定的引用，可安全方法交给其它组件且不会破会组件的pros比较规则，避免烦恼的<code>useMemo</code>和<code>useCallback</code>遗漏相关依赖</p>
<p>搭配<code>useObject</code>时</p>
<pre class="prettyprint language-ts"><code>function DemoUseService(props: any) {
  const [state, setState] = useObject({ a: 100, b: 2 );
  // srv本身和它包含的方法是一个稳定的引用，
  // 可安全的将 srv.change 方法交给其它组件且不会破会组件的pros比较规则
  const srv = useService({ props, state, setState }, {
    change(a: number) {
      srv.ctx.setState({ a });
    },
  });
  
  return &lt;div&gt;
    DemoUseService:
    &lt;button onClick={() =&gt; srv.change(Date.now())}&gt;change a&lt;/button&gt;
  &lt;/div&gt;;
}
</code></pre><p>搭配<code>useSharedObject</code>时，只需替换<code>useObject</code>即可，其他代码不用做任何改变</p>
<pre class="prettyprint language-diff"><code>+ const sharedObj = createSharedObject({a:100, b:2})

function DemoUseService(props: any) {
-  const [state, setState] = useObject({ a: 100, b: 2 );
+  const [state, setState] = useSharedObject(sharedObj);
</code></pre><h4>getState 和 getProps</h4>
<p>因 <code>state</code> 和 <code>props</code> 是不稳定的，所以服务内部函数取的时候需从<code>srv.ctx.getState</code>或<code>srv.ctx.getProps</code></p>
<pre class="prettyprint language-ts"><code>// 抽象服务函数
export function useChildService(compCtx: {
  props: IProps;
  state: S;
  setState: (partialState: Partial&lt;S&gt;) =&gt; void;
}) {
  const srv = useService&lt;IProps, S&gt;(compCtx, {
    change(label: string) {
      // !!! do not use compCtx.state or compCtx.state due to closure trap
      // console.log("expired state:", compCtx.state.label);

      // get latest state
      const state = srv.ctx.getState();
      console.log("the latest label in state:", state.label);
      // get latest props
      const props = srv.ctx.getProps();
      console.log("the latest props when calling change", props);

      // your logic
      compCtx.setState({ label });
    }
  });
  return srv;
}

export function ChildComp(props: IProps) {
  const [state, setState] = useObject(initFn);
  const srv = useChildService({ props, state, setState });
}

 return (
    &lt;div&gt;
      i am child &lt;br /&gt;
      &lt;button onClick={() =&gt; srv.change(`self:${Date.now()}`)}&gt;
        change by myself
      &lt;/button&gt;
      &lt;h1&gt;{state.label}&lt;/h1&gt;;
    &lt;/div&gt;
  );
</code></pre><h4>exposeService</h4>
<p>当孩子组件props上透传了<code>exposeService</code>函数时，<code>useService</code> 将自动透传服务对象给父亲组件，是一种比较方便的逃离<code>forwardRef</code>完成父调子的模式</p>
<pre class="prettyprint language-ts"><code>import { ChildSrv, Child } from "./Child";

function App() {
  // 保存孩子的服务
  const childSrv = React.useRef&lt;{ srv?: ChildSrv }&gt;({});
  const seeState = () =&gt; {
    console.log("seeState", childSrv.current.srv?.ctx.getState());
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; childSrv.current.srv?.change(`${Date.now()}`)}&gt;
        call child logic
      &lt;/button&gt;
      &lt;Child
        unstableProp={`${Date.now()}`}
        exposeService={(srv) =&gt; (childSrv.current.srv = srv)}
      /&gt;
    &lt;/div&gt;
  );
}
</code></pre><h2>结语</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是把<a href="https://github.com/concentjs/concent">concent</a>内部精华全部萃取提炼再加工后的全新作品，期望能得到你的喜欢与鼓励。❤️</p>







标题：fabric.js开发图片编辑器可以实现哪些功能？多图
作者：nihaojob
发布日期：发布于 6 天前
文章内容：<p>最近使用fabric.js开发了一个图形编辑器并开源了，已收到900+star，<strong>很多开发者咨询fabric.js能实现哪些功能</strong>，今天就用文字加动图的形式直观的分享出来，帮助大家做参考。</p>
<p>fabric.js 提供强大的底层能力，可实现<strong>自定义模板、素材、字体，图片滤镜、辅助线、组合、裁剪等功能，也提供了自定义元素等高级的用法</strong>。</p>
<p>项目：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>
<p>预览：<a href="https://nihaojob.github.io/vue-fabric-editor/#/">https://nihaojob.github.io/vue-fabric-editor/#/</a></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89169a52052245839413826e3a9b9ac0~tplv-k3u1fbpfcp-watermark.image?" alt="screenshot-20230415-142257.png"></p>
<h2>画布功能</h2>
<p><strong>画布属性：尺寸、预设大小、背景色。</strong>
支持修改画布尺寸，也有预常用预设的画布尺寸，可以便捷设置，有背景色修改属性，同时提供常用颜色的快捷修改。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044e2d09049f489f9341263862674fb9~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415120741_rec_.gif"></p>
<p><strong>画布缩放：放大、缩小、自动适应、鼠标滚轮缩放。</strong>
支持画布放大缩小操作，可按照1:1尺寸展示或自适应展示，页面窗口改变时会根据窗口大小自适应展示；滑动鼠标滚轮时可快捷缩放画布。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6950ef15074c494e9d277a5b46c2c9f2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415121804_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570f0c1bb2434593949b65234972f1b4~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122049_rec_.gif"></p>
<p><strong>其他细节：拖拽画布、画布区域外显示控制条。</strong>
画布支持拖拽操作，按住alt快捷键，可以拖动画布；当元素拖拽到画布外区域时，仍然展示控制条，但元素并不会被展示出来，所见即所得。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b050ef702a4449dbce41b27a525a7e2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122246_rec_.gif"></p>
<h2>辅助功能</h2>
<p><strong>控制条：</strong> 在满足元素缩放、旋转的基础上尽量让其简洁，提供了2种样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bba9a276e24db99653513bafb23f75~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123406_rec_.gif"></p>
<p><strong>标尺：</strong> 标尺与辅助线可以满足我们更高要求的设计场景。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3489af30b75e4ecdbd037f7dddfbd10a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123622_rec_.gif"></p>
<p><strong>快捷调整：</strong> 图层管理、右键菜单、快捷键。
图层可以直观的定位元素的层级顺序，右键菜单提供了常用的快捷功能，还支持复制、删除等快捷键操作，提高操作效率。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b2176cb3e4ce0bc973d27cd58d705~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415125124_rec_.gif"></p>
<h2>基础元素</h2>
<p><strong>字体元素：</strong> 字体元素有普通字体、框字体，框字体可调整外边框，自动换行。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2dd53747534bbba5273787cced287a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130158_rec_.gif"></p>
<p><strong>基础形状：</strong> 有矩形、圆形、三角形、多边形，可直接点击或拖拽添加到画布。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa5a10f62049cdbd7a6f0d10760e29~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130303_rec_.gif"></p>
<p><strong>线条元素：</strong> 支持箭头、线条元素绘制。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1209cdaee70b4f38b7eef8987d6d676d~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131152_rec_.gif"></p>
<p><strong>插入元素：</strong> 支持插入多种图片类型，图片图片、SVG元素、SVG字符串。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba18715bb24d46719d8883a90d127152~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130901_rec_.gif"></p>
<p><strong>自定义素材：</strong> 素材在左侧分类展示，可定义图片素材、字体样式素材。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97231aaa1f145f1965c1a7ee935e442~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131012_rec_.gif"></p>
<h2>文件功能</h2>
<p><strong>数据保存：</strong> 支持导出/导出JSON文件方便存储数据，可自定义设计模板。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff449fe3b9b4f08b5e51f5072b164ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131754_rec_.gif"></p>
<p><strong>图片保存：</strong> 可清空画布、预览图片、保存图片文件。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9b6eef8f2d46a284acccaa15710f39~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131852_rec_.gif"></p>
<h2>属性设置</h2>
<p><strong>基础操作：</strong> 所有元素都可以在属性面板调整透明度、坐标、旋转角度。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b96af734d4a03bfeb003de4d04865~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133918_rec_.gif"></p>
<p><strong>锁定与组合：</strong> 锁定元素后元素将不会收到其他操作影响；可将多个元素组合为一个组元素，也可以将组元素拆分为多个元素。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d836659d849d0ba115a5ec2e3b959~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132328_rec_.gif"></p>
<p><strong>元素对齐：</strong> 单个元素支持相对于画布的水平、垂直、水平垂直居中，多个元素支持上、下、左、右对齐，水平居中、垂直居中、垂直平均分布、水平平均分布功能。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71eae7cab77489d8ffb51edb3c66f11~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132516_rec_.gif">
**自定义字体：**可自定义字体、对齐方式、行高、背景色、下划线、删除线等信息。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eae4c5d03474d28b25fa64e82ef87e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>渐变配置：</strong> 渐变是设计的重要形式之一，支持为元素、字体设置渐变颜色。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf12add8983481cb2a11bcd0a33614e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>边框设置：</strong> 支持为元素增加边框样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349ce94cbc0f4aae99ec59d72ea73346~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415134137_rec_.gif"></p>
<p><strong>图片操作：</strong> 快捷替换、简单滤镜、复杂滤镜。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4998294d7f11404fad58321bfb4f22ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133617_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21f01ec7ccd40458693d0e0b8cb43a7~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133505_rec_.gif"></p>
<h2>总结</h2>
<p>fabric.js 的底层能力非常强大，这依赖于灵活的底层接口，但是太过灵活也有一个弊端，那就是我们必须掌握更多的细节才能用起来得心应手，这对于开发者来说并不会太轻松。</p>
<p><a href="https://github.com/nihaojob/vue-fabric-editor">vue-fabric-editor</a>项目致力于打造一个开箱即用的web图片编辑器应用，同时<strong>沉淀一个介于web图片编辑器应用与fabric.js之间的封装层</strong>，期望封装层面向开发者设计，<strong>提供更简单的接口，让开发者可以轻松的实现图片应用开发</strong>。</p>
<h2>邀请</h2>
<p>通过技术社区和开源的方式和大家相识是一种很奇妙的体验，大部分都是在使用fabric.js做项目的开发者，我们组建了fabric.js开发者交流群，一起抱团取暖互相支招，一边吐槽文档，一起实现功能，欢迎你的加入交流群。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e358ff17a16e4f6e946291c7beeac0d4~tplv-k3u1fbpfcp-watermark.image?" alt="WechatIMG391.jpeg"></p>
<p>我们离目标还有很长的距离，如果你对这件事情感兴趣，真诚的邀请你加入，我们一起沉淀fabric.js的最佳实践，<strong>你会得到包括不限于以下列表的收获，你只要会简单的Git和Javascript语法就可以</strong>。</p>
<ul>
<li>熟悉开源协作方式，成为项目贡献者。</li>
<li>Vue3 + TS实践，边学边开发。</li>
<li>fabric.js开发，边学边开发。</li>
<li>入门单元测试，边学边开发。</li>
<li>众多的fabric.js开发者交流。</li>
</ul>
<p>我自己是第一次搞开源项目，感谢项目的贡献者的帮助和社区的推动，<strong>这是一个很新的项目和社区，期待你的加入，希望我们一起边走边学，在未来一起成为知名开源项目的开发者</strong>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d96501901c48c8ba76d6a64ca4a185~tplv-k3u1fbpfcp-watermark.image?" alt="海报.png"></p>







标题：使用fabric.js 快速开发一个图片编辑器
作者：nihaojob
发布日期：发布于 6 个月前
文章内容：<p>最近自己开发了一个图片编辑器，把源码也放在了GitHub上，顺便也总结下使用fabric.js开发一个编辑器需要用到哪些知识点。</p>
<ul>
<li>预览地址：<a href="https://nihaojob.github.io/vue-fabric-editor/">https://nihaojob.github.io/vue-fabric-editor/</a></li>
<li>GitHub地址：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ca4329b4c24dcea91e624ccadf4127~tplv-k3u1fbpfcp-watermark.image?" alt="Foxmail20220904011310.png"></p>
<h3>架构设计</h3>
<p><strong>选型：</strong> fabric.js 和 konva.js都是强大的canvas库，功能上类似，konva.js比较新中文文档也多一些，因为比较熟悉fabric就没有采用konva。</p>
<p><strong>要点：</strong> 因为框架用的vue，主要解决如何把fabric的实例对象共享给各个功能组件，区分出是未选中、单选、多选状态，然后将选中、取消选中事件暴露给各个功能组件，子组件根据状态进行独立的功能开发。</p>
<p>我的方法是在入口文件中初始化实例，然后与mixins结合，在mixins中定义了选择类型（多选、单选、未选中）、选中元素类型、选中id等属性，以及选中、取消选中的事件，子组件通过引入mixins来开发对应功能；如子组件需要对fabric对象进行操作，则可以通过inject获得原始对象。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d79b361a2549eea30d199e59b36344~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>入口文件：
<a href="https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L113">https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L113</a></p>
<p>mixins文件：
<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/mixins/select.js">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/mixins/select.js</a></p>
<h3>初始化</h3>
<p>初始化比较简单，fabric.js创建对象，用EventEmitter创建事件发射器，可订阅单选、多选、取消选择事件。
通过vue的provide语法把fabric对象、EventEmitter对象向下传递，在mixins中保存选中的元素和选中状态。</p>
<p><strong>初始化：</strong>
<a href="https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L111">https://github.com/nihaojob/vue-fabric-editor/blob/161faae7b0adcf6f55d9efaa38cb6d7c6d2c01b5/src/views/HomeView.vue#L111</a></p>
<p><strong>事件发射器：</strong></p>
<pre class="prettyprint"><code>import EventEmitter from 'events'

class EventHandle extends EventEmitter {

    init(handler){
        this.handler = handler
        this.handler.on("selection:created", (e) =&gt; this._selected(e));
        this.handler.on("selection:updated",  (e) =&gt; this._selected(e));
        this.handler.on("selection:cleared", (e) =&gt; this._selected(e));
    }

    // 暴露单选多选事件
    _selected(e) {
        const actives = this.handler.getActiveObjects()
        if(actives &amp;&amp; actives.length === 1) {
            this.emit('selectOne', actives)
        }else if(actives &amp;&amp; actives.length &gt; 1){
            this.mSelectMode = 'multiple'
            this.emit('selectMultiple', actives)
        }else{
            this.emit('selectCancel')
        }
    }
}

export default EventHandle
</code></pre><p><strong>mixins:</strong></p>
<pre class="prettyprint"><code>export default {
  inject: ['canvas', 'fabric', 'event'],
  data() {
    return {
      mSelectMode: '', // one | multiple
      mSelectOneType: '', // i-text | group ...
      mSelectId: '', // 选择id
      mSelectIds: [], // 选择id
    }
  },
  created(){
    this.event.on('selectOne', (e) =&gt; {
      this.mSelectMode = 'one'
      this.mSelectId = e[0].id
      this.mSelectOneType = e[0].type
      this.mSelectIds = e.map(item =&gt; item.id)
    })

    this.event.on('selectMultiple', (e) =&gt; {
      this.mSelectMode = 'multiple'
      this.mSelectId = ''
      this.mSelectIds = e.map(item =&gt; item.id)
    })

    this.event.on('selectCancel', () =&gt; {
      this.mSelectId = ''
      this.mSelectIds = []
      this.mSelectMode = ''
      this.mSelectOneType = ''
    })
  },
  methods: {
    /**
     * @description: 保存data数据
     * @param {Object} data 房间详情数据
     */
    _mixinSelected({ event, selected }) {
      if(selected.length === 1) {
        const selectItem = selected[0]
        this.mSelectMode = 'one'
        this.mSelectOneType = selectItem.type
        this.mSelectId = [selectItem.id]
        this.mSelectActive = [selectItem]
      }else if(selected.length &gt; 1){
        this.mSelectMode = 'multiple'
        this.mSelectActive = selected
        this.mSelectId = selected.map(item =&gt; item.id)
      }else{
        this._mixinCancel()
      }
    },
    /**
     * @description: 保存data数据
     * @param {Object} data 房间详情数据
     */
     _mixinCancel(data) {
      this.mSelectMode =''
      this.mSelectId= []
      this.mSelectActive =[]
      this.mSelectOneType = ''
    },
  }
}

</code></pre><h3>背景设置</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2286f31ad81545579f8a0a4caf060d60~tplv-k3u1fbpfcp-watermark.image?" alt="背景.gif">
主要包括设置画布大小、设置背景颜色、设置背景图片，也可以设置背景重复方向。
<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/bgBar.vue">代码：</a></p>
<pre class="prettyprint language-"><code>// 设置大小
setSize() {
      this.canvas.c.setWidth(this.width);
      this.canvas.c.setHeight(this.height);
      this.canvas.c.renderAll()
},
// 设置背景图片
setBgImg(target) {
      const imgEl = target.cloneNode(true);
      imgEl.onload = () =&gt; {
        // 可跨域设置
        const imgInstance = new this.fabric.Image(imgEl, { crossOrigin: 'anonymous' });
        // 渲染背景
        this.canvas.c.setBackgroundImage(imgInstance, this.canvas.c.renderAll.bind(this.canvas.c), {
          scaleX: this.canvas.c.width / imgInstance.width,
          scaleY: this.canvas.c.width / imgInstance.width,
        });
        this.canvas.c.renderAll()
        this.canvas.c.requestRenderAll();
      }
},
// 背景颜色设置
setColor(color) {
      this.canvas.c.setBackgroundColor(color, this.canvas.c.renderAll.bind(this.canvas.c))
      this.canvas.c.backgroundImage = ''
      this.canvas.c.renderAll()
}
</code></pre><h3>插入元素</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d110915d044f91818a238df07bf767~tplv-k3u1fbpfcp-watermark.image?" alt="插入元素.gif">
主要包括插入基础元素文字、正方形、圆形、三角形、SVG元素，详见<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/tools.vue#L122">代码</a>：</p>
<pre class="prettyprint"><code>addText() {
      const text = new this.fabric.IText('万事大吉', {
        ...defaultPosition,
        fontSize: 40, id: uuid(),
      });
      this.canvas.c.add(text)
      this.canvas.c.setActiveObject(text);
},
addTriangle() {
      const triangle = new this.fabric.Triangle({
        top: 100,
        left: 100,
        width: 100,
        height: 100,
        fill: '#92706B'
      })
      this.canvas.c.add(triangle)
      this.canvas.c.setActiveObject(triangle);
},
</code></pre><p>导入SVG元素时，可以导入SVG文件或者字符串进行导入，调用fabric的loadSVGFromURL、loadSVGFromString方法进行导入，<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/importSvg.vue">详见代码</a>。</p>
<h3>属性调整</h3>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e780a1c7c0414f0896bf80ca69b4a35c~tplv-k3u1fbpfcp-watermark.image?" alt="属性调整.gif">
不同元素的属性会有差异，但通用属性是一致的，如填充颜色、坐标、旋转角度、透明度等，也有很多特定元素的特定属性，如文字的字体属性、图片的滤镜属性等，<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/attribute.vue">详见代码</a>。
字体属性可以自定义字体，需要先下载字体后再进行设置，可以通过fontfaceobserver工具库下载指定字体，成功后在设置字体名称。</p>
<pre class="prettyprint"><code>// 字体加载
var font = new FontFaceObserver(fontName);
font.load(null, 150000).then(() =&gt; {
    const activeObject = this.canvas.c.getActiveObjects()[0]
    activeObject &amp;&amp; activeObject.set('fontFamily', fontName);
    this.canvas.c.renderAll()
    this.$Spin.hide();
}).catch((err) =&gt; {
    this.$Spin.hide();
})
</code></pre><h3>元素对齐</h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd4ffa48d104810b895c82c705701d2~tplv-k3u1fbpfcp-watermark.image?" alt="对齐.gif">
元素对齐区分单选元素与多选元素，单选元素时只支持相对于画布水平、垂直、水平垂直对齐。</p>
<pre class="prettyprint"><code>// name为 centerH | centerV | center
position(name){
  const activeObject = this.canvas.c.getActiveObject()
  if(activeObject){
    activeObject[name]()
    this.canvas.c.renderAll()
  }
}
</code></pre><p>多元素对齐有上下左右对齐、水平、垂直对齐，主要是通过获得最边缘元素的坐标，然后进行计算排序，如顶部对齐代码：</p>
<pre class="prettyprint"><code>const activeObject = this.canvas.c.getActiveObject();
  if (activeObject &amp;&amp; activeObject.type === 'activeSelection') {
        const activeSelection = activeObject;
        console.log(activeSelection)
        const activeObjectTop = -(activeObject.height / 2);
        activeSelection.forEachObject(item =&gt; {
          item.set({
                top: activeObjectTop,
            });
            item.setCoords();
            this.canvas.c.renderAll();
        });
    }
}
</code></pre><p>平均分配会复杂一些，需要计算出边缘与元素间距，再进行设置，<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/align.vue">详见代码</a>。</p>
<h3>其他用法</h3>
<p>编辑器经常需要给元素进行分组/拆分组合、调整层级、回退、快捷键、画布放大/缩小、导入/导出文件等功能，不再一一罗列，这个小编辑器都已经支持，大家感兴趣的可以看源码。</p>
<ul>
<li><a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/group.vue">组合</a></li>
<li><a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/layer.vue">层级调整</a></li>
<li><a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/plugin/hotkeys.js">快捷键实现</a></li>
<li><a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/zoom.vue">画布放大缩小</a></li>
<li><a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/components/save.vue">导入/导出</a></li>
</ul>
<h3>总结</h3>
<p>fabric.js的功能很强大，可以很轻松的开发出一个简版的图片编辑器，自定义素材、模板、字体文件；还可以结合数据接口拼接模板生成图片，很轻松的实现定制模板 + 生成图片的功能，比如我的朋友借助我的功能 + 成语接口生成成语图片，在小红书上斩获了八千多的粉丝。</p>
<p>最后希望大家能够通过这个项目学习到fabric.js的基础用法，感兴趣的话可以一起维护这款小编辑器，欢迎star。</p>
<p><a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>







标题：《狼书(卷3)：Node.js高级技术》视频版本
作者：i5ting
发布日期：发布于 2 个月前
文章内容：<p><a href="https://talk.aliyun.com/live?id=11741877.9369914">https://talk.aliyun.com/live?id=11741877.9369914</a></p>
<p>以上内容仅代表嘉宾个人观点，于2023年2月14日发布于阿里云大咖说，存在一定时效性，仅供学习和参考。</p>







标题：聊聊 WebCodecs 实现 GIF 视频转码
作者：kinglisky
发布日期：发布于 8 天前
文章内容：<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d9d33079b840e3aa3d7d0b603139eb~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt=""></p>
<p>被裁了，最近在摸鱼写文档，这两天研究了下浏览器环境下摆脱 ffmpeg.wasm 实现 GIF 转视频的功能，现在浏览器提供的 API 越来越靠近底层，浏览器在发展个几年可能真没 Electron 啥事了 [狗头] 。</p>
<p>不重复发文了，发掘金了：<a href="https://juejin.cn/post/7221557738537549879">聊聊 WebCodecs 实现 GIF 视频转码</a></p>
<p>欢迎大佬们指教~</p>







标题：自己开发了编程课程搜索的小程序，基本慕课网的课程都能搜到
作者：mikfake
发布日期：发布于 9 天前
文章内容：<p>小程序使用uniapp开发，后端使用java。因为实后端java开发，前端不擅长，有一些地方写的不是很合理。不过主要目的还是分享免费的编程课程。正在找编程资源的可以看看，可能你要的就能搜到，每天都会更新一些资源。
<img src="//static.cnodejs.org/FmBeKhXk1La4M-1xzwnIiLRZq_Ip" alt="素材1.png">
<img src="//static.cnodejs.org/FgF93KX8qwHSlleM5X6Gmug5RFo2" alt="素材2.png">
<img src="//static.cnodejs.org/Fo3cR9S0MO2OPOBe9X1Mhb7M7GXg" alt="素材3.png">
<img src="//static.cnodejs.org/FnMtv4MbZU0NRrn1Q8Ql1gRYJDCc" alt="素材4.png">
<img src="//static.cnodejs.org/Fl4_GBEs_KDU3A8PzuqpHtym9FFg" alt="二维码.jpg"></p>







标题：NestJS e2e test报错：Class extends value undefined is not a constructor or null
作者：tashuo
发布日期：发布于 12 天前
文章内容：<p><img src="//static.cnodejs.org/FmtF2x_7JtxGcSAewTxaKIg7ysLc" alt="image.png"></p>
<p>在nestjs项目中运行e2e test报错，服务是正常的，是循环依赖的问题吗？</p>
<p>jest-e2e.json</p>
<pre class="prettyprint language-json"><code>{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "modulePaths": ["&lt;rootDir&gt;/../"],
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "moduleNameMapper": {
    "^@/(.*)$": "&lt;rootDir&gt;/../src/$1"
  }
}
</code></pre>






标题：react每个大版本都改变了啥？
作者：zzz6519003
发布日期：发布于 15 天前
文章内容：<p>。。。</p>







标题：NodeJS+Sequelize在生产环境下，最合适的建立连接池的方式是？
作者：monkeytwins
发布日期：发布于 15 天前
文章内容：<p>看官网文档里提到关于多进程的情况下，必须为每一个进程都创建sequelize实例：</p>
<blockquote>
<p>If you’re connecting to the database from multiple processes, you’ll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected.</p>
</blockquote>
<p>生产环境下，肯定是多负载多进程的情况，并且一般用cluster模块去进行进程处理</p>
<pre class="prettyprint language-js"><code>if (cluster.isMaster) {
    for (var i = 0; i &lt; env.CPU; i++) {
        cluster.fork();
    }

    cluster.on('fork', worker =&gt; {
        log(`worker ${worker.process.pid} forked success`, 'info', logOptions);
    });

    cluster.on('online', worker =&gt; {
        log(`worker ${worker.process.pid} responded after it was forked`, 'info', logOptions);
    });

    cluster.on('exit', function (worker, code, signal) {
        log(`worker ${worker.process.pid} died (${signal || code})`, 'warn', logOptions);
        cluster.fork();
    });
} else {
    require('../app.js');
}
</code></pre><p>想请教下这种情况下，Sequelize的实例初始化应该在什么阶段？</p>







标题：await 不能回调 sismember 吗
作者：yuexiangqianlong
发布日期：发布于 17 天前
文章内容：<p>在nodejs 里面执行
const result = await redis.sismember(<code>puzzle_user</code>,  key);
redis里面没有集合puzzle_user，result 返回的结果为啥是true</p>







标题：NestJs周下载量已经达到200多万了 用nestjs开发的人多还是midway多--各位老铁用的什么
作者：phonegap100
发布日期：发布于 1 个月前
文章内容：<p>NestJs周下载量已经达到200多万了 用nestjs开发的人多还是midway多？</p>
<p><img src="//static.cnodejs.org/Ftx8B1sj-zY5bLEFJA5ObHwGec8G" alt="nestjs8.png"></p>







标题：node.js 向下取整
作者：spitWind
发布日期：发布于 25 天前
文章内容：<p>发现了个奇怪的现象， 很多人都用的取整方式
~~(2418473332.1)， 0|(2418473332.1) 竟然是负数 -1876493964；</p>







标题：请大神帮帮忙，看看怎么设计这样的数据库？类似Github的标签功能。
作者：hz0324
发布日期：发布于 1 个月前
文章内容：<p>使用场景描述：</p>
<p>我们公司内部的一个系统，员工每次创建一个记录，可以给这个记录加标签。其中，有5个标签是固定的，提前设置好的，员工可以改掉它们，还可以添加自定义的标签。这个标签只有他自己能看到。我觉得这个功能需求跟Github的issue中提供的标签系统很像，但是不知道怎么设计数据库结构。</p>
<p>请问，这个场景下，使用MySQL数据库该怎么设计表结构啊？如果有必要，我们可以使用Redis。</p>
<p>请各位大神帮帮忙。</p>







标题：基于 React+Konva+TypeScript 拖动配置流程图，配置卡片参数表单欢迎在线体验
作者：myfirebug
发布日期：发布于 1 个月前
文章内容：<h1>基于 React 拖动配置流程图</h1>
<p>flow-chart 基于 React+konva+TypeScript 流程图开发，支持新增/编辑卡片，支持动态配置卡片参数表单（即动态配置表单功能），支持 GET、POST 接口在线调试，支持拖动配置流程图，支持拷贝、删除、撤销、恢复、全选、对齐卡片等等。</p>
<p>项目纯前端-Demo 地址：<a href="https://myfirebug.github.io/flow-chart/index.html#/login">https://myfirebug.github.io/flow-chart/index.html#/login</a></p>
<p>用户名：admin, 密码：123456</p>
<p><strong>新增/编辑卡片图片</strong></p>
<p><img src="https://myfirebug.github.io/example-images/flow-chart/01.png" alt="RUNOOB 图标">
<img src="https://myfirebug.github.io/example-images/flow-chart/02.png" alt="RUNOOB 图标">
<img src="https://myfirebug.github.io/example-images/flow-chart/03.png" alt="RUNOOB 图标"></p>
<p><strong>新增/编辑流程图图片</strong>
<img src="https://myfirebug.github.io/example-images/flow-chart/04.png" alt="RUNOOB 图标"></p>
<p><strong>主要依赖：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>react</td>
<td>18.0.0</td>
<td>react-dom</td>
<td>18.0.0</td>
</tr>
<tr>
<td>typescript</td>
<td>4.6.3</td>
<td>jsoneditor</td>
<td>9.9.0</td>
</tr>
<tr>
<td>redux</td>
<td>4.1.2</td>
<td>react-redux</td>
<td>7.2.8</td>
</tr>
<tr>
<td>konva</td>
<td>8.4.2</td>
<td>redux-logger</td>
<td>3.0.6</td>
</tr>
<tr>
<td>redux-persist</td>
<td>6.0.0</td>
<td>redux-thunk</td>
<td>2.4.1</td>
</tr>
<tr>
<td>react-app-rewire</td>
<td>2.2.1</td>
<td>echarts</td>
<td>5.3.2</td>
</tr>
<tr>
<td>antd</td>
<td>4.19.3</td>
<td>axios</td>
<td>0.26.1</td>
</tr>
<tr>
<td>cross-env</td>
<td>7.0.3</td>
<td>customize-cra</td>
<td>1.0.0</td>
</tr>
<tr>
<td>react-konva</td>
<td>18.2.4</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>开发环境</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>node</td>
<td>16.17.0</td>
<td>npm</td>
<td>8.15.0</td>
</tr>
</tbody>
</table>
<p><strong>已完成功能</strong></p>
<table>
<thead>
<tr>
<th>页面</th>
<th>是否完成（功能）</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录</td>
<td>是</td>
</tr>
<tr>
<td>首页</td>
<td>是</td>
</tr>
<tr>
<td>流程</td>
<td>是</td>
</tr>
<tr>
<td>卡片列表</td>
<td>是</td>
</tr>
<tr>
<td>卡片新增/编辑</td>
<td>入参配置（input,textArea, number, pasword, select, checkboxGroup,radioGroup,cascader,switch，date,dateRange,time,timeRange,treeSelect 配置功能开发）置顶、置顶、上移、下移、复制、删除功能开发(正在开发中···)</td>
</tr>
<tr>
<td>流程图列表</td>
<td>是</td>
</tr>
<tr>
<td>流程图新增/编辑</td>
<td>支持拷贝、删除、撤销、恢复、全选、对齐卡片、ctrl+单机多选、卡片表参数配置（卡片新增/编辑里的拼入参配置表单使用）</td>
</tr>
</tbody>
</table>
<p><strong>已完成的组件</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input</td>
<td>TextArea</td>
<td>InputNumber</td>
</tr>
</tbody>
</table>
<h1>框架使用技术</h1>
<ul>
<li>框架为<code>create-react-app</code>构架，搭配<code>react-router-dom</code>、<code>redux</code>、<code>react-redux</code>、<code>redux-thunk</code>、<code>redux-persist</code>、<code>redux-logger</code>、<code>axios</code>，UI 框架为<code>antd@4.19.3</code></li>
</ul>
<h1>学习文档</h1>
<ul>
<li><a href="https://react.docschina.org" title="react中文官网">react 中文官网</a></li>
<li><a href="https://reactjs.org" title="react英文官网">react 英文官网</a></li>
<li><a href="http://cn.redux.js.org" title="redux中文官网">redux 中文官网</a></li>
<li><a href="https://redux.js.org" title="redux英文官网">redux 英文官网</a></li>
<li><a href="https://www.html.cn/create-react-app/docs/getting-started/" title="create-react-app中文文档">create-react-app 中文文档</a></li>
<li><a href="https://3x.ant.design/index-cn" title="antd官网">antd 官网</a></li>
<li><a href="https://github.com/timarney/react-app-rewired#readme" title="在不npm run inject的情况下修改webpack">react-app-rewired</a></li>
<li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" title="webpack-bundle-analyzer分析SPA应用">webpack-bundle-analyzer 分析 SPA 应用</a></li>
</ul>
<h1>依赖安装、启动、打包</h1>
<pre class="prettyprint"><code>## 克隆

## 启动开发环境（开发调试时使用）
### `npm start`

## 构建测试项目
## `npm build:test`

## 构建正式项目
### `npm build:production`

</code></pre><h1>目录结构</h1>
<pre class="prettyprint"><code>flow-chart
├── src
│   ├── assets                       // 静态资源
│   ├── components                   // 公共组件
│   ├── config                       // 配置文件
│   ├── mock                         // 模拟接口
│   ├── pages                        // 页面
│   │   ├── card-configuration       // 卡片配置页面
│   │   ├── diagrams-configuration   // 流程图配置页面
│   │   ├── frame                    // 框架页面
│   │   ├── home                     // 首页页面
│   │   ├── login                    // 登录页面
│   │   └── process                  // 流程图
│   │   │   └── card                 // 卡片列表
│   │   │   └── diagrams             // 流程列表
│   ├── service                      // 接口服务
│   ├── store                        // 状态
│   ├── types                        // ts基本类型
│   ├── utils                        // 工具
│   └── form                         // 组件及其配置
</code></pre><p><strong><a href="https://github.com/myfirebug/flow-chart">欢迎star</a></strong></p>







标题：node V16.16.0 无法使用import语句
作者：scottMan1001
发布日期：发布于 4 个月前
文章内容：<p>PS E:\study\forVideo&gt; npm run start</p>
<blockquote>
<p>microblog@0.0.0 start
node ./bin/www</p>
</blockquote>
<p>E:\study\forVideo\service\service.js:1
import got from “got”;
^^^^^^</p>
<p>SyntaxError: Cannot use import statement outside a module</p>
<p>请问这是为什么？
项目框架是 “express”: “~4.16.1”,
“got”: “^12.5.3”,</p>







标题：请问如何排查Nodejs进程退出原因，只有pid和dmseg信息，dmseg里面也没找到有用的信息
作者：assmdx
发布日期：发布于 1 个月前
文章内容：<p><a href="https://github.com/nodejs/tooling/issues/175">https://github.com/nodejs/tooling/issues/175</a></p>







标题：SlowJS!
作者：hsiaosiyuan0
发布日期：发布于 2 个月前
文章内容：<p><a href="https://github.com/hsiaosiyuan0/slowjs">SlowJS</a> - QuickJS 降速版本！</p>
<ul>
<li>将 5.4W 行 <a href="https://github.com/bellard/quickjs">quickjs.c</a> 进行拆分</li>
<li>增加断点调试功能</li>
<li>增加内存 dump WIP</li>
</ul>
<p>一起学习 QuickJS!</p>







标题：【🔥AI编码】cool-admin6.0预览版
作者：cool-team-official
发布日期：发布于 1 个月前
文章内容：<p><img src="https://show.cool-admin.com/AI%E7%BC%96%E7%A0%81.gif" alt="AI编码.gif"></p>
<p>cool-admin基于nodejs的后台管理系统开发框架</p>
<p><strong>官网</strong>
<a href="https://cool-js.com/">https://cool-js.com/</a></p>
<p><strong>演示地址</strong>
<a href="https://show.cool-admin.com">https://show.cool-admin.com</a>
账户：admin
密码：123456</p>







标题：绝对免费的AI绘画和ChatGpt
作者：cool-team-official
发布日期：发布于 1 个月前
文章内容：<p><img src="//static.cnodejs.org/FlSBO6MuaiLeKq5QuxAwxqkpxpya" alt="微信图片_20230317134522.jpg">
<img src="//static.cnodejs.org/FsJUy2c0VGU3hlaY3J4NNnvdqs_7" alt="微信图片_20230317134517.jpg">
<img src="//static.cnodejs.org/FpniM8qx15wLB3t_ra-vzZGLOPqo" alt="微信图片_20230317134527.jpg">
<img src="//static.cnodejs.org/FpFnYRtpNYMuvf21GPZg-gV68Gl8" alt="微信图片_20230317134535.jpg"></p>
<p>用法群里
<a href="/user/cool-ai">@cool-ai</a> + 你的问题  （ChatGPT聊天）
<a href="/user/cool-ai">@cool-ai</a> img + 你想生成的图片  （AI绘画）</p>
<p><img src="//static.cnodejs.org/FplcOosVU82faVewXT6DQO6VKZEo" alt="微信图片_20230317134542.jpg"></p>







标题：[🍭TerminalBot]我把chatGPT放到了终端里面，自定义多个小助手并快速提问
作者：xusenlin
发布日期：发布于 1 个月前
文章内容：<h1>TerminalBot</h1>
<p>chatGPT 简直是我们程序员的福音，可以说是一对一导师了，但是每次遇到问题还需要打开网页去提问，而且还一个字一个字的慢慢蹦，还要回复我英文，我看又看不懂，作为一个程序员怎么能忍受得了呢？</p>
<p>于是我就突发奇想，能不能直接在终端里面问问题，并且直接回复我中文，还有我想要翻译的时候，直接给我翻译，想要给变量名起名的时候，直接回复我变量名，不需要我过多的解释。</p>
<p>【🍭TerminalBot】它来了，先看看效果。</p>
<p><img src="//static.cnodejs.org/Fgbtyr_dMPKoRKlzAMzRihkL-LBM" alt="demo_zh.png">
<img src="//static.cnodejs.org/FvCCNhA6Vw48pxBVyQ_T8oEmi_iN" alt="demo2_zh.png">
我自定义了2个命令，分别是<code>bot</code>和<code>bot2</code> bot我给它添加了使用中文回复我的“prompt”，bot2我添加了给我翻译的“prompt”</p>
<p>看看bot命令的json配置</p>
<h2>bot</h2>
<pre class="prettyprint language-json"><code>{
  "authToken": "your authToken",
  "proxyURL": "http://127.0.0.1:7890",
  "questionPrefix": "",
  "prompt":[
    {
      "role": "system",
      "content": "你是xusenlin开发的一个终端chatGPT，你的名字叫TerminalBot，你的所有回答将使用中文回复。"
    },
    {
      "role": "system",
      "content": "TerminalBot的安装非常简单，只需要到https://github.com/xusenlin/terminal-bot下载一个名为bot的二进制文件，然后放到你的环境变量里面，在用户目录下填写bot.json配置，提问的时候输入```bot -q 你的问题```就能快速得到回答,这样你就可以拥有一个终端机器人助手了，非常酷。如果你想拥有更多的终端机器人助手,只需要复制一份二进制文件重命名为bot2，然后填写相应的bot2.json配置文件就行。"
    }
  ]
}
</code></pre><h2>bot2</h2>
<pre class="prettyprint language-json"><code>{
  "authToken": "xxx",
  "proxyURL": "http://127.0.0.1:7890",
  "questionPrefix": "翻译:",
  "prompt": [
    {
      "role": "system",
      "content": "你是一个翻译助手，你不要回答用户的任何问题，如果用户向你发送中文，你直接回复翻译好的英文，如果用户向你发送英文，你直接回复翻译好的中文。"
    }
  ]
}
</code></pre><p>哈哈，不知道你有好的prompt推荐不，这样我们就能配置各式各样的小助手了，工作效率嘎嘎快。</p>
<p>开源了，<a href="https://github.com/xusenlin/terminal-bot">https://github.com/xusenlin/terminal-bot</a>
喜欢不要吝啬给个星星哇。</p>







标题：看看CabloyJS是如何异步加载并执行go wasm模块的
作者：zhennann
发布日期：发布于 1 个月前
文章内容：<h2>介绍</h2>
<p>CabloyJS提供了一个内置模块<code>a-wasmgo</code>，将go wasm模块的异步加载运行机制进行了封装，使我们可以非常方便的在CabloyJS项目中引入go wasm，从而支持更多的业务场景开发</p>
<p>下面，我们以测试模块<code>test-party</code>为例，演示引入go wasm模块并运行需要哪几个步骤</p>
<h2>效果演示</h2>
<ul>
<li>请直接打开此演示页面：<a href="https://test.cabloy.com/#!/test/party/wasm_go">https://test.cabloy.com/#!/test/party/wasm_go</a></li>
</ul>
<h2>1. 准备工作</h2>
<ol>
<li>
<p>安装go环境：参见 <a href="https://go.dev/doc/install">https://go.dev/doc/install</a></p>
</li>
<li>
<p>创建CabloyJS项目：参见 <a href="https://cabloy.com/zh-cn/articles/guide-quick-start.html">https://cabloy.com/zh-cn/articles/guide-quick-start.html</a></p>
</li>
<li>
<p>安装test-party演示套件：参见 <a href="https://store.cabloy.com/zh-cn/articles/test-party.html">https://store.cabloy.com/zh-cn/articles/test-party.html</a></p>
</li>
</ol>
<h2>2. 开发一个go wasm模块</h2>
<h3>2.1 go源码</h3>
<p><code>src/suite-vendor/test-party/modules/test-party/front/src/assets/wasm/demo.go</code></p>
<pre class="prettyprint language- go"><code>package main

import (
	"fmt"
	"syscall/js"
)

func main() {
	fmt.Println("Hello, World!")
	alert := js.Global().Get("alert")
	alert.Invoke("alert!")
}
</code></pre><ol>
<li>
<p>fmt.Println：在控制台输出一个字符串</p>
</li>
<li>
<p>js.Global().Get(“alert”)：获取网页中的window.alert方法</p>
</li>
<li>
<p>alert.Invoke：执行alert方法</p>
</li>
</ol>
<h3>2.2 编译wasm</h3>
<p>进入源码所在目录，将<code>demo.go</code>编译为<code>demo.wasm</code></p>
<pre class="prettyprint language- bash"><code>$ cd src/suite-vendor/test-party/modules/test-party/front/src/assets/wasm/
$ GOOS=js GOARCH=wasm go build -o demo.wasm demo.go
</code></pre><ul>
<li>更详细说明，请参见go官方文档：<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a></li>
</ul>
<h2>3. 加载并运行wasm</h2>
<p>测试模块<code>test-party</code>提供了一个演示页面，页面路径为：<a href="http://localhost:9092/#!/test/party/wasm_go">http://localhost:9092/#!/test/party/wasm_go</a></p>
<p>该页面提供了两个加载并运行wasm的方法：</p>
<h3>3.1 两步执行</h3>
<p><code>src/suite/test-party/modules/test-party/front/src/pages/wasm_go.jsx</code></p>
<pre class="prettyprint language- javascript"><code>import wasmDemo from '../assets/wasm/demo.wasm';
...
async onPerformRun1() {
  // go
  let action = {
    actionModule: 'a-wasmgo',
    actionComponent: 'sdk',
    name: 'go',
  };
  const go = await this.$meta.util.performAction({ ctx: this, action });
  // load wasm
  action = {
    actionModule: 'a-wasmgo',
    actionComponent: 'sdk',
    name: 'loadWasm',
  };
  const item = { source: wasmDemo };
  const wasmResult = await this.$meta.util.performAction({ ctx: this, action, item });
  // run
  await go.run(wasmResult.instance);
},
</code></pre><ol>
<li>
<p>内置模块<code>a-wasmgo</code>是异步模块，提供了一个<code>sdk</code>组件，用于封装异步加载并运行wasm的逻辑。因此需要通过调用<code>performAction</code>方法异步加载<code>a-wasmgo</code>模块，并调用其中的方法</p>
</li>
<li>
<p>第一步，调用<code>performAction</code>取得<code>go</code>实例</p>
</li>
<li>
<p>第二步，调用<code>performAction</code>异步加载<code>demo.wasm</code>模块</p>
</li>
<li>
<p>调用<code>go.run</code>执行wasm模块的实例</p>
</li>
</ol>
<h3>3.2 一步执行</h3>
<p><code>src/suite/test-party/modules/test-party/front/src/pages/wasm_go.jsx</code></p>
<pre class="prettyprint language- javascript"><code>import wasmDemo from '../assets/wasm/demo.wasm';
...
async onPerformRun2() {
  // load&amp;run wasm
  const action = {
    actionModule: 'a-wasmgo',
    actionComponent: 'sdk',
    name: 'run',
  };
  const item = { source: wasmDemo };
  await this.$meta.util.performAction({ ctx: this, action, item });
},
</code></pre><ol>
<li>调用<code>performAction</code>时，直接传入<code>demo.wasm</code>模块，从而一次完成加载与运行的逻辑</li>
</ol>
<h2>附：performAction说明</h2>
<ul>
<li>action</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>actionModule</td>
<td>模块名称，此处为<code>a-wasmgo</code></td>
</tr>
<tr>
<td>actionComponent</td>
<td>模块提供的组件，此处为<code>sdk</code></td>
</tr>
<tr>
<td>name</td>
<td>需要调用的方法名称，此处有以下可选值：<code>go/loadWasm/run</code></td>
</tr>
</tbody>
</table>
<ul>
<li>item</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>source</td>
<td>wasm模块的url地址，此处为<code>wasmDemo</code>，指向<code>'../assets/wasm/demo.wasm'</code></td>
</tr>
</tbody>
</table>
<h2><strong>相关链接</strong></h2>
<ul>
<li>
<p>文档：<a href="https://cabloy.com/">https://cabloy.com/</a></p>
</li>
<li>
<p>演示：<a href="https://test.cabloy.com/">https://test.cabloy.com/</a></p>
</li>
<li>
<p>GitHub源码仓库: <a href="https://github.com/zhennann/cabloy">https://github.com/zhennann/cabloy</a></p>
</li>
</ul>







标题：可不可以用 a == null 来代替  a === null || a === undefined
作者：daGaiGuanYu
发布日期：发布于 2 个月前
文章内容：<p>今天闲着没事看 coffeescript，发现 coffeescript 会把</p>
<pre class="prettyprint language- coffeescript"><code>a = undefined
if a?
  console.log a
</code></pre><p>翻译成：</p>
<pre class="prettyprint language- javascript"><code>var a;
a = void 0;
if (a != null) {
  console.log(a);
}
</code></pre><p>然后我想了想、试了试，发现 <code>0</code>、<code>false</code>、<code>""</code> 都不满足 <code>== null</code></p>
<p>于是我就想，可不可以使用 <code>a == null</code> 来代替  <code>a === null</code> || <code>a === undefined</code> 呢？</p>







标题：fabric.js开发图片编辑器的细节实现
作者：nihaojob
发布日期：发布于 2 个月前
文章内容：<p>之前写过一篇笔记，《<a href="https://juejin.cn/post/7155040639497797645">使用fabric.js 快速开发一个图片编辑器</a>》，简单介绍了如何用vue和fabric.js快速开发一款编辑器。</p>
<p>当时的版本比较粗糙，只能说是一个基础版的Demo，很多细节不够完善，参考了稿定设计和创客贴的设计编辑器，<strong>优化了很多必要的细节，也算是fabric.js的进阶用法</strong>，整理成笔记分享出来。</p>
<p>项目地址：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>
<p>预览地址：<a href="https://nihaojob.github.io/vue-fabric-editor/">https://nihaojob.github.io/vue-fabric-editor/</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb39b4abf3e940f8a9dc78032f4e7d0e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>正文</h2>
<h3>1、架构演进</h3>
<p>最早的设计是将 fabric.js创建的canvas对象通过provide传递给子组件使用，功能代码封装到vue组件中。前<strong>期基础功能尚能满足，但后期迭代时发现无法复用功能代码</strong>，如复制功能原来以按钮的形式存在，代码全部在复制组件中，在后期迭代中要在快捷键和右键菜单中增加复制功能，没办法复用；</p>
<p>所以在原来的基础上，封装出Editor对象，将通用方法挂载到Editor对象上实现复用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8862c4b7dab42ff821e2dda10d24290~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/core/index.js#L19">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/core/index.js#L19</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a832545a57474923802f5337a8d2cee2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>2、辅助线</h3>
<p>辅助线是很常见的必要功能，官方提供了辅助线方法，在官方仓库中，只需要引入方法即可。</p>
<p>实现代码：<a href="https://github.com/fabricjs/fabric.js/blob/master/lib/aligning_guidelines.js">https://github.com/fabricjs/fabric.js/blob/master/lib/aligning_guidelines.js</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb50b2869c664e879fdba2f316ac9cd9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>3、控制条样式</h3>
<p>稿定设计和创客贴的元素控制条看起来都很精致，而fabric.js自带的控制条较为简陋，可以通过自定义样式方法把控制条修饰的稍微美观一些。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initControls.js">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initControls.js</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2222e0689def499caf5b8416d7907760~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f582bd8f2645a080b18b78ea80b8fc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9214a3a0cf7246c49d191f7c20a6fccb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>4、右键菜单</h3>
<p>fabric.js并没有自带右键菜单的功能，但可以监听到右键菜单事件，我们可以通过监听方法来实现右键菜单功能。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/mouseMenu.vue#L72">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/mouseMenu.vue#L72</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3ceb6963d14ddfb53a92387497e796~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>5、快捷键功能</h3>
<p>快捷键可以提高操作效率，比如组合/拆分组合、复制、删除等，只需要将快捷键事件和Editor的功能方法做绑定即可快速实现快捷键功能。</p>
<p>快捷键监听有现成的工具库<code>hotkeys-js</code>，只需要绑定事件即可。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initHotKeys.js">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initHotKeys.js</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c2ee439f53461699f603734352f040~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>6、锁定图层</h3>
<p>锁定元素可以让元素不可编辑，比如下图中的白色背景元素，设置大小和位置后就不希望再选中和它，可以设置图层锁定，这样编辑上方元素时就会干扰到下方元素。</p>
<p>使用<code>selectable</code>属性控制元素不可选中，需要注意的点是，当我们遍历所有元素时，要对锁定元素单独处理。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/lock.vue#L41">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/lock.vue#L41</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4620334fc7a64756ba950e0fa4d50db8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>7、画布大小调整</h3>
<p>最早的版本的画布大小调整就是对fabric.js的canvas大小做调整，这样做有2个问题，一是没办法将画布大小保存到json文件中，另外一个问题是缩小放画布时，缩小后画布颜色和背景颜色一致，无法区分画布的边界，效果较差。</p>
<p>最后的实现思路是，使用矩形元素模拟画布区域，fabric.js的canvas大小根据视口DOM的宽高自适应，通过调整矩形元素属性来设置画布到大小和颜色，其他元素通过属相面板修改属性。这样就解决了上边的2个问题。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initWorkspace.js">https://github.com/nihaojob/vue-fabric-editor/blob/main/src/core/initWorkspace.js</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6724b0d4ab37495eaf52b30c31c8da61~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>8、元素画布超出区域</h3>
<p>参考稿定设计和创客贴的编辑器，都有一个细节，就是当元素拖出画布区域后，看不到元素但可以展示控制条，由于画布是通过矩形模拟出来的，通过clipPath可以便捷的实现。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/commit/8512e3293f991dc8b2633669c4feb1514dca9a02">https://github.com/nihaojob/vue-fabric-editor/commit/8512e3293f991dc8b2633669c4feb1514dca9a02</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a18f16ca244b3d929891711eabc959~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>9、拖拽到画布</h3>
<p>将基础元素添加到画布有两种方式，一种是点击元素，会添加到画布中央，另一种是直接拖拽元素到画布，可以将元素添加到指定位置，使用拖拽事件实现。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/tools.vue#L163">https://github.com/nihaojob/vue-fabric-editor/blob/bf36aa6ba093d0d603d68482d201f0c78d2b1f2c/src/components/tools.vue#L163</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca86b6de9a144e5589de4f56624e845a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>10、渐变配置</h3>
<p>渐变在背景、字体颜色上很常用，fabric.js有提供渐变的配置方法，我们只需要按照纯色、渐变2种方式设置颜色即可，功能已实现，细节需要优化，没有合并到main分支。</p>
<p>实现代码：<a href="https://github.com/nihaojob/vue-fabric-editor/blob/f85fede86b37be0a22362cd68c346cab19ef507e/src/components/attribute.vue#L493">https://github.com/nihaojob/vue-fabric-editor/blob/f85fede86b37be0a22362cd68c346cab19ef507e/src/components/attribute.vue#L493</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691a58842da74ef19a4ec8993c177acb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2>结尾</h2>
<p>开源过程中遇到很多志同道合的开发者，为项目提供思路、代码、PR ，让项目从0涨到了600star，感谢大家的帮助，希望能够继续迭代，打磨成像稿定设计和创客贴一样好用的开源图形编辑器。</p>
<p>目前的版本仍在继续迭代，很多细节还不完善，基础功能还在补充，比如滤镜设置、图片替换、图片裁剪、字体样式模板等，还有一些文档、vue3升级、单元测试的工作。</p>
<p>在开发的过程中我的收获也很大，如果你也比较感兴趣，是fabric.js的爱好者或者自己也在开发类似的项目，欢迎加入交流群，期待你的Issue和PR，一起打造一款好用的设计编辑器。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73edacbc23c24ae289b87fc54687ff55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3>致谢：</h3>
<ul>
<li><a href="https://github.com/Qiu-Jun">June</a> 多次深夜为项目贡献代码，提供快捷键、右键菜单等功能。</li>
<li><a href="https://github.com/xiaozeo">xiaozeo</a> 宝妈百忙中为项目提交代码，让属性面板更美观。</li>
<li><a href="https://github.com/icleitoncosta">icleitoncosta</a> 异国他乡的开发者朋友，提供了国际化功能。</li>
<li><a href="https://github.com/asang28">asang28</a> 为项目提供了vue3版本代码。</li>
<li>晗萧℡ 会自己写编辑器的设计师，多次为项目提供代码示例。</li>
<li>RHS 为项目提供缩放思路、标尺代码。</li>
<li>放牛哥 为项目提供代码和实现思路。</li>
<li>冯志辉 一直在关注我们，为我们加油打气。</li>
<li>…</li>
</ul>
<p>篇幅有限，不再一一列举名单，感谢大家的支持与帮助，希望vue-fabric-editor在未来的日子里不负期望，和大家一起越变越好。</p>







标题：单路由\实现，拼接不同 path，性能不同
作者：Leon-OS
发布日期：发布于 2 个月前
文章内容：<p>如代码所示，仅实现了/路由，其他均未实现。
<img src="//static.cnodejs.org/FnnKgmu7Uk7kw1nua9FYbm0GyiOD" alt="image.png">
<img src="//static.cnodejs.org/FjL0aE_oQ8haLPmdO5Km35IxRc-7" alt="image.png"></p>







标题：【轻快图片管理系统】基于Koa2 + Vue3.x + Vite3.x + typescript开发的轻量级快捷图片管理系统、图床系统
作者：helinghands
发布日期：发布于 2 个月前
文章内容：<h2>简介</h2>
<p>程序员日常就是写博客，当然写博客时就会涉及到在博文中插入图片，所以往往会使用图床来进行图片资源管理，市面上较流行的图床系统是<code>PicGo</code>，是使用<code>electron-vue</code>开发的桌面应用程序，每次换电脑或者重装系统后都需要重新下载安装并配置图床，比较麻烦。所以开发了这款<strong>轻快图片管理系统</strong>，是基于vue3.x + typescript + vite + koa + mysql开发的前后端分离图床系统，使用该系统可以不需要每次都配置图床。
前端使用 Vue3.x + Vite3.x + typescript + Element-plus, 后端使用 Koa2 + typescript + mysql 进行开发，使用 Jwt + koa-ts-controllers 做登录验证和权限校验。</p>
<h2>内置功能</h2>
<p><strong>图片上传</strong>
支持图片多图上传、拖拽上传、粘贴上传、一键复制多种格式的图片外链。</p>
<p><strong>图片管理</strong>
多上传的图片进行管理，支持文件重命名、移入指定相册、删除图片、预览图片等。</p>
<p><strong>存储桶管理</strong>
支持多桶储存，可同时添加多个对象存储桶管理，上不封顶，例如：七牛云对象存储、阿里云对象存储、腾讯云对象存储等等，系统会统计出每个存储桶下的图片数量以及已使用存储量。同时也支持控制存储桶是否显示在上传区。</p>
<p><strong>相册管理</strong>
支持相册管理，可以对图片进行分组分类管理，便于用户将不同的图片进行分类挂办理，同时也支持直接将图片上传到相册中。</p>
<p><strong>操作日志管理</strong>
完整的可视化日志功能，记录用户所有操作，方便事件溯源。普通用户只能查看自己的操作记录，管理员则能查看所有人员的操作记录，于此同时数据统计中的贡献图的数据来源也是从操作记录中提取。</p>
<p><strong>个人信息维护</strong>
用户可以对自己的信息管理，如头像(系统内置4组不同维度的头像供选择)、昵称、职业、性别、个人简介以及个人登录密码进行维护管理。</p>
<p><strong>数据统计</strong>
系统提供了数据统计功能，统计用户的图片数量、存储桶数量、总占用存储量、相册数量以及系统贡献度数据进行统计。</p>
<p><strong>使用习惯配置</strong>
考虑到每个用户的使用习惯不同，系统提供了使用习惯配置中心，可以对默认复制的图片链接格式、自定义链接格式、常用快捷键配置以及是否开启上传成功提示、复制链接成功提示等配置。</p>
<p><strong>用户管理</strong>
多用户管理，根据不同的角色可以管理不同的数据，同时用户可以通过自主注册或者管理员在管理页面直接创建。</p>
<p><strong>存储桶插件管理</strong>
存储桶管理，是由管理员进行在线开发的插件，用于管理员对存储桶插件的相关配置，需要做什么前置处理或者后置处理等进行管理，例如七牛云对象存储，需要用户在界面上感知出需要填写哪些数据、哪些数据时必填项、有哪些数据的智能提示，需要前置操作则是获取上传认证，其实就是对存储桶拥有哪些元数据进行配置，于此同时还提供了是否启用或者禁用的功能，比如某一个对象存储已经从市面上out，则管理员可以进行禁用操作，这样用户就不能创建该类型的存储桶。</p>
<p><strong>字典管理</strong>
对系统中经常使用的一些较为固定的数据进行维护，例如个人中心的职业、用户性别、存储桶页面不同的存储桶类别展示不同的图标等数据维护。</p>
<p><strong>系统设置</strong>
对系统中一些常用的数据进行维护，包括系统名称、系统logo、备案信息、更新日志、系统上所使用的的图标的来源进行配置。</p>
<p><strong>权限控制</strong>
完整的权限控制功能，不同的角色可分配不同的操作权限，控制对应的删除及查看。</p>
<h2>在线体验</h2>
<p><strong>在线演示</strong>
地址：<a href="http://picture.itchenliang.club/#/">http://picture.itchenliang.club/#/</a>
账号：guest@163.com
密码：000000</p>
<h2>待办功能 TODO</h2>
<p>后期待开发的功能列表/优化部分展示</p>
<ol>
<li>数据迁移/数据备份
考虑到有的用户原先使用的是其他图床系统，需要将数据迁移到本系统中；或者需要将本系统中的图片迁移到其他图床系统中。
<ul>
<li>存储桶支持一键导出所有图片(即将该存储桶中的图片一键批量导出到zip包中)</li>
<li>存储桶支持一键导入所有图片(即将zip包中的图片一键批量导入到该存储桶中)
&lt;br&gt;考虑到有的用户需要将相册中的图片导入或者导出做备份工作</li>
<li>相册支持一键导出所有图片(即将该相册中的图片一键批量导出到zip包中)</li>
<li>相册支持一键导入所有图片(即将zip包中的图片一键批量导入到该相册中)</li>
</ul>
</li>
<li>新增存储桶插件
考虑到很多用户在使用“哔哩哔哩图床”和“csdn图床”，为了方便用户的使用，管理员需新增如下两个存储桶插件：
<ul>
<li>bilibili存储桶</li>
<li>csdn存储桶</li>
</ul>
</li>
<li>首页上传区
目前首页上传区存在的问题，如果用户上传的图片多且超清，会导致上传时间比较长，如果此时用户切换菜单到其他页面，会导致图片上传不成功问题，为了解决该问题需要配置一个“全局任务中心”，用户图片上传进度检测，由于是全局的，所以用户切换页面不会造成上传失败问题。</li>
<li>快捷键绑定实际事件
目前只完成了快捷键绑定设置功能，还需完善到实际的事件绑定，例如：快捷上传快捷键<code>Ctrl + Shift + P</code>，需要自动进入到个人中心页面。</li>
<li>提示功能
根据用户的习惯配置是否开启上传成功等相关的消息提示。</li>
<li>鉴黄能力
有的用户在本系统上上传【颜色图片】，属于不合法行为，故需接入鉴黄能力，若用户上传的图片是【有颜色图片】则上传失败。</li>
</ol>
<h2>环境</h2>
<ul>
<li>Node版本 &gt;= 14.17.6</li>
<li>Mysql版本 &gt;= 5.7</li>
<li>typescript版本 &gt;= 4.8.4</li>
</ul>
<h2>安装</h2>
<h3>安装步骤</h3>
<p><strong>1. 安装node</strong>
前往<a href="https://nodejs.org/zh-cn/">node官网</a>下载<code>node.exe</code>并安装或者使用<code>nrm</code>进行安装。</p>
<p><strong>2. 安装git</strong>
前往<a href="https://git-scm.com/">Git官网</a>下载<code>git</code>并安装，此步可忽略。</p>
<p><strong>3. 安装typescript、nodemon、ts-node</strong>
使用下面的命令全局安装<code>typescript</code></p>
<pre class="prettyprint language-shell"><code>npm install typescript -g
npm install nodemon -g
npm install ts-node -g
</code></pre><p><strong>4. 克隆代码</strong>
使用<code>git clone</code>命令将代码克隆到本地，或者直接下载压缩包到本地并解压</p>
<p><strong>5. 依赖安装</strong></p>
<pre class="prettyprint language-shell"><code># 前端依赖安装
cd client
npm install

# 服务端依赖安装
cd server
npm install
</code></pre><p><strong>6. 项目启动</strong></p>
<pre class="prettyprint language-shell"><code># 前端项目启动
cd client
npm run dev

# 服务端启动
cd server
npm run start
</code></pre><p>控制台出现如下如所示即代表启动成功
<img src="https://imgs.itchenliang.club/img/202211101711526.png" alt="202211101711526.png">
<img src="https://imgs.itchenliang.club/img/202211101712519.png" alt="202211101712519.png"></p>
<p><strong>7. 项目打包部署</strong>
koa项目可以不用打包部署，直接将<code>server</code>目录下的内容所有内容拷贝到服务器上然后执行上述的安装步骤。</p>
<pre class="prettyprint language-shell"><code># 前端项目打包部署
cd client
npm run build
</code></pre><p>将打包后生成的<code>dist</code>目录下的所有内容拷贝到web服务器上。</p>
<h2>预览</h2>
<h3>登录</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101727165.png" alt="202211101727165.png"></p>
<h3>注册</h3>
<p><img src="https://imgs.itchenliang.club/img/2022111017274810.png" alt="2022111017274810.png"></p>
<h3>忘记密码</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101728063.png" alt="202211101728063.png"></p>
<h3>上传区</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101718307.png" alt="202211101718307.png"></p>
<h3>图片管理</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101719274.png" alt="202211101719274.png"></p>
<h3>存储桶管理</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101719413.png" alt="202211101719413.png"></p>
<h3>相册管理</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101720094.png" alt="202211101720094.png"></p>
<h3>操作日志</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101720309.png" alt="202211101720309.png"></p>
<h3>个人中心</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101721163.png" alt="202211101721163.png">
<img src="https://imgs.itchenliang.club/img/202211101721385.png" alt="202211101721385.png"></p>
<h3>使用习惯配置</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101723388.png" alt="202211101723388.png"></p>
<h3>数据统计</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101724094.png" alt="202211101724094.png"></p>
<h3>用户管理</h3>
<p><img src="https://imgs.itchenliang.club/img/202302201017207.png" alt="202211101724463.png"></p>
<h3>存储桶插件管理</h3>
<p>为了方便拓展，存储桶以插件的形式开发，由管理员直接在系统上进行在线开发，并且支持插件版本管理(版本回退、版本对比)。</p>
<p><strong>存储桶插件列表</strong>
<img src="https://imgs.itchenliang.club/img/202302201018349.png" alt="202211101725136.png"></p>
<p><strong>存储桶插件开发</strong>
<img src="https://imgs.itchenliang.club/img/202302201023375.png" alt="202302201023375.png"></p>
<p><strong>存储桶插件开发预览</strong>
<img src="https://imgs.itchenliang.club/img/202302201024225.png" alt="202302201024225.png"></p>
<p><strong>存储桶插件版本管理</strong>
<img src="https://imgs.itchenliang.club/img/202302201024461.png" alt="202302201024461.png"></p>
<p><strong>存储桶插件版本对比</strong>
<img src="https://imgs.itchenliang.club/img/202302201025202.png" alt="202302201025202.png"></p>
<h3>字典管理</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101725334.png" alt="202211101725334.png"></p>
<h3>系统设置</h3>
<p><img src="https://imgs.itchenliang.club/img/2022111017260710.png" alt="2022111017260710.png"></p>
<h3>更新日志</h3>
<p><img src="https://imgs.itchenliang.club/img/202211101726356.png" alt="202211101726356.png"></p>
<h2>联系我</h2>
<p>Email: &lt;a <a href="mailto:href=%22mailto:itchenliang@163.com">href="mailto:itchenliang@163.com</a>"&gt;<a href="mailto:itchenliang@163.com">itchenliang@163.com</a>&lt;/a&gt;</p>
<h2>捐赠/打赏</h2>
<p>如果您认可我的作品，并且觉得对你有所帮助我愿意接受来自各方面的捐赠。
<img src="http://lc-dzncsgi3.cn-n1.lcfile.com/FnXBNkKfhnOYoLppJGSWQY6dUh1rnMHA/reward_alipay.jpg" alt="">
<img src="http://lc-dzncsgi3.cn-n1.lcfile.com/PAMB9Ah4luFLiVvwp6oVh6pelyPudsNK/reward_weixin.jpg" alt=""></p>







标题：自己封装了个数据模型库用于代替ORM
作者：jaxzhou
发布日期：发布于 2 个月前
文章内容：<p>传统的ORM主要将模型和具体表的进行关联，大体上上一张表对应一个Model。</p>
<p>在数据开发和实践中，关联查询，聚合查询等复杂查询往往会比较多，ORM是较难支撑住这样的场景。这时候我们往往会手写SQL来进行。而手写SQL的问题主要在于SQL无法像代码一样被复用和阅读。并且在TypeScript下，可能还是需要对返回结果的类型进行单独定义。</p>
<p>在设计和开发过程中，优先定义和考虑的自然是我们查询所需要的数据字段到底是哪些。所以不如从结果出发，基于定义的返回结果来定义结果的产生过程，就有了基于具体Query的模型结构。而且这样，也能够复用子查询结果，减少重复的SQL。</p>
<p>GitHub： <a href="https://github.com/jaxzhou/querymodel">https://github.com/jaxzhou/querymodel</a></p>







标题：ChatGpt免费用，绝不收费，帮助开发和学习
作者：cool-team-official
发布日期：发布于 2 个月前
文章内容：<p>这里可以免费使用ChatGpt，旨在帮助学习和开发，不要提一些无聊的问题</p>
<p><a href="https://cool-js.com/ad/chatgpt.html">ChatGpt免费聊天</a></p>
<p>ChatGPT 是一个由 OpenAI 训练的大型语言模型。与以往的 AI 不同，它可以做很多事情如编程、写作、作诗等，回答的富有逻辑并且能联系上下文。它的出现颠覆了人们对 AI 的认知。对于程序员来说它也能提供一些帮助来加快我们的编码效率，协助学习一些新的知识。如：</p>
<p>Q：如何使用 ioredis 实现分布式锁，请给出代码示例</p>
<p>A：JavaScript 冒泡排序算法：</p>
<blockquote>
<p>function bubbleSort(arr) {
	for (let i = 0; i &lt; arr.length; i++) {
		for (let j = 0; j &lt; arr.length - i - 1; j++) {
			if (arr[j] &gt; arr[j + 1]) {
				let temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	return arr;
}</p>
</blockquote>







标题：关于微前端，你理解到究极奥义了么？
作者：fantasticsoul
发布日期：发布于 5 个月前
文章内容：<h2>微前端的起源</h2>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21701cc8cba43b9b3e7f24195238262~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>在<strong>微前端</strong>这个概念出现之前，我们或多或少都能够联想到另一个词性上有些相似的概念<strong>微服务</strong>，它从出现后便一直都很火热，并不断催生着后端架构体系的演进，而此刻我们如果细品一下这微字头的两兄弟，探究他们的诞生原因，会有很多有意思的点。</p>
<p>我们暂且忘掉这兄弟两，到一个更高的角度会发现，很多新概念的诞生，一定能够顺藤摸瓜的追溯到一个某个原点上，这个原点我们可以把它比作宇宙诞生的奇点，压抑了足够久之后发生了大爆炸，然后逐渐向外扩散生成万物原型，so… 我们复盘一下处在这个信息高速时代，当网络带宽越来越大，覆盖范围越来越广，延迟越来越低，触达人群越来越多的时候，让web从1.0进化2.0、3.0、4.0，在这个全民入网的时代，网络条件如此优越的时代，是什么开始按捺不住那庞大的能量，开始肆无忌惮的爆炸起来了呢？</p>
<h2>爆炸的数据</h2>
<p>聪明的你一定意识到了，它就是<strong>数据</strong>，优越的网络条件如同肥沃的土壤，让全民皆参与到内容生产当中，于是乎海量的数据疯狂生长，让我们进入了<strong>大数据</strong>时代，面对如此磅礴的体量，<strong>云计算</strong>、<strong>分布式</strong>等新概念蜂拥而出，有了用武之地，或者说数据的爆炸倒逼着这些技术的产生与发展。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ac7b9a8aba43de9c3b7cb631744a7c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>再回到<strong>微服务</strong>与<strong>微前端</strong>两兄弟上，想一下是不是同样的也正因为数据的爆炸，需要精细化的运营各种场景，让我们传统的单体服务架构上不得不承载着越来越多的业务呢？</p>
<p>这种包含n个服务构成的一个后台项目，从开发侧看，只能在既有的技术栈上不停的叠加新功能，当新的技术福利诞生时想作替换将是一场噩梦，从运维测看，因整个项目打包在一起构成了一个产物，而不得不面对任何一点修改都必须全部一起发布的繁琐。</p>
<p>于是乎<strong>微服务</strong>诞生了，将这种巨石服务或按各职责、或按功能、或按业务等维度作为拆分的维度，拆解成一个个服务，可独立构建、独立部署，通过<code>rpc</code>通信做到应用的语言架构无关，让开发者不再捆绑到某一个编程语言上，当然了，作为拆的代价，服务注册、服务治理、服务发现、服务熔断、服务监控、链路追踪等新机制的引入带来了更高的复杂度，所以服务的拆分一定是一个渐进式的过程，为了拆而拆必然带来运维上的更高成本与挑战。</p>
<h2>重刷存在感的微前端</h2>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a8a2999908c408ca56123db69f03abc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>和<strong>微服务</strong>不一样的是，如果我们不死磕<strong>微前端</strong>概念，而是从<strong>拆</strong>字这个角度来看，其实<strong>微前端</strong>其实从html诞生那天开始一直都存在，我么仔细回想一下，传统的服务器端渲染，是不是一个路由对应着服务器端一个html页面的字符串返回呢，这一个返回对应着后端的一个页面模板，不管它是静态生成的还是动态生成的，它在后端的目录结构里都是一个个独立存在的文件，所以我们一直都是在用<strong>微前端</strong>搭建项目的视图部分。</p>
<p>随着前端的业务复杂度极巨爬升，传统的服务端渲染方式给前端工程化带来了巨大的挑战，因为工程化的基础是组件化，而后端的模板引擎所支持的组件化天生有着用绵软无力的感觉，无论是书写体验还是调试体验都远远弱于浏览器端渲染，而随着作为浏览器端主战场的不二人选js，生态周边越来越丰富与强大，如node的诞生为前端工程化催生了大量优秀的构建工具、编译工具，js引擎的性能也一直在攀升，js自身的规范和语言特性也不断的进化，以及和相关组件化开发的优秀库如春笋版冒出（react、vue、angular、svelte…）,良好的npm生态让库共享易如反掌等，在这种有利于前端工程化的土壤培育下，让我们面对复杂的前端项目时，如可忽略seo优化，首屏速度等因素时（尽管也有类似的解决方案），倾向于从服务器渲染迁移到浏览器端渲染了。</p>
<h2>微前端之5个核心思想</h2>
<p>前端工程化也面临着后端同样的问题，一个工程随着时间流逝会逐渐堆叠大量业务，从而让一个前端项目慢慢演变成一个巨石应用，基于此背景下在<a href="https://micro-frontends.org/">micro-frontends</a>上对微前端做了如下阐述：</p>
<blockquote>
<p>微前端背后的想法是将网站或 Web 应用程序视为由<strong>独立团队拥有</strong> 的 <strong>功能的组合</strong>。每个团队都有<strong>不同的业务领域</strong>或<strong>任务</strong>，它关心和专注于，一个团队是<strong>跨职能</strong>的，从数据库到用户界面，<strong>端到端地</strong>开发其功能，但这个想法并不新鲜，<a href="http://scs-architecture.org/">它与自包含系统的</a>概念有很多共同之处。在过去，这种方法被称为<a href="https://dev.otto.de/2014/07/29/scaling-with-microservices-and-vertical-decomposition/">垂直系统的前端集成</a>。但微前端显然是一个更友好、更简洁的术语。</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234d777aa2a24c949b092a65d6021cf0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>并进一步提炼出以下5点微前端的核心思想</p>
<ul>
<li><strong>与技术无关</strong><br>
每个团队都应该能够选择和升级他们的堆栈，而无需与其他团队协调。<a href="https://micro-frontends.org/#the-dom-is-the-api">自定义元素</a>是隐藏实现细节同时为其他人提供中性界面的好方法。</li>
<li><strong>隔离团队代码</strong><br>
不要共享运行时，即使所有团队都使用相同的框架。构建自包含的独立应用程序。不要依赖共享状态或全局变量。</li>
<li><strong>建立团队前缀</strong><br>
就尚无法隔离的命名约定达成一致。命名空间 CSS、事件、本地存储和 Cookie，以避免冲突并明确所有权。</li>
<li><strong>优先使用本机浏览器功能而不是自定义 API</strong><br>
使用<a href="https://micro-frontends.org/#parent-child-communication--dom-modification">浏览器事件进行通信</a>，而不是构建全局 PubSub 系统。如果你真的需要构建一个跨团队的 API，尽量让它尽可能简单。</li>
<li><strong>构建弹性站点</strong><br>
即使 JavaScript 失败或尚未执行，您的功能也应该很有用。使用<a href="https://micro-frontends.org/#serverside-rendering--universal-rendering">通用渲染</a>和渐进增强来提高感知性能。</li>
</ul>
<h2>微前端之模块联邦</h2>
<p>以上阶段1里强调的5点特性看起来似乎给微前端下了一个相当完美的定义，以至于后来的各种微前端框架都在这5个核心思想指导下去做实现，直到2020年 webpack 5 <code>module federation</code>（以下我们简称MF）模块联邦诞生，并对此特性在官网做了一个很简单的介绍：</p>
<blockquote>
<p>模块联合的动机，让多个单独的构建应该可组合为一个应用程序,这些单独的构建之间不应该有依赖关系，因此它们可以单独开发和部署，这通常被称为<strong>微前端</strong>，但不限于此。</p>
</blockquote>
<p>细细玩味这段话，我们发现webpack 5视角下的<strong>微前端</strong>仅需要包含3个特点：独立开发、独立部署、运行时组合。</p>
<p>如果你基于<code>webpack 5 MF</code>发布过远程模块，你会知道它并不包含micro-frontends站点里提到的<strong>隔离团队代码</strong>这个关键点，尽管我们知道涉及到代码运行隔离需要用上shadowrealm(未来的隔离方案)、proxy window、iframe 等方案，但MF并未强调这一点，所以看起来MF理解下的微前端是阉割版的微前端？</p>
<h2>再思考微前端</h2>
<p>我们将micro-frontends 和 webpack 5 两个出处的微前端定义做一个对比，并提出一个灵魂的拷问，是否以下表达成立？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a8dc369d594459fa90ddbdfa862ed1b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>事实上随着模块联邦这个概念开始逐渐深入人心，微前端架构已经分裂出两个方向：</p>
<ul>
<li>
<p><strong>容器型微前端</strong></p>
<p>我们把以single-spa为代表的这一类方案统称为<strong>微容器</strong>，在single-spa走红之后市面很多基于single-spa二次封装的库如雨后春笋般涌出，典型的代表作如阿里的qiankun，意在解决一些single-spa未解决的问题并让其更适合企业级开发，同时也诞生了很多非singlespa系的框架，如京东的micro-app、腾讯的wujie等，它们的细节实现各有差异，包含js沙箱隔离、css隔离、iframe编排、启用web-component、window代理、接入过程等各个地方的细节也各有千秋，但它们都一个很显著的特点，对应的模块粒度是整个应用，做出的产品可以理解为一种以宏观态的方式来组合多个应用交付给用户使用。</p>
</li>
</ul>
<blockquote>
<p>试想一下，你不会极端到以运行时隔离的方式去渲染多个按钮吧？</p>
</blockquote>
<ul>
<li>
<p><strong>模块型微前端</strong></p>
<p>相较于<strong>微容器</strong>宏观态的组合应用方式，<strong>微模块</strong>则可以形容为微观态的组合方式，它的粒度更小，小到可以是一个函数，一个基础的组件，对于开发者来说，引入<strong>微模块</strong>和引入一个普通的js包没有任何区别，他们在使用上也并无任何区别，但恰恰是这一点！是它和<strong>微容器</strong>最大差异之一，<strong>微模块</strong>的使用方式回归到了js语法本身。</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b40fda05aa8443e86cbae6f1d775089~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><strong>微容器</strong>和<strong>微模块</strong>在开源社区均有很多实现，它们的特点很明显</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/290a8055b5ba4a7990f7a0a3fbdb4362~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>所以基于两种方案搭建的微前端架构也是区别非常明显的</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a82939c20538433283e1d02188d00812~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>微前端技术该如何选型</h2>
<p>我们只要深刻理解到<strong>微模块</strong>是天然就假定运行在同一个宿主里（即同个一js环境里），它要解决的核心问题是大规模独立构建的应用间如何快速动态共享公共模块这个棘手问题。</p>
<blockquote>
<p>例如你有100个内部的前端项目依赖了lodash-1.0.0，突然该库暴露了一个漏洞，你需要100个前端项目全部重新构建升级到1.0.1才代表安全解决此漏洞问题，而基于模块联邦的lodash，你仅需要构建一次mf-lodash，其他项目即可引用到最新的安全代码。</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a731f2050326452fab4ba726276d6eb9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>再综合考虑到两个以下关键点，就很容易得出技术如何选型的结论了：</p>
<ul>
<li>
<p>1 是否需要多技术栈混合开发（react、vue…）</p>
</li>
<li>
<p>2 是否需要多版本技术栈同时迭代等(vue2, vue3…)</p>
</li>
</ul>
<p>因为<strong>微模块</strong>是微观态的组合方式，它可以迅速的将你逐渐庞大的应用拆为一个个可独立部署的组件并再次组合起来，相对于<strong>微容器</strong>方案，大多数时候或许你的新项目并不需要介入<strong>微容器</strong>。</p>
<p>当你需要组合一些第三方应用或自己的其他技术栈应用，并需要让它的就是被隔离起来安全的运行时，<strong>微容器</strong>是你武器库里适合拿出来的强力武器。</p>
<p>事实上它们搭配起来混合使用将是相辅相成的完美组合，你可以先使用微容器再接入微模块做跨应用模块动态共享，或先使用微模块再套上微容器做运行时隔离，取决于你的项目发展到了什么阶段。</p>
<h2>混合架构的微前端实践</h2>
<p>实际上，我们在这方面已经做了大量的工程实践，微容器推出了<a href="https://github.com/Tencent/wujie">无界</a>，微模块推出了<a href="https://github.com/tnfe/hel">hel-micro</a></p>
<p>这里给出一个混合架构的例子可供大家参考：<a href="https://github.com/fantasticsoul/wujie-and-hel">wujie和hel-mico搭建微前端</a>，大家可以将此思路复制到其他社区方案，例如（micro-app + mf）（qiankun + hel-micro）等。</p>
<p>例子里有无界容器里加载远程react组件的示例
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f25a79a83f4b4e7d836ac4d09b6c4750~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>有无界容器里加载远程lodash模块的示例
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c5bdf269b84a82872732fa9d7ce6aa~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>关于hel-micro与wujie</h2>
<p><a href="https://github.com/tnfe/hel">hel-micro</a>是业内里首个模块联邦 sdk 化，免构建、热更新、工具链无关的微模块方案，让模块联邦技术从构建工具插件层面提升到 sdk 层面，使用更灵活，模块流通性更好（工具链无关）。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f799bd46ac144d809a2e9dbcabd54679~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><a href="https://github.com/Tencent/wujie">无界</a>微前端是一款基于 Web Components + iframe 微前端框架，具备成本低、速度快、原生隔离、功能强等一系列优点。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42dbd5d995fc4232a28325b843501d9f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>它们均已在腾讯云、腾讯新闻的多个toB、toC场景经历考验，期待你的关注与了解，让我们一起在微前端领域探索出更多的可能性。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/955467e2200440ea8727c2b6074c2cd8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h2>总结</h2>
<p>本文讨论了很多关于微前端的新理解，你理解到究极奥义了么，是不是和你和你之前所接触的微前端概念有所不同呢，期望你能在 <strong>容器型微前端</strong> 和 <strong>模块型微前端</strong> 之间找到最佳的平衡点并付诸实践。</p>







标题：WASM 原生时代已经到来 | 解读 WebAssembly 的 2022
作者：chai2010
发布日期：发布于 3 个月前
文章内容：<p><a href="https://mp.weixin.qq.com/s/Mfpe8knOGtUG-wl1GDdGHQ">https://mp.weixin.qq.com/s/Mfpe8knOGtUG-wl1GDdGHQ</a></p>







标题：2022大前端总结和2023就业分析
作者：i5ting
发布日期：发布于 3 个月前
文章内容：<p>本文首发CNode社区、SegmentFault、稀土掘金和Node全栈公众号，本文版权归作者所有，未经作者同意，禁止转载。</p>
<p>我在年前给掘金平台分享了《2022年热点技术盘点》的前端热点，算是系统性的梳理了一下我自己对前端一整年的总结。年后，在知乎上看到《前端的就业行情怎么样？》，下面都是各种唱衰前端的论调，什么裁员，外包化，没前途，薪资不过20k之类的，我非常不认同他们的观点，于是我也回复了这个提问，基于前端情况、趋势和我个人的理解，给出了一些就业行情分享，大家还是比较认可的，收藏的比点赞的还多。既然都喜欢看，那我就把这些人写的稍微详细一下，希望有理有据的分析能够对更多前端的朋友们在寒冷的冬天，感受到更多温暖，更加坚定。</p>
<p>本文主要讲了前端2022的主流趋势，年度大戏低码和2023就业行情分析，对未来的2个可能放大的点AI和Cropto和前端相关的部分也有一点点覆盖。2022年是黑天鹅满天飞的一年，整个互联网局势都很差，从人才济济到“人才挤挤”，2023年前端就业形势会怎样呢？下面一起来尝试分析一下。</p>
<h2>先看一下2022年前端主流趋势</h2>
<p>2022年的前端还是非常热闹的，比如Vite和Turbo的性能之争，恶劣的Faker.js事件，尊重但不一定认同的SubStack退网事件，已知多位大佬加入区块链公司，Doodlewind在AFFiNE做编辑器，Justjavac在Deno &amp; Rust之外又参与了Astro源码贡献，Antfu开源的Vitest非常棒，如果评年度卷王2位，一定会有Antfu。如果只评一位，那么一定是Jarred-Sumner，他是Bun.sh作者，Bun是2022年的性能最好的Runtime，风光一时无二，从 2021 年 4 月初始提交至今已有超过百万行的代码增删量，单人完成了 98% 以上的提交量，2月3日刚发布了Bun v0.5.5。</p>
<p>通过我的种种观察，我的分析是前端专业成熟度基本上见顶了，基建基本稳定，2022年做的事都是深耕基建和前端垂类细化，整体看是围绕研发体验优化做的事儿为主，各垂类全面专业化。下面围绕性能、运行时、体积、Rust等四个方面进行讲解。</p>
<h3>当前前端趋于成熟</h3>
<p><img src="//static.cnodejs.org/FisMyKnbxskT6gg4vQ6zxQ78q5Ku" alt="image.png"></p>
<p>从2005年之后，相继出现Prototype，Motools，jQuery等为了抹平浏览器差异的库，极大的降低了全栈开发门开。随着电商高速发展，促成了前后端分离，并最终催生了前端工程师这一专业工种。</p>
<p>在2009年，Node.js横空出世，由于Node.js使用V8这个最高效的JavaScript引擎，所以在语法上，对前端更友好，或间接或直接的促进了前端构建领域的日渐成熟，比如对html不满足，就有了Pug、ejs等模版，比如css不满足，就有了sass，less等CSS预处理器，比如js不满足，就开始有了Coffee等新的衍生语言。除此之外，在模块规范层面也是有了很多演进，从AMD到CommonJS到UMD，完成了很多优秀的探索，比如require.js，sea.js这样的优秀实践。另外JavaScript语言本身也取得非常大的发展，从ES5一路升级，在TC39组织下每年一个版本，为了兼容各个版本特性，诞生了Babel这样的超级怪物，当然这样间接的解决了异步流程控制问题，从Callback hell到Promise到Generator到Async function，虽然很乱，到总归是回到了正路上。除了这些基础外，在UI框架层面也做了大量时间，从早年各种hack面向对象基础，到extjs类的面向对象的开发方式，甚至是从Flex、Silvelight等富客户端，但都是惊鸿一瞥，未能一直称雄。</p>
<p>随后2013年之后，开始出现Backbone，Angular类似插件，将MVVM、IoC、指令等引入到前端，继而促使React、Vue在DSL，VDom层面展开激烈角逐，并促成了React、Vue、Angular三家争霸的局面。同时，也使得分散的技术栈开始变得不满足构建需求，于是从Grunt、Gulp等传统构建器，演进为以Webpack代表的打包器(Bundler)。</p>
<p>这还只是前端爆发的开始，2015年之后，Node.js开始稳定在1.0版本，并持续发力，使得BFF（backend for frontend）遍地开花。同时围绕React、Vue、Angular三大框架的移动端开发也如火如荼，比如react-native、weex等都变得流行起来，几乎是强运营场景下必备的神器。</p>
<p>从2013到2019年间，是大前端的爆发式增长期。从前端基建，跨端，BFF（backend for frontend）等领域都取得了极大的进步，这也促使前端人才需求极大，尤其是对专业型人才需求极大，薪资也是可以用“狂飙”来形容。可以说这6年是前端发展最好的时期，Java自从被Spring包养之后变化不大，移动端更是在2015年下半年之后开始式微，在这种情况下，只有前端几乎是唯一大的增长点。很多人黑前端娱乐圈，屁大点事儿都能被放大到很大，这种聚光灯效应足以说明大家对前端的关注点。</p>
<p>甚至那几年有前端同学调侃说：“学不动了”，就是因为三大框架生态和大前端的快速发展导致的。但，2020年之后，基本上就没有人这样说了，前端的新轮子也不再那么高频率出现了，就连几个核心框架，更新的内容也都开始挤牙膏了，甚至是互相借鉴。这就意味着前端成熟度已经趋于平稳，剩下的事儿就是如何趋于成熟。我们看一下这2年前端所发生的变化也确认如此，你能看到的变化，已经不是轮子上的广度上追求变化，而是更多的聚焦核心场景围绕深度上进行探索，这就在稳定性和开发者体验上做更多努力，这是极好的变化。</p>
<p>这里以Svelte为例，它甚至还有点返祖，它官方介绍的特性就是：写更少的代码（开发者体验），无VDom（性能），真正反应式（开发者体验）。基本上也都是围绕开发者体验和性能2个方面进行创新的。</p>
<p><img src="//static.cnodejs.org/FovjjT7Z8CfVYBqg87mtHUInDYDA" alt="image.png">
下面就当下新潮的技术（Solid.js、Svelte、Remix、Astro、Vite、Bun、Tauri、Turbo等）进行总结，围绕性能、运行时、体积、Rust四方面分别讲解，具体如下。</p>
<h3>1、性能</h3>
<p>先看一下为什么会有性能问题，问题和解法如下。
1、启动时间慢，大家都受够了Webpack阵营：于是就有了swc、esbuild这些编译器，以及Turbo、Vite这样的基于新编译器的构建方式。
2、配置太多：约定大于配置或0配置的开箱即用
3、包太大，动不动1个G的NPM包大小：Yarn，pnpm。有朋友开玩笑，1个G不大，可是电脑才256个G的硬盘。
4、模块拆分：Lerna | Yarn/ pnpm workspace。</p>
<p>其实都是在解决大规模编程问题，如果再直接点说，那就是解决的是开发者自己的体验问题。整体看前端生态真的做的已经很好，吊打其他社区包管理机制。某一次我在知乎上看到一个回答，往死里骂npm，然后我就简单的拿NPM和Cargo对比了一下，结果那位回答的人来质问我不能这样比。这就是典型中国人，自己孩子随便骂，别人说一声都不行。如此看来，我这激将法还是管用的。</p>
<p>下面是Umi作者云谦大佬整理的性能比较数据，以及Vercel官方对比的Vite和Turbo数据对比。至于具体数据大家不必详细看，数据在变，不同基准下也是有影响的。之所以放这2张图，就是想让大家了解一下，当前几个主流框架里都在做性能竞赛，这里面最有代表性的就是Webpack5，Vite和Turbo。</p>
<p><img src="//static.cnodejs.org/FhXtk6jkRwrauIjIx_x1xjci1N0Q" alt="image.png"></p>
<p>围绕构建工具，我曾经画过一张图，基本讲清楚了前端的构建演进历史。参考下图。</p>
<p><img src="//static.cnodejs.org/FgqJxCVu1-tzqFdJU2prThOl7s1v" alt="image.png"></p>
<p>最开始的时候，很多前端，包含Node.js工程师都是使用make作为构建工具的，如果大家感兴趣，可以去看看tj早年项目结构（其实，《深入浅出Node.js》里也是用到make的，朴大大也很喜欢make）。之后就是Grunt，基于模版和插件机制的构建工具，比如jQuery等都是基于Grunt构建的。但Grunt有2个问题，就是性能不太好，另外配置复杂。于是Gulp横空出世，很快就替代了Grunt，它是基于Node.js stream机制做，只要机器有资源就可以完全利用上，在效率上比基于文件模版的方式高出一大截。即使在今天看，Gulp也是极为优秀的构建方案。
但前端发展非常快，各种CSS预处理器，模版，语言，还有Babel等各种兼容，于是就有了Webpack这样的Bundler，通过插件和loader机制，把前端这点乱七八糟的快速发展产物整理的顺畅很多，在很长很长一段时间，Webpack都随着三大框架一起成长，结果臃肿，笨重，一个稍大一点的项目几秒到几十秒都是常事。那个时候，没的选，学东西都来不及，温饱还没解决，谁还有心思想什么马斯洛需求层次理论啊。</p>
<p>到2019年之后，开始出现Snowpack，主要是针对ESM进行Bundless打包方案，随后Vite也借鉴了Snowpack的思路，提升开发者体验，并以Rollup和esbuild生态辅助，以高明的设计，最小的投入，获得社区快速的认同，有点像当年Gulp替代Grunt一样。按照正常剧本的话，Vite会和Gulp一样大火。偏偏半路杀出一个程咬金，Vercel开源了Turbo，以Rust做基建，拿Rust优势为底，重写底层工具链，从根上开始杠，做了一个硬核的事儿。</p>
<p>其实，充分竞争是好的。如果性能提升10倍，甚至100以上，这对开发者是多么大的体验提升啊。不管最终胜者是Vite，还是Turbo，或者其他，都无所谓，我们能看到的是未来前端开发会非常幸福。</p>
<h3>2、运行时</h3>
<p>2013到2019年，TC39组织发展的非常快。曾经阿里，360都以能加入TC39为荣，能够从语言这样的底层规范上参与，能够很大程度提升中国前端的影响力。比如2021年阿里巴巴提案Error Cause 进入Stage3，也是当年很火的新闻。但实际上经过这么多年的发展，能提的都提了，能借鉴的也都借鉴了，就好比现在Node.js源码想去提个PR是不容易的一样。</p>
<p><a href="http://xn--2022Bun-8t3kgm230lb1ruhcs52co3rrnbqz41a.sh">2022年最火的一个项目是Bun.sh</a>，官方介绍Bun是一个快的JavaScript运行时，且all in one，就是说它内置包管理。基于Zig和uWebSockets，性能是极好的。</p>
<p>其实，Node.js从2009诞生之后，除了当年iojs分家又合并的事外，就是ry另立门户做的Deno，其实它也是一个JavaScript运行时，无非是对浏览器和最新标准支持的更好，加上对TypeScript直接支持，开箱即用是非常好的设计。</p>
<p>我们可以把Node.js、Deno、Bun放在一起走一个简单的对比，具体如下。</p>
<p><img src="//static.cnodejs.org/Ft6eYpSNqKn95U9ju3A1SSXfrvRi" alt="image.png"></p>
<p>它们都是非常优秀的JavaScript运行时，无论是star数，更新频度，贡献者都是非常健康的。图中有一个错误，说Node.js是创建于2014年，这其实是iojs合并回来的时间，实际上Node.js是2009年。</p>
<p>去年之所以Bun爆火就是因为它的性能极好，下面我们看一下Bun的性能，分别是Bun v0.1和v0.4的性能对比。</p>
<p><img src="//static.cnodejs.org/FhroIffu5_gItklv4oC6fzgNRfkQ" alt="image.png"></p>
<p>通过上图，可以明显的看出，Bun的性能基本上是Node.js和Deno的3倍左右。但只看数据其实是不合适的，按太郎的说法: “等 Bun 把所有的 <strong>SegmentationFault</strong>, <strong>Illegal instruction</strong> 和 **version ‘GLIBC_2.29’ not found **修完了以后性能会回到 Node.js/Deno 水平”，我是非常认同这个说法的。</p>
<p>当然，Node.js也有它的问题，尾大不掉，很多东西想改也是没法的。事实上，Node.js更新的也是非常多的，比如Deno引以为豪的network import，在Node.js v17.6里就实现了，除了直接ts没有支持外，其他差别就不大了。</p>
<p><img src="//static.cnodejs.org/FvATx2XROUDW1yPiUHYH1k_wJ6nO" alt="image.png"></p>
<p>针对Runtime来块，Bun的思路是对的，all in one，不过我更希望有一个集合3个Runtime的优势的Runtime，比如支持network import，自带包管理，原生支持Typescript。想想，对Node.js开发者来说，那也是很美好的事儿。其实就是歪歪一下而已，Node.js已经很难做改造了，不然也不会在Serverless容器里因为冷启动时长过长，而导致很多公司自己定制Runtime，比如阿里去年开源的noslate便是因为这个原因鼓捣出来的。</p>
<p>这里再稍微啰嗦一点，除了Runtime层面，其实在应用层面性能也是有提升，比较典型的例子是Deepkit，Deepkit的做法是将 TypeScript 转换到字节码，提供反射 开箱即有类型转换、序列化/反序列化器，验证器和自动类型守卫，所有的 TypeScript 类型都受支持。在<a href="/user/deepkit">@deepkit</a>/core里使用很多hack技巧，比如用new function来创建新的动态类。但由于类型上做了大量优化，包括bson解析，RPC协议优化等方面有非常大的优势，所以在DB和RPC性能方面是非常不错的。除此之外，它在调试方面也是非常方便的。参见下图。</p>
<p><img src="//static.cnodejs.org/FsjIQyF6VVKkqfZAE-6Je-BfFxQL" alt="image.png"></p>
<p>就目前deepkit情况而言，它是非常优秀的项目，deepkit目标非常远大，它自己也实现Web server，但性能和Fastify比还是有一定差距的，可以关注一下。</p>
<p>除了deepkit之外，其实还有一些社区想法也是可以关注的，对提升性能都是比较好的解法。</p>
<ul>
<li><a href="https://arrow.apache.org/">https://arrow.apache.org/</a>基于内存的列式数据结构，目前Node.js社区这方面实践还少。</li>
<li><a href="https://github.com/sysgears/webpack-virtual-modules">https://github.com/sysgears/webpack-virtual-modules</a> 能内存解决的事儿都内存做吧。在vm2里可以使用require file from memfs ，这也是一个不错的方式，参见<a href="https://github.com/patriksimek/vm2/issues/472">https://github.com/patriksimek/vm2/issues/472</a></li>
<li>Partytown 拆到worker里，分而治之也是极好的。</li>
<li>Cyberscript，基于zig的脚本：基于寄存器做编译，也是扣性能扣到一定程度了。</li>
</ul>
<h3>3、体积</h3>
<p>通常产品开发都是先实现功能，然后再优化，然后再做周边。其实这种思路在大前端生态里也是这样的。举个例子，SSR就是非常典型的例子。以淘宝的活动页为例，早年一直是没有SSR支持的，后来拉新需求以及技术突破，自然而然就会做SSR了。就好像我当年使用SSR，总会被问到SSR的价值，明明就是锦上添花的技术，为什么一定要用，原理是一样的。当你想提升性能的时候，除了万金油缓存外，减小体积就是最简单的方式，SSR就是最典型的实现，当下SSR、SSG等已经成了前端标配，像astro也是在体积上做了大文章的优秀项目。</p>
<p>除了前端体积外，跨度领域其实也是在优化的。这里举一个2022年轮子哥Egoist的一个项目dropcode，颇具有代表性。dropcode技术栈和ui如下图。</p>
<p><img src="//static.cnodejs.org/FpQMVxgqQVZndUtVJXeyaEPzec2A" alt="image.png"></p>
<p>dropcode就是一个简单的管理代码片段的软件，它的技术栈是很潮的，采用Tauri做打包，采用Vite做构建，采用Solid.js做ui框架，这三个大杀器都是非常优秀的。</p>
<ul>
<li>Tauri是Rust编写的跨端构建方案，优点是基于Web技术可以打出比Electron更小的包。体积小10倍以上。</li>
<li>Vite是基于ESM的方案，在体积和性能上也是极为优秀的，丝般顺滑。</li>
<li>Solidjs是一个react类dsl增强的优化框架，7kb的包，也是把体积做到极致了。createSignal不评价，优点缺点都有的。</li>
</ul>
<p>关于Tauri这里是有必要讲一下，它是Rust的代表应用之一，在跨端构建领域也算一时风光，大有取而代之的意思。下面是Tauri的架构图和功能对比。</p>
<p><img src="//static.cnodejs.org/FqCRBN_B4U5x8Q3fHnCUWf_tGfgx" alt="image.png"></p>
<p>上图右侧对比功能基本差不多，Linux系统的安装包大小是非常值得关注的，将近20倍，这也是最吸引开发者的特性。从Tauri架构上来看，设计的是很合理。</p>
<p>1、TAO是创建跨平台应用窗口的库，支持所有主要平台，除了PC，还有iOS和Android，野心还是很大的。
2、WRY是基于Tao构建的跨平台Webview渲染库。
3、核心是Tauri Runtime和周边。</p>
<p>接下来我们对比一下Tauri和Electron。从Tauri v1.2发布声明上看，它是使用Rust编写的，构建优化过的，安全的，前端独立的应用多平台打包软件。</p>
<p>这里重点介绍一下构建优化，主要是它的tao和wry使用各个操作系统的内置Webview，而不是像Electron内置Chromium。所以在安装包大小上，具有绝对优势。但辩证的看，使用系统内置的Webview，Webview兼容性是个大问题，会不会出现ie6类的兼容问题不好说。而Electron是所有平台展示都一样，这就是拿体积换体验一致。参考下图，了解一下就好。</p>
<p><img src="//static.cnodejs.org/Fj60W2PB83zPK8rkxupsMRA3iT8j" alt="image.png"></p>
<p>下面看一下Tauri相关应用场景，2022年最火的软件大概Chatgpt，围绕Chatgpt衍生出很多周边，通过Tauri打包chatgpt，lencx的做法就非常不错，目前已经超过6.9k star数了。另外一个应用就是侑夕写的pake，这是一个简单的基于Tauri的封装，但用法却极为简单，可以让网页快速变成pc应用。试用了一下，非常的舒服，短短几个月就10.2k star数了。</p>
<p><img src="//static.cnodejs.org/Fqfu4QJaNvvy4LJEWiDtqFwhT2ox" alt="image.png"></p>
<p>大家对体积和性能的关注是一样的，除了Tauri外，Node.js社区里也有Gluon这样的方案，都是采用系统Webview，不过目前Gluon还是处于比较初级阶段，可以关注一下。下面是Gluon官方给出的对比图。就性能和体积来说，Gluon和前面讲的Bun类似，希望它们都能够发展的越来越好。</p>
<p><img src="//static.cnodejs.org/FoCC0V1EyIuHwQGKTHDScFJixv96" alt="image.png"></p>
<p>从SSR，到Solidjs，到Vite，到Tauri，到Gluon，都是在体积上做了很大优化的优秀技术，我相信未来还会不断在体积和性能优化方案深究，这对用户和开发者来说都是好的。</p>
<h3>4、Rust正在变成前端新基建</h3>
<p>说 Rust 是 WebAssembly 未来，目前看还不是，多语言里大家几率不会差太多。Web Server 已经卷死了，无机会。云原生是 Go 的地盘，难下手，机器学习 Python 才是王者，大数据和后端 Java 天下，可玩的有限。综上，JavaScript 依然是应用软件最好的选择。但 Rust 做基建，提供更好的开发体验，倒是大有可为的。</p>
<p>当然 Rust 是写前端基建，是当下趋势，我整理了一下相关工具链的仓库[<a href="https://github.com/i5ting/learn-rust-for-fe">https://github.com/i5ting/learn-rust-for-fe</a>]
(<a href="https://github.com/i5ting/learn-rust-for-fe">https://github.com/i5ting/learn-rust-for-fe</a>)，目前已经超过900多star了。</p>
<p><img src="//static.cnodejs.org/FsOU5-14EcKR7c6Yj_uqzg1MYtht" alt="image.png"></p>
<p>Rust 语言在前端工具链的影响越来越大，目前可以看到 Next.js 对 Rust 重仓，招揽大量人才，swc 作者，Rollup 作者等等，未来可能是一个很好的解决前端体验的方向。</p>
<p>《Rust Is The Future of JavaScript Infrastructure》一文作者是 Vercel 的开发者关系主管，这篇文章和我的观点一样，自备梯子。 很多东西都是上错花轿嫁对郎，比如 MVC，比如 Node，如今又多了 Rust。必然雄起！未来随着 WebAssembly 普及，Rust 才能变成应用级别的。</p>
<p>其实，很多经典的Rust库在blessed.rs网站上都是有的，上面内容非常全。我对Rust模块的看法是都偏底层，比如CLI用的最多的就是clap，类似的模块远没有Node.js世界里百分之一，这意味着Rust社区比较喜欢深耕，不喜欢搞各种创新。另外，从功能上clap这种就属于刚好够用的，这和cargo类似，基本相当于低配版的pnpm。之前和粉丝们开玩笑，狼书三卷出完了，如果再出卷4，我的唯一选择就是《狼书卷四：Rust从入门到弃坑》，这是玩笑话，也是真实想法，我非常认同Rust对大前端和Node.js的未来影响。</p>
<p><img src="//static.cnodejs.org/FkVVIEqmmV5pCjUwR2Qf7SiW0xuq" alt="image.png"></p>
<p>我的小兄弟十忆在2022年写了一个v8-profiler-rs模块，v8-profiler-rs 是一个使用 Rust 开发的用于在线智能化的分析 V8 heapsnapshot 堆快照的项目。帮助使用到 V8 引擎的应用开发者，例如Node.js/Chrome/Deno/Electron 等程序，旨在帮助开发者更直观的理解程序内存结构以及辅助定位内存泄漏问题。这里面技术点还是非常复杂的，需要熟悉v8，还要用rust重写，里面算法部分还是非常多的，比如支配数算法。</p>
<p><img src="//static.cnodejs.org/FqVWYEFAzKNP2XbZVSbYsuGY2EGq" alt="image.png"></p>
<p>其实，它实现了多少功能不重要的，重点要的是它能够代表趋势潮流。从Swc到Turbo到v8-profiler-rs，基本上前端工具链已经被Rust实现差不多了，比如ESLint就曾在Issue里说要用Rust重写，类似的事儿比比皆是，综上种种，我个人对Rust打造前端基建是非常有信心的。</p>
<h3>总结</h3>
<p>2022年，从性能，运行时，体积等多个方面讲了前端趋势，同时Rust正在变为前端新基建，整体上看前端趋于成熟，更多的都是做的是深耕，优化的事儿，这些对用户和开发者都是极好的。
如果说只能推荐一个，那就只能是Next.js。虽然Next.js和张宇昂写的ssr框架是竞品，我个人不是很喜欢Next.js后面的改进，但它确确实实是好东西。</p>
<p>1、它是一个开箱即用的框架，从SSR开始做，然后转型开箱即用的应用框架，支持CSR，支持SSG，支持各种优化，连图片、字体、SEO等很多小细节都扣的极其细致。这对新手极其友好，所以大家的好感是极好的。
2、除了框架自身做的好用，简单，强大外，搭配Vercel云服务，一条命令完成开发和部署，这一点也是对开发者极好的体验。
3、Vercel对 Rust 重仓，招揽大量人才，swc 作者，Rollup、Webpack 作者等等，对Turbo这种基建硬核的事儿有勇气有能力，我是非常佩服的。</p>
<p>有Vercel打样，引领前端趋势潮流，未来很多框架都会趋之若鹜，关注开发者体验的，这才是真正的大好事。</p>
<p><img src="//static.cnodejs.org/FrLw6fkRBxPwVQXGROlfQrBSymcm" alt="image.png"></p>
<h2>年度大戏（低码）：又一次全栈，至暗时刻还是新机会？</h2>
<p>每年都会做一次年度总结和趋势预测，以往我对前端趋势都是比较乐观的，但在今年，此时此景，我竟然有一种莫名的惆怅，因为今年可能是至今为止变化最大的一年。对应标题中的全栈，可能大家都熟悉，但今天我要讲的是“又一次全栈”，低码全栈，是我以为的未来发展趋势。在当前前端成熟度和技术突破的结果上，催生低码全栈，继而导致工程师角色的变化，可能是前端的至暗时刻，也可能是新的机会。本文主要探讨这个问题，相信能够给大家一些不一样的输入。</p>
<h3>全栈历史</h3>
<p>讲到全栈，大家的都是既熟悉又陌生，且褒贬不一。按英文解释，全栈是fullstack翻译过来的，在JavaWeb时代其实是不讲全栈，只是Java工程师里，有Java Web工程师这个分类而已。在这个角色里，开发者需要会Java SE基础，掌握JavaEE，会写jsp、servlet、javabean，会model1和model2，会ssh框架，做的最多的事儿就是针对db的crud。至于ibatis等都是额外的零食。那个年代能折腾的其实很少，比如nutz算不错的开源项目，fastjson也不错，剩下的就是各种apache的包，结果最终大一统到spring全家桶了。这时候的Java Web工程师其实就是全栈工程师了。</p>
<p>在2005年，Ruby on rails作者dhh通过15分钟编写一个blog，震惊世界。一下子ruby和rails成了效率工具，确实ruby很优秀，简洁，结合强大的元编程能力可以实现很多超能力（黑魔法），在rails里通过脚手架，以及视图抽象等，才使得15分钟写1个blog成为现实。ror的影响一直持续到现在，很多语言里的框架都是借鉴rails的，比如目录结构，脚手架实现。在《狼书》卷三里，自己动手写企业级Web框架，其实也是借鉴了rails写法的。</p>
<p><strong>无论Java Web工程师，还是RoR工程师，他们都是一个人搞定开发，从db到视图，从开发到发布运维，这就是早起的全栈</strong>。所以很多那个时代过来的人都会认为全栈就是全干的说法，事实上看确实没错，不过是自我调侃而已。这时候的前端非常原始，基本上js能写一些表单处理校验，动画处理基本就够了，最麻烦的大概就是浏览器兼容了，于是各种prototype，motools，jquery等应运而生。说白了，这些都还是工具属性，所以，这时候的前端，基本上是全栈工程师的加分技能而已，还不是一个角色。</p>
<p>随着互联网的崛起，在2005到2009年之间，前后端开始分离，标志性事件应该是淘宝最先引发的，前端开始更多的关注UI表达、浏览器兼容性，组件复用，性能优化等。于是在工具库之上，开始出现各种ui库，比如jquery-ui，我理解是原始ui框架的开始。然后是extjs，通过class方式定义ui，在企业级开发里被大量使用，很多ui框架都开始迷信面向对象（oop）能够解决ui复用问题。在一个连oo机制都不完善的语言里，自己实现oo写法是那个时代特有的特征。无论如何，专业化分工，带来的工程师职业发展的更多可能性。这个阶段，很多前端都会自嘲为切图仔，甚至还有专门的css重构工程师。</p>
<p>对前端影响里程碑事件的是2009年，Node.js诞生，它对前端工程化落地提供了基础。虽然本意是解决c10k问题，却误打误撞，变成了前端基础设施。通过js能够写构建，解法了前端很多禁锢。从写一点简单构建脚本，到grunt、gulp，基本上你能想到的构建都涵盖了，甚至连服务器运维都有一整套js工具链。如果仅仅是构建方面增强，其实是说小了，node其实是打开了工程师的想象力，当js具备io读写功能，自然就是编译的良好实验场。再加上各种js自身痛点（比如模块规范缺失），ruby等其他语言影响，于是出现了ejs这样的模版引擎，coffee这样的类ruby语法的转译器，从ruby解决的scss等，于是潘多拉魔盒被打开了。像新文化运动一样，前端开始不满足“切图仔”的角色，而是想打造更好的前端。随后backbone，angular、react、vue等依次登场，后面就是大家熟悉的话本了。这里要讲的是，从简单构建到bundler是一个跨越。事实上，2013年之后，曾经能搞定jQuery的那波Java大佬已经搞不定React了，原因是概念太多，前端不成熟，没有cra这样的东西，于是彻底切断了前后端的分工。
按墨菲定律，凡是可能出错的事有很大几率会出错，引申到Node.js身上也是一样的，它是什么，它就该做什么。当前端掌握了这个大杀器，不搞点事情怎么可能呢？于是早起的MEAN新一代架构便应运而生，说白了，就是mongdb、express、angular、node四个当时先进技术的，这其实也是上一代全栈的延伸。</p>
<p>除了MEAN外，还另外一个概念就是BFF，backend for frontend。就是所谓的api胶水层解决方案。最初bff是为了解决ios，android等移动端和pad、pc的api聚合问题而被thoughtworks提出来的，反正是胶水层，难度不大，用node写更合适。另外一个契机是互联网架构的演进，从前后端分离，慢慢固化到ui，api，rpc和db四个部分。在这种架构下，api层聚合，需要的是前端能搞定，性能好，快发简单，这种场景下舍Node其谁。所以从我个人角度来看，bff才是第二个的全栈阶段。从专业化分工到胶水粘结，确实是非常高效的。在《狼书》卷一和卷三大量讲的内容都是这件事，搞来搞去也无非缓存，RPC、MQ。在卷二里讲的Web开发，其实也是BFF必须掌握的技能。</p>
<p>至此，我们讲了2个全栈高潮期，具体如下。
1、从Java Web到RoR，引发的“全干” fullstack。这个阶段，全干是精髓。
2、由Node.js引发的API胶水层革命，即bff层fullstack，这个阶段是再互联网四大件体系下，前端和API胶水层全干。也有个说法，这叫前端3.0，本质没变，都是想拓宽前端的职能范围。</p>
<p>时至今日，前端框架混战，爆发式增长的阶段已经过去了。2020年之后，已经很少有人说学不动了，除了技术创新成本增加外，新东西增量也放缓，还有就是现有体系不断增加，比如cra，umi，next等越来越完善，基本上都是开箱即用的。各种ui库多的是，各种可视化，拖拽，编排也非常多，且垂类越来越好，比如3d、vr/ar/webassemly等生态。</p>
<p>那么，下一个正在发展中的阶段是什么呢？我以为是全栈的第三个阶段：低码全栈。如下图，表达了三个阶段的演进关系。</p>
<p><img src="//static.cnodejs.org/FnQ_Tz4jDUXHtQ4oCfg7UevPkVcr" alt="image.png"></p>
<h3>低码全栈</h3>
<p>在2019年之后，前端技术趋于稳定，生态丰富，发展出很多对低码友好的技术生态。下面我们具体分析一下，低码全栈的历史必然性。</p>
<p><img src="//static.cnodejs.org/Fk8wML8NWSngKfGEURuKSaKbM7Mz" alt="image.png"></p>
<p>结合上图，从基建形成低码技术，继而出现面向低码的全栈。这里先讲解基建的必然性。</p>
<p>1）前端成熟，这个大家都可以理解。
2）可视化技术成熟，在前端生态里可视化已经相当够用了。各种画布，所见即所得，编辑器技术也得到大大的发展。都想干掉office，颠覆企业协作，这也是可以理解的。
3）SQL成熟，这里更多的是指DB层面的成熟，无论量，运维，还是oltp和olap融合，都是非常成熟的，至少目前的互联网应用是验证过的。各种SQl相关定制和实现也很容易，会SQL的人更是不计其数，好一点的PD都能自己搞定。
这里要讲一点不一样的内容，比如Byzer，将算法和SQL结合是一个很有趣的方向，社区里py类似项目也是有的。我们可以这样理解，在表单这种垂类应用上，借助算法模型，能够提供更多分析和实操能力。这个我理解才是趋势。
4）AI算法成熟，虽然AI普及很难，但在特定场景，真的是很好用。</p>
<p>以上四点是基础，但不是载体。我们目前能看到的，承载所有上面技术的是低码技术。</p>
<h3>对前端带来的技术变化</h3>
<p>下面我们看一下低码全栈给前端带来的一些变化，简单讲是服务下沉，给了一些技术变革的机会，以当下投资圈最火爆的retool为例。</p>
<p><img src="//static.cnodejs.org/Fji9OcG57-DFyxEO9FbKfAPT6Roy" alt="image.png"></p>
<p>大家看去retool官网首页看一下这个视频，太震撼了。第一次看到五分钟可以搞定2个表格，按钮，过滤，联动。这种复杂度，对于绝大部分B端应用都够了。<strong>其最大的创新是让ui元素和SQL字段联动，让ui元素和请求联动</strong>。这样ui、sql、http请求就有机的结合在一起了。在上面4点基础之上，极大的放大了生产力，在当下经济环境下，大概这才是资本追逐的原因。</p>
<p><img src="//static.cnodejs.org/FtGX51XXSmVWDVYAIyiblHjpQGqQ" alt="image.png"></p>
<p>关于低码的更多介绍，推荐大家看一下侑夕同学的这篇文章，总结的还是非常棒的。</p>
<p>除了上面讲的历史必然性，我们还要低码和当下技术进行对比拆解，这样理解起来更容易。我们前面讲过第二个阶段全栈核心解决的是BFF，主要是胶水层。那么低码应该解决啥呢？</p>
<p>以retool的方式为例，它只保留ui和db，而rpc和api都变成了db上的增值服务，这样就减少了环节，也让问题定义更简单。</p>
<p><img src="//static.cnodejs.org/Fvd3YZdWNLxsxXJujt6kne24GqZX" alt="image.png"></p>
<p>快手的车明君老师总结的低码本质，说的非常好。
1）通过技术提升生产力，继而减少需求
2）通过优化生产关系，减少中间环节，协作更高效</p>
<p>以前我的理解的生产关系优化是从PD到服务端，今天看来，这个观点可以更加开放一些，在技术上也是一样的。当我们再看到sql和ui元素组合的时候，你会震惊，这才是简化的力量。
从技术上提高生产力，从组织层面优化，从技术层面简化，三管齐下，解决绝大部分开发场景是够用的。约定式创新是没有问题，确实降本提效。至于是不是杀鸡取卵，大家可以各自发挥。从我个人视角来看，这是趋势，一个人能够做更多事情，借助生产力工具，减少协作流程，这一定是高效的。回到标题，“又一次全栈”，我想把第三个全栈定义为低码全栈就是这个原因。</p>
<p>低码全栈是技术发展和融合背景下提供的业务快速交付方式的创新。不管大家是否愿意，这样的改变都正在发生。试想当年运维工程师，在2000左右都是车接车送的，2010年基本就消失了，继而转换成devops和平台工程师，事情其实还是在的，比如MoeLove（张晋涛）做的k8s相关研究也在这个范围里。</p>
<p>对于前端工程师来讲，也面临同样的问题，转型成全栈或平台前端、垂类前端。我在文章最前面说，这可能是前端的至暗时刻，也可能是新的机会。就是这个原因，优胜劣汰会使得很多人要接受变化。</p>
<p>但换积极的角度看，有了retool这样的平台，也同样会催生出使用这样平台的人，我们假定这个角色叫retool工程师，需要掌握sql和低码操作，完成页面快速交付，这其实也是一个新的全栈角色。对于工程师来说，这也是一个新的选择。</p>
<p>在低码背景下，前端也会有一些技术选型上的变化，具体如下。</p>
<p>首先低码是基于页面维度的，所以页面托管服务是必备的。也就是说狼三里page as service依然实用，甚至要把csr和ssr都同意到一起。</p>
<p>其次是微前端成为基础设施，这个和微前端诞生初心一样，新老系统难免整合。</p>
<p>之后是MPA大行其道，以前spa是为了缓存公共资源文件，提升加载速度，体验更好。但在低码里都是独立页面，这种情况，很明显是多页应用更好，每个页面都是独立的，独立服务，按需开启ssr或csr，是必然结果。</p>
<p><img src="//static.cnodejs.org/FrXTr6VTvcVFIxiZoQ-f8IooGUNB" alt="image.png"></p>
<p>当然，优秀的开源项目，比如aims，alc，x6等都会有比较不错的增量，享受趋势红利。还有整合性的，比如apitable等也是我非常看好的。</p>
<h3>举例</h3>
<p>技术变化其实是小的，真正的难的是选择。如下图，我整理了2个方案。</p>
<p><img src="//static.cnodejs.org/FvgrGlEYu19AeE44X3RIhXlJ61ny" alt="image.png"></p>
<p>1）拥抱变化，积极转型全栈。大部分的只能这样选择
2）主动出击，做好bff，去分一块服务端的业务。</p>
<p>技术本身变化并不大，但融合会导致工作内容变化，继而是角色变化。其实还有平台前端，或者说专业前端可以选择，当然，这个范围会慢慢变小。垂类前端也可以，比如做互动游戏，3d，xr，音视频等小众。当然也可以尝试web3。</p>
<p>下面说一个我的例子，2022年把ts-junit写完了第一版，写这个目的就是让熟悉Java的同学能够以他们熟悉的方式写测试。当然，这不一定是真命题。只有全栈统一，这样的需求才会变多。</p>
<p>我的做法是选用junit写法， 用ts去实现。</p>
<p><img src="//static.cnodejs.org/Ft0AkH1tKXZhlrjgRkpHhMSsFuYe" alt="image.png"></p>
<p>技术选型上，选择了uvu做执行引擎，里面用了策略模式和模版模式做了一点扩展点，可圈可点。</p>
<p><img src="//static.cnodejs.org/Fg_aLK6xzhtdomOlDs-m4LwXjX3V" alt="image.png"></p>
<p>下面是ts里的具体技术栈，还算是比较常规的内容，具体如下。</p>
<p><img src="//static.cnodejs.org/FvaTrTJ1muqkbqqgM_FjiCkUUj-k" alt="image.png"></p>
<h3>总结</h3>
<p>文章中，我们讲了3个全栈高潮期，具体如下。</p>
<p>1、从Java Web到RoR，引发的“全干” fullstack。这个阶段，全干是精髓。
2、由Node.js引发的API胶水层革命，即bff层fullstack，这个阶段是再互联网四大件体系下，前端和API胶水层全干。也有个说法，这叫前端3.0，本质没变，都是想拓宽前端的职能范围。
3、低码全栈是技术发展和融合背景下提供的业务快速交付方式的创新。从技术上提高生产力，从组织层面优化，从技术层面简化，三管齐下，解决绝大部分开发场景是够用的。</p>
<p>由低码技术发展而衍生出的全栈，可能会导致工程师们角色的又一次变化。文章中举例了运维工程师的变化。当然，也写了一些前端的变化和应对方案。最后举了ts-junit的例子。这是残酷的现实，所以我说这可能是前端的至暗时刻，也可能是新的机会。</p>
<p>其实，身在变化中的人都会难受，重要的是心态。无论大家愿意与否，改变都在发生。坚持学习，每日精进才是解法。</p>
<h2>2023年就业情况分析</h2>
<p>整体上，我对前端的状态是趋于成熟，已经过了第一波爆发式增长期，但它还在垂类细化领域不断发展中，所以我还是非常看好的，前端按照波士顿矩阵说法，大约处于明星和金牛中间，整体上发展还是非常好的。交代完背景，再看就业情况分析。</p>
<h3>前端局势算很差吗？</h3>
<p>先说结论，整个互联网局势都很差，从人才济济到“人才挤挤”，我理解的原因就是经济环境和行业发展遇到瓶颈，更深层次的分析我就没能力分析了。有了这个命题，加上前端是互联网中的一个工种，这就意味着前端在互联网局势很差的情况下也会很差。</p>
<p>其实，最可怕是马斯克收购Twitter搞一波裁员，如果打破投资圈对技术崇拜的魔咒，那才是最可怕的。以前互联网朝气蓬勃，产品都是做加法的，举例电商做品类拆分细化，越做越大，还有pdd，那时候能拿钱砸出来，现在就未必了。另外，很多产品都功能做的过于丰满，把自己定位甚至都改了，真是把mvp理解的太到位了，从Minimum Viable Product到Maximum Viable Product都理解到了。 以往裁员都是销售类等挥之即来的岗位，如果因为产品功能饱和而裁员技术，这才是最可怕的。</p>
<p>事实上，前端是去年在互联网如此糟糕的局势里比较好的工种。参考<a href="https://octoverse.github.com/2022/top-programming-languages">https://octoverse.github.com/2022/top-programming-languages</a>，这应该和各位读者理解的差不多，JavaScript依然是一骑绝尘，冠绝一时，连Typescript都能排在第四，可见前端技术使用度占比之高。</p>
<blockquote>
<p>JavaScript continues to reign supreme and Python held steady in the second place position over the past year in large part due to its versatility in everything from development to education to machine learning and data science. TypeScript also held firm in fourth place year-over-year. Notably, PHP dropped from sixth to seventh place in 2022.</p>
</blockquote>
<p>具体数据如下。
<img src="//static.cnodejs.org/FvevszYAqoWWKGfxMaDxzZaLToQh" alt="image.png"></p>
<p>根据DevJobsScanner网站统计，时间是从Oct-2021 到 Nov-2022之间，从1200万个工作机会中进行筛选的记过。数据如下。</p>
<p><img src="//static.cnodejs.org/FlP0fI-CWc6Q84iJtv1JxzC0rLJ0" alt="image.png"></p>
<p>从图中，我们可以得知，JavaScript / TypeScript相关工作高居榜首，这意味着前端相关技能适用面非常广泛。虽然这是国外的数据，放在国内不一定完全适用，但它至少可以佐证，前端是在国外是需求旺盛的工种。参考<a href="https://www.devjobsscanner.com/blog/top-8-most-demanded-languages-in-2022/">https://www.devjobsscanner.com/blog/top-8-most-demanded-languages-in-2022/</a>，把上图进行简单梳理，可只前端需求量依然最大。</p>
<p><img src="//static.cnodejs.org/FjG8dx-isj_0x1XfotiY1VX8E6fv" alt="image.png"></p>
<p>辩证的看，前端技能和前端职位数成正比，这是正常的。这一点国内和国外的是没有区别的，多端和跨端，Node.js等混合成为大前端，守好体验和效率的门卫，当然是必不可少。</p>
<p>下面回复3个相关提问：</p>
<blockquote>
<p>提问1：请教下大佬，现在前端局势算很差吗，作为一个前端校招新人而言应该朝哪个方向发展大佬有什么推荐吗</p>
</blockquote>
<p>整个经济形势都不好，不只是前端。不过是比不得前几年而已。整体看，还算健康的，精深专业人才还是需要的。</p>
<blockquote>
<p>提问2：前端最悲观的前景在于需求越来越外包化，很可能将来的趋势是除了行业顶端的企业需要少量的金字塔顶前端，其他前端都只能吃外包的饭。</p>
</blockquote>
<p>一个不盈利的创业公司他不需要关注体验，而是完成功能。当求发展时才有体验需求，这时候才要专业的人。所以你这个观点有点以偏概全了，且悲观。我的观点，几乎任何行业都类似的，努力进大厂，然后独立，玩出乐趣，才是好事。</p>
<blockquote>
<p>提问3：2022年的前端岗位在逐渐外包化（几个大厂带的头），工资 10k~20k 的外包岗位很好就业，但是 20k 以上的就难找不少了。</p>
</blockquote>
<p>至于20k以上少的论断，我不认同。经验能力和薪资必然正比。只是选择上会更谨慎。如果再直接点，就是你看到的就是你看到的，不一定是别人看到的。</p>
<p>就业形式相交而言还是不错的，受大的经济环境和前端趋势影响，很明显，前端外包化严重，专业前端细分化，但变化（危机）也要来了，在低码和AI共同作用下，新的融合性岗位已经慢慢在出现了。下面具体讲讲我的理解。</p>
<h3>1、外包化严重</h3>
<p>没有增长的公司大致是会维持或降本。对于技术来说，除了服务器等软硬件采购，就是人力成本。出于降本的考虑，一些能够由成本不高的人能够完成的活，就不会让高成本的人来做。所以说，外包化是整个互联网行业都在做的事儿，不单单只是前端。</p>
<p>对于前端来说，门槛不高，技术成熟度高的工作是最容易外包化的。比如ToB端相关工作外包化就严重。原因很简单用户是内部人员，页面不追求极致体验，甚至是能用就行。另外，技术上没有新框架，React这种框架使用上还是很好用的，所以ToB端CRUD能外包的就外包。</p>
<p>熟练外包确实是好的，但外包和正式比例短期内还是正式更多。大家也不必过度担心，java至今也没有外包比正式多，只是会让大家去追求专业度更高的事儿，这其实也是好事。</p>
<p>外包是一种常态化选择，不只是在裁员潮下面，外包和技术提效一直都有，只是在局势不好的时候，它会被放大，甚至引起很多人的恐慌。业务萎缩，挤掉些水分是正常的，但这不是行业坍塌，需求量依然还在的，对我们而言，更多的调整好心态，强大自己，技术过硬，与时俱进就好。</p>
<p>就未来讲，真正惨的事儿不只是外包化，而是正式员工干外包的活，外包被辞退，这也是非常有可能的。比如类似国企性质的公司，不方便辞退的公司，大概率只能这样选择。成本优化，很多时候是先挤掉水分，然后清理外包，正式员工加量不加价（降薪不好操作），正式流失，扛不住的时候再补外包。</p>
<h3>2、高级岗位变少</h3>
<p>前端领域里所谓的架构师类(或者说专家类）比例还是非常多的。前端为什么会高级岗位很多，其实是2013到2019年的前端爆发期有关的。以前Java同学还能写jQuery，但到了React时代，搞定Webpack，sass，TypeScript等等，他们就显得力不从心了，专业前端都很痛苦，何况他们。所以那个时候非常细化招高级岗位，除了解决问题外，还有很多基建的建设。</p>
<p>随着基建的完善，比如create-react-app(cra)、Umi、Next.js这样的基建成熟，如果只是单纯做业务，我们还需要那么多高级岗位吗？明细是不会的。从成本角度看，高级岗位的成本，大家也是心里清楚的。所以我的判断是高级岗位会变少，很有可能会慢慢变成架构师角色，比例和Java等差不多。</p>
<p>高级岗位溢出的人，创业、转管理、转型也都是好的，学学Winter、Hax、Phodal、安晓辉、神光、程军，王晔亮（头哥侃码）其实也挺好。像TL这种比例不大动，变化不大。优胜略汰，正常比例，只是流动量少，竞争会非常激烈。</p>
<h3>3、专业前端细分化</h3>
<p>专业前端，依然是大多数，比如c端这种重体验的必须专业前端，还有垂类，比如互动游戏，3d，webrtc这种有专业难度的小众分类也必须专业前端，比如可视化编辑器，AFFiNE，QUill，X6这种都是需要专业前端的。</p>
<p>技术的边界，其实已经在打破了。比如以前说浏览器里无法操作DB，传统数据库都是要通过TCP进行连接，请问前端如何连接？基本上无解，Web缓存不算。目前见到的奇技淫巧是sql.js-httpvfs，通过WASM+Webworker搞，脑回路甚至不一样。其次，前端范围放大，Server Page也算前端，那就有了ASP，JSP，PHP等等，这些都是可以连接数据库的。尤其是http://asp.net玩的很棒的。再看，前后端分离下，为什么呢？写到一起没分层，代码不好，不适合大规模开发。部署到一起，没法借助CDN优势，也没法保障高可用。最重要的是专业化分工。</p>
<p>最近也看到AlaSQL.js，也是可以跑在浏览器是的RDBMS，未来浏览器就是现在的OS，对此我深信不疑。AFFiNE其实在做本地存储，目前看可能是基于SQLite做的。再加上去中心化的玩法，浏览器既是OS，又是Client，这样的日子还会远吗？</p>
<p>在我看来，发展中的企业依然是按照专业分工工作，成熟的公司更愿意搞全栈，降薪不好操作，就只能加量不加价。目前看，前端垂类，其实是最吃香的部分。</p>
<h3>4、岗位融合新机会</h3>
<p>岗位融合，对于Retool带来革命性的交互方式，会颠覆很多角色的，包括前端、服务端、数据分析等。未来可能会出现低码工程师，或者类似全栈工程师这样的胶水类岗位，也是非常有可能的。大家把心态放宽，没工作是很难的，最怕的自己放弃自己，坚持每日精进，又怎么会被时代抛弃呢。</p>
<p>在本文中《年度大戏（低码）：又一次全栈，至暗时刻还是新机会？》一节里，已经有了全面的叙述，这里就不再赘述了。</p>
<p>体力活和技术含量低的活儿慢慢被技术升级所替代，这在任何时代都是必然的事儿。</p>
<h2>小结</h2>
<p>回顾一下前面讲的内容：</p>
<ul>
<li>讲了2022年趋势
<ul>
<li>1、性能</li>
<li>2、运行时</li>
<li>3、体积</li>
<li>4、Rust正在变成前端新基建</li>
</ul>
</li>
<li>讲了年度大戏（低码），retool类低码系统会颠覆很多角色的，未来可能会出现低码工程师，或者类似全栈工程师这样的胶水类岗位。</li>
<li>讲了2022就业情况，局势很差，不只是前端，而是互联网很差，前端也很差，很有变化，但大盘需求不会有特别大的变化。</li>
</ul>
<p>在2023年，端正态度，做好技术才是正经事。小胡子哥说：“想做一件事情，看到的全是方法，不想做一件事情，那看到的就全是借口。意愿、态度或者说兴趣，才是个人发展的第一生产力”。摆正心态，积极面对。如果不热爱，请热爱，不然做不好的。我很认同他的说法，不管是工作还是学习，其实都是：知之者不如好之者，好之者不如乐之者。我经常说，编程本身是无趣的，玩出乐趣，才能做好编程。</p>
<p>按常理，文章后都是要展望一下未来。对于未来来说，我们还是要重视趋势的影响，对低码，AI，去中心化等技术还是保持关注和学习，最好能每日精进，与时俱进。对于AI和去中心化等技术，我是持悲观态度的，和Vic talk的推文想法类似：“AI提高生产力，Crypto提升资本利用效率，一起创造新的庞氏”，这话说的虽然很那露骨，但确实是趋势。如果拿不准，每日精进，学习能力在，还会怕技术变革吗？</p>
<p><img src="//static.cnodejs.org/FvswuKs9avJJKz9PouIiUOjdqyHW" alt="image.png"></p>
<p>狼叔说：“少抱怨，多思考，未来更美好”，社会需要专业人才，喜欢就坚定的做，热爱才是救赎最好的药。</p>







标题：锡沪程序员高速公路动土了
作者：xiaohudmn
发布日期：发布于 3 个月前
文章内容：<p>因工作关系经常去往上海，也接触过无锡—&gt;上海谋生，上海——&gt;无锡安家的很多程序员兄弟，这不仅让我感慨，流浪的人呐。</p>
<p>上海和无锡是不同的城市，工资水平、业务形态、人才类型都有所不同，但相同的是人啊。</p>
<p>我相信，人的流动，信息的流动会给所有人带来新的机遇。更多的交流，能扩展人的世界观。</p>
<p>我羡慕你在上海的薪资，你羡慕我在无锡的舒适。</p>
<p>何不建立一个这样的群组，双城联动，给匆匆忙忙的兄弟们，一个交流的地方</p>
<p>欢迎大家乘坐本次列车，IT 锡沪线。</p>
<p>请各位兄弟出示您的微信号（base64 ），我抬您上车咯。。。</p>







标题：原生js代码实现spring框架，包括spring-mvc
作者：892280082
发布日期：发布于 8 个月前
文章内容：<p>github : <a href="https://github.com/892280082/j-spring">j-spring</a>
github : <a href="https://github.com/892280082/j-spring-mvc">j-spring-mvc</a></p>
<p><strong>向Spring开源社区致敬！</strong></p>
<p>原生javascript实现Spring框架，无缝还原，上手丝滑，秒级启动。适合轻应用和产品原型开发。</p>
<pre class="prettyprint language-js"><code>//@SpringBoot
Class Application {

  /**
    演示如何引入阿里大鱼的短信服务
      1. npm install alibaba-sms-demo --save
      2. 在app-dev.yaml中配置组件的基础信息
          alibaba-sms-demo:
            key: 'xxx'
            secret: 'xxx'
      3. 在项目中引入alibaba-sms-demo包中具体组件
  */
  //@Autowired(alibaba.sms.demo.smsUtil)
  smsUtil;

  //默认入口程序
  async main(args){

    await this.smsUtil.sendMsg(&lt;tel&gt;,'msg')

  }

}
</code></pre><h2>特点</h2>
<ul>
<li>支持注解</li>
<li>无第三方依赖</li>
<li>无需babel编译</li>
<li>支持注入Npm组件</li>
<li>秒级启动</li>
</ul>







标题：chatgpt-api的node client
作者：i5ting
发布日期：发布于 3 个月前
文章内容：<p><a href="https://github.com/transitive-bullshit/chatgpt-api">https://github.com/transitive-bullshit/chatgpt-api</a></p>
<pre class="prettyprint"><code>import { ChatGPTAPI } from 'chatgpt'

const api = new ChatGPTAPI({
  apiKey: process.env.OPENAI_API_KEY
})

const res = await api.sendMessage('Hello World!')
console.log(res.text)
</code></pre><p>备忘</p>







标题：视频剪辑软件学习
作者：i5ting
发布日期：发布于 3 个月前
文章内容：<p>最近和阿里云大咖说合作录制了狼书三卷的视频，预计下周会发布。</p>
<p>了解到他们视频制作是通过PR、FCPX、达芬奇剪辑，组合用的，稍后可以学习一下。</p>
<p><img src="//static.cnodejs.org/FhOToSj5BIw9yHBJ0vGVrpKHfp6q" alt="B3DCA67F-4F41-41E9-B0CB-53DDF5F7C12C.jpg"></p>
<p>进度，logo、水印，颜色，都还不错的。</p>
<p>备忘</p>







标题：helux，一个鼓励服务注入的响应式react状态库
作者：fantasticsoul
发布日期：发布于 6 天前
文章内容：<h2>关于helux</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是一个鼓励服务注入，并支持响应式变更react的全新数据流方案，它的前身是<a href="https://github.com/concentjs/concent">concent</a>（一个类vue开发体验的高性能状态管理框架），但concent自身因为需要兼容class和function保持一致的语法，且为了对其<code>setup</code>功能，导致内部代码量实在太大，压缩后有<code>70</code>多kb，api暴露得也非常多，导致学习难度急剧上升，为了更符合现在非常流行的<code>DDD</code>围绕业务概念构建领域模型的编码趋势，<code>helux</code>一开始就设计为<code>鼓励服务注入</code>、<code>支持响应式变更</code>、<code>支持依赖收集</code>的轻量级react数据流方案。</p>
<p>它拥有以下优势：</p>
<ul>
<li>轻量，压缩后2kb</li>
<li>简单，仅暴露7个api，高频使用的仅<code>createShared</code>、<code>useObject</code>、<code>useSharedObject</code>、<code>useService</code>4个接口</li>
<li>高性能，自带依赖收集</li>
<li>响应式，支持创建响应式对象，在视图之外变更对象将同步更新视图</li>
<li>服务注入，配合<code>useService</code>接口轻松控制复杂业务逻辑，总是返回稳定的引用，可完全避免<code>useCallback</code>依赖烦扰了</li>
<li>状态提升0改动，所以地方仅需将<code>useObject</code>换为<code>useSharedObject</code>即可提升状态共享到其他组件</li>
<li>避免forwordRef 地狱，内置的<code>exposeService</code>模式将轻松解决父掉子时的<code>ref</code>转发晦涩理解问题和传染性（隔代组件需要层层转发）</li>
<li>ts友好，100% ts 编写，为你提供全方位类型提示</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88176d2bc14643e8b81d29fd72902a9d~tplv-k3u1fbpfcp-watermark.image?" alt="2.gif"></p>
<blockquote>
<p>该gif图和以下所有api均对应有在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>,欢迎fork并修改体验。</p>
</blockquote>
<p>为什么起名<code>helux</code>，虽然内心上我是把它作为<code>concent</code> v3版本去开发的，但因为它的变化实在太大，除了依赖收集不继承任何<code>concent</code>的特性，同时它也是伴随我开发的<a href="https://github.com/tnfe/hel">hel-micro</a>诞生一款作品，我期望它成为 hel-micro 生态的 luxury 级别的贡献，就将 hel-micro 和 luxury 两个词拼一起成为了 <code>helux</code>。</p>
<p>欢迎点星关注<a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>，它虽然较新，但已在我自己的使用场景中发挥功不可没的作用，现已加入hel-micro生态大仓，期待能成为你愿意挑选的一款可心数据流方案。</p>
<h2>快速上手</h2>
<p>极致的简单是helux最大的优势，了解以下6个api后，你可以轻松应付任何复杂场景，最大的魅力在于<code>useSharedObject</code>和<code>useService</code>两个接口，且看如下api介绍，或访问在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>fork并修改来体验。</p>
<h3>useObject</h3>
<p>使用 useObject 有两个好处</p>
<ul>
<li>1 方便定义多个状态值时，少写很多 useState</li>
<li>2 内部做了 unmount 判断，让异步函数也可以安全的调用 setState，避免 react 出现警告 :
“Called SetState() on an Unmounted Component” Errors</li>
</ul>
<pre class="prettyprint language-ts"><code>// 基于对象初始化一个视图状态
const [state, setState] = useObject({a:1});
// 基于函数初始化一个视图状态
const [state, setState] = useObject(()=&gt;({a:1}));
</code></pre><h3>useForceUpdate</h3>
<p>强制更新当前组件视图，某些特殊的场景可以使用它来做视图重刷新</p>
<pre class="prettyprint language-ts"><code>const forUpdate = useForceUpdate();
</code></pre><h3>createSharedObject</h3>
<p>创建一个共享对象，可透传给 <code>useSharedObject</code>，具体使用见 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const sharedObj = createSharedObject({a:1, b:2});
// 基于函数初始化一个共享对象
const sharedObj = createSharedObject(()=&gt;({a:1, b:2}));
</code></pre><h3>createReactiveSharedObject</h3>
<p>创建一个响应式的共享对象，可透传给 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const [reactiveObj, setState] = createReactiveSharedObject({a:1, b:2});

sharedObj.a = 111; // 任意地方修改 a 属性，触发视图渲染
setSharedObj({a: 111}); // 使用此方法修改 a 属性，同样也能触发视图渲染，深层次的数据修改可使用此方法
</code></pre><h3>createShared</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function createShared&lt;T extends Dict = Dict&gt;(
  rawState: T | (() =&gt; T),
  enableReactive?: boolean,
): {
  state: SharedObject&lt;T&gt;;
  call: &lt;A extends any[] = any[]&gt;(
    srvFn: (ctx: { args: A; state: T; setState: (partialState: Partial&lt;T&gt;) =&gt; void }) =&gt; Promise&lt;Partial&lt;T&gt;&gt; | Partial&lt;T&gt; | void,
    ...args: A
  ) =&gt; void;
  setState: (partialState: Partial&lt;T&gt;) =&gt; void;
};
</code></pre><p>创建一个响应式的共享对象，可透传给 useSharedObject，它是<code>createReactiveSharedObject</code>和<code>createSharedObject</code>的结合体，当需要调用脱离函数上下文的服务函数时（即不需要感知组件props时），可使用该接口，第二位参数为是否创建响应式状态，为 true 时效果同 <code>createReactiveSharedObject</code> 返回的 sharedObj</p>
<pre class="prettyprint"><code> const ret = createShared({ a: 100, b: 2 });
 const ret2 = createShared({ a: 100, b: 2 }, true); // 创建响应式状态
 // ret.state 可透传给 useSharedObject
 // ret.setState 可以直接修改状态
 // ret.call 可以调用服务函数，并透传上下文
</code></pre><p>以下将举例两种具体的定义服务函数的方式，之后用户便可在其他其他地方任意调用这些服务函数修改共享状态了，如需感知组件上下文，则需要用到下面介绍的<code>useService</code>接口去定义服务函数。</p>
<pre class="prettyprint"><code>// 调用服务函数第一种方式，直接调用定义的函数，配合 ret.setState 修改状态
function changeAv2(a: number, b: number) {
   ret.setState({ a, b });
}
*
// 第二种方式，使用 ret.call(srvFn, ...args) 调用定义在call函数参数第一位的服务函数
function changeA(a: number, b: number) {
   ret.call(async function (ctx) { // ctx 即是透传的调用上下文，
     // args：使用 call 调用函数时透传的参数列表，state：状态，setState：更新状态句柄
     // 此处可全部感知到具体的类型
     // const { args, state, setState } = ctx;
     return { a, b };
   }, a, b);
 }
</code></pre><h3>useSharedObject</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function useSharedObject&lt;T extends Dict = Dict&gt;(sharedObject: T, enableReactive?: boolean): [
  SharedObject&lt;T&gt;,
  (partialState: Partial&lt;T&gt;) =&gt; void,
]
</code></pre><p>接收一个共享对象，多个视图里将共享此对象，内部有依赖收集机制，不依赖到的数据变更将不会影响当前组件更新</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
</code></pre><p><code>useSharedObject</code>默认返回非响应式状态，如需要使用响应式状态，透传第二位参数为true即可</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
// now obj is reactive
 setInterval(()=&gt;{
  state.a = Date.now(); // 触发视图更新
 }, 2000);
</code></pre><h3>useService</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>/**
 * 使用用服务模式开发 react 组件：
 * @param compCtx
 * @param serviceImpl
 */
function useService&lt;P extends Dict = Dict, S extends Dict = Dict, T extends Dict = Dict&gt;(
  compCtx: {
    props: P;
    state: S;
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
  },
  serviceImpl: T,
): T &amp; {
  ctx: {
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
    getState: () =&gt; S;
    getProps: () =&gt; P;
  };
}
</code></pre><p>它可搭配<code>useObject</code>和<code>useSharedObject</code>一起使用，会创建服务对象并返回，该服务对象是一个稳定的引用，且它包含的所有方法也是稳定的引用，可安全方法交给其它组件且不会破会组件的pros比较规则，避免烦恼的<code>useMemo</code>和<code>useCallback</code>遗漏相关依赖</p>
<p>搭配<code>useObject</code>时</p>
<pre class="prettyprint language-ts"><code>function DemoUseService(props: any) {
  const [state, setState] = useObject({ a: 100, b: 2 );
  // srv本身和它包含的方法是一个稳定的引用，
  // 可安全的将 srv.change 方法交给其它组件且不会破会组件的pros比较规则
  const srv = useService({ props, state, setState }, {
    change(a: number) {
      srv.ctx.setState({ a });
    },
  });
  
  return &lt;div&gt;
    DemoUseService:
    &lt;button onClick={() =&gt; srv.change(Date.now())}&gt;change a&lt;/button&gt;
  &lt;/div&gt;;
}
</code></pre><p>搭配<code>useSharedObject</code>时，只需替换<code>useObject</code>即可，其他代码不用做任何改变</p>
<pre class="prettyprint language-diff"><code>+ const sharedObj = createSharedObject({a:100, b:2})

function DemoUseService(props: any) {
-  const [state, setState] = useObject({ a: 100, b: 2 );
+  const [state, setState] = useSharedObject(sharedObj);
</code></pre><h4>getState 和 getProps</h4>
<p>因 <code>state</code> 和 <code>props</code> 是不稳定的，所以服务内部函数取的时候需从<code>srv.ctx.getState</code>或<code>srv.ctx.getProps</code></p>
<pre class="prettyprint language-ts"><code>// 抽象服务函数
export function useChildService(compCtx: {
  props: IProps;
  state: S;
  setState: (partialState: Partial&lt;S&gt;) =&gt; void;
}) {
  const srv = useService&lt;IProps, S&gt;(compCtx, {
    change(label: string) {
      // !!! do not use compCtx.state or compCtx.state due to closure trap
      // console.log("expired state:", compCtx.state.label);

      // get latest state
      const state = srv.ctx.getState();
      console.log("the latest label in state:", state.label);
      // get latest props
      const props = srv.ctx.getProps();
      console.log("the latest props when calling change", props);

      // your logic
      compCtx.setState({ label });
    }
  });
  return srv;
}

export function ChildComp(props: IProps) {
  const [state, setState] = useObject(initFn);
  const srv = useChildService({ props, state, setState });
}

 return (
    &lt;div&gt;
      i am child &lt;br /&gt;
      &lt;button onClick={() =&gt; srv.change(`self:${Date.now()}`)}&gt;
        change by myself
      &lt;/button&gt;
      &lt;h1&gt;{state.label}&lt;/h1&gt;;
    &lt;/div&gt;
  );
</code></pre><h4>exposeService</h4>
<p>当孩子组件props上透传了<code>exposeService</code>函数时，<code>useService</code> 将自动透传服务对象给父亲组件，是一种比较方便的逃离<code>forwardRef</code>完成父调子的模式</p>
<pre class="prettyprint language-ts"><code>import { ChildSrv, Child } from "./Child";

function App() {
  // 保存孩子的服务
  const childSrv = React.useRef&lt;{ srv?: ChildSrv }&gt;({});
  const seeState = () =&gt; {
    console.log("seeState", childSrv.current.srv?.ctx.getState());
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; childSrv.current.srv?.change(`${Date.now()}`)}&gt;
        call child logic
      &lt;/button&gt;
      &lt;Child
        unstableProp={`${Date.now()}`}
        exposeService={(srv) =&gt; (childSrv.current.srv = srv)}
      /&gt;
    &lt;/div&gt;
  );
}
</code></pre><h2>结语</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是把<a href="https://github.com/concentjs/concent">concent</a>内部精华全部萃取提炼再加工后的全新作品，期望能得到你的喜欢与鼓励。❤️</p>







标题：fabric.js开发图片编辑器可以实现哪些功能？多图
作者：nihaojob
发布日期：发布于 6 天前
文章内容：<p>最近使用fabric.js开发了一个图形编辑器并开源了，已收到900+star，<strong>很多开发者咨询fabric.js能实现哪些功能</strong>，今天就用文字加动图的形式直观的分享出来，帮助大家做参考。</p>
<p>fabric.js 提供强大的底层能力，可实现<strong>自定义模板、素材、字体，图片滤镜、辅助线、组合、裁剪等功能，也提供了自定义元素等高级的用法</strong>。</p>
<p>项目：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>
<p>预览：<a href="https://nihaojob.github.io/vue-fabric-editor/#/">https://nihaojob.github.io/vue-fabric-editor/#/</a></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89169a52052245839413826e3a9b9ac0~tplv-k3u1fbpfcp-watermark.image?" alt="screenshot-20230415-142257.png"></p>
<h2>画布功能</h2>
<p><strong>画布属性：尺寸、预设大小、背景色。</strong>
支持修改画布尺寸，也有预常用预设的画布尺寸，可以便捷设置，有背景色修改属性，同时提供常用颜色的快捷修改。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044e2d09049f489f9341263862674fb9~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415120741_rec_.gif"></p>
<p><strong>画布缩放：放大、缩小、自动适应、鼠标滚轮缩放。</strong>
支持画布放大缩小操作，可按照1:1尺寸展示或自适应展示，页面窗口改变时会根据窗口大小自适应展示；滑动鼠标滚轮时可快捷缩放画布。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6950ef15074c494e9d277a5b46c2c9f2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415121804_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570f0c1bb2434593949b65234972f1b4~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122049_rec_.gif"></p>
<p><strong>其他细节：拖拽画布、画布区域外显示控制条。</strong>
画布支持拖拽操作，按住alt快捷键，可以拖动画布；当元素拖拽到画布外区域时，仍然展示控制条，但元素并不会被展示出来，所见即所得。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b050ef702a4449dbce41b27a525a7e2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122246_rec_.gif"></p>
<h2>辅助功能</h2>
<p><strong>控制条：</strong> 在满足元素缩放、旋转的基础上尽量让其简洁，提供了2种样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bba9a276e24db99653513bafb23f75~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123406_rec_.gif"></p>
<p><strong>标尺：</strong> 标尺与辅助线可以满足我们更高要求的设计场景。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3489af30b75e4ecdbd037f7dddfbd10a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123622_rec_.gif"></p>
<p><strong>快捷调整：</strong> 图层管理、右键菜单、快捷键。
图层可以直观的定位元素的层级顺序，右键菜单提供了常用的快捷功能，还支持复制、删除等快捷键操作，提高操作效率。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b2176cb3e4ce0bc973d27cd58d705~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415125124_rec_.gif"></p>
<h2>基础元素</h2>
<p><strong>字体元素：</strong> 字体元素有普通字体、框字体，框字体可调整外边框，自动换行。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2dd53747534bbba5273787cced287a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130158_rec_.gif"></p>
<p><strong>基础形状：</strong> 有矩形、圆形、三角形、多边形，可直接点击或拖拽添加到画布。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa5a10f62049cdbd7a6f0d10760e29~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130303_rec_.gif"></p>
<p><strong>线条元素：</strong> 支持箭头、线条元素绘制。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1209cdaee70b4f38b7eef8987d6d676d~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131152_rec_.gif"></p>
<p><strong>插入元素：</strong> 支持插入多种图片类型，图片图片、SVG元素、SVG字符串。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba18715bb24d46719d8883a90d127152~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130901_rec_.gif"></p>
<p><strong>自定义素材：</strong> 素材在左侧分类展示，可定义图片素材、字体样式素材。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97231aaa1f145f1965c1a7ee935e442~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131012_rec_.gif"></p>
<h2>文件功能</h2>
<p><strong>数据保存：</strong> 支持导出/导出JSON文件方便存储数据，可自定义设计模板。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff449fe3b9b4f08b5e51f5072b164ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131754_rec_.gif"></p>
<p><strong>图片保存：</strong> 可清空画布、预览图片、保存图片文件。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9b6eef8f2d46a284acccaa15710f39~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131852_rec_.gif"></p>
<h2>属性设置</h2>
<p><strong>基础操作：</strong> 所有元素都可以在属性面板调整透明度、坐标、旋转角度。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b96af734d4a03bfeb003de4d04865~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133918_rec_.gif"></p>
<p><strong>锁定与组合：</strong> 锁定元素后元素将不会收到其他操作影响；可将多个元素组合为一个组元素，也可以将组元素拆分为多个元素。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d836659d849d0ba115a5ec2e3b959~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132328_rec_.gif"></p>
<p><strong>元素对齐：</strong> 单个元素支持相对于画布的水平、垂直、水平垂直居中，多个元素支持上、下、左、右对齐，水平居中、垂直居中、垂直平均分布、水平平均分布功能。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71eae7cab77489d8ffb51edb3c66f11~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132516_rec_.gif">
**自定义字体：**可自定义字体、对齐方式、行高、背景色、下划线、删除线等信息。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eae4c5d03474d28b25fa64e82ef87e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>渐变配置：</strong> 渐变是设计的重要形式之一，支持为元素、字体设置渐变颜色。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf12add8983481cb2a11bcd0a33614e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>边框设置：</strong> 支持为元素增加边框样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349ce94cbc0f4aae99ec59d72ea73346~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415134137_rec_.gif"></p>
<p><strong>图片操作：</strong> 快捷替换、简单滤镜、复杂滤镜。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4998294d7f11404fad58321bfb4f22ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133617_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21f01ec7ccd40458693d0e0b8cb43a7~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133505_rec_.gif"></p>
<h2>总结</h2>
<p>fabric.js 的底层能力非常强大，这依赖于灵活的底层接口，但是太过灵活也有一个弊端，那就是我们必须掌握更多的细节才能用起来得心应手，这对于开发者来说并不会太轻松。</p>
<p><a href="https://github.com/nihaojob/vue-fabric-editor">vue-fabric-editor</a>项目致力于打造一个开箱即用的web图片编辑器应用，同时<strong>沉淀一个介于web图片编辑器应用与fabric.js之间的封装层</strong>，期望封装层面向开发者设计，<strong>提供更简单的接口，让开发者可以轻松的实现图片应用开发</strong>。</p>
<h2>邀请</h2>
<p>通过技术社区和开源的方式和大家相识是一种很奇妙的体验，大部分都是在使用fabric.js做项目的开发者，我们组建了fabric.js开发者交流群，一起抱团取暖互相支招，一边吐槽文档，一起实现功能，欢迎你的加入交流群。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e358ff17a16e4f6e946291c7beeac0d4~tplv-k3u1fbpfcp-watermark.image?" alt="WechatIMG391.jpeg"></p>
<p>我们离目标还有很长的距离，如果你对这件事情感兴趣，真诚的邀请你加入，我们一起沉淀fabric.js的最佳实践，<strong>你会得到包括不限于以下列表的收获，你只要会简单的Git和Javascript语法就可以</strong>。</p>
<ul>
<li>熟悉开源协作方式，成为项目贡献者。</li>
<li>Vue3 + TS实践，边学边开发。</li>
<li>fabric.js开发，边学边开发。</li>
<li>入门单元测试，边学边开发。</li>
<li>众多的fabric.js开发者交流。</li>
</ul>
<p>我自己是第一次搞开源项目，感谢项目的贡献者的帮助和社区的推动，<strong>这是一个很新的项目和社区，期待你的加入，希望我们一起边走边学，在未来一起成为知名开源项目的开发者</strong>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d96501901c48c8ba76d6a64ca4a185~tplv-k3u1fbpfcp-watermark.image?" alt="海报.png"></p>







标题：聊聊 WebCodecs 实现 GIF 视频转码
作者：kinglisky
发布日期：发布于 8 天前
文章内容：<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d9d33079b840e3aa3d7d0b603139eb~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt=""></p>
<p>被裁了，最近在摸鱼写文档，这两天研究了下浏览器环境下摆脱 ffmpeg.wasm 实现 GIF 转视频的功能，现在浏览器提供的 API 越来越靠近底层，浏览器在发展个几年可能真没 Electron 啥事了 [狗头] 。</p>
<p>不重复发文了，发掘金了：<a href="https://juejin.cn/post/7221557738537549879">聊聊 WebCodecs 实现 GIF 视频转码</a></p>
<p>欢迎大佬们指教~</p>







标题：自己开发了编程课程搜索的小程序，基本慕课网的课程都能搜到
作者：mikfake
发布日期：发布于 9 天前
文章内容：<p>小程序使用uniapp开发，后端使用java。因为实后端java开发，前端不擅长，有一些地方写的不是很合理。不过主要目的还是分享免费的编程课程。正在找编程资源的可以看看，可能你要的就能搜到，每天都会更新一些资源。
<img src="//static.cnodejs.org/FmBeKhXk1La4M-1xzwnIiLRZq_Ip" alt="素材1.png">
<img src="//static.cnodejs.org/FgF93KX8qwHSlleM5X6Gmug5RFo2" alt="素材2.png">
<img src="//static.cnodejs.org/Fo3cR9S0MO2OPOBe9X1Mhb7M7GXg" alt="素材3.png">
<img src="//static.cnodejs.org/FnMtv4MbZU0NRrn1Q8Ql1gRYJDCc" alt="素材4.png">
<img src="//static.cnodejs.org/Fl4_GBEs_KDU3A8PzuqpHtym9FFg" alt="二维码.jpg"></p>







标题：NodeJS+Sequelize在生产环境下，最合适的建立连接池的方式是？
作者：monkeytwins
发布日期：发布于 15 天前
文章内容：<p>看官网文档里提到关于多进程的情况下，必须为每一个进程都创建sequelize实例：</p>
<blockquote>
<p>If you’re connecting to the database from multiple processes, you’ll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected.</p>
</blockquote>
<p>生产环境下，肯定是多负载多进程的情况，并且一般用cluster模块去进行进程处理</p>
<pre class="prettyprint language-js"><code>if (cluster.isMaster) {
    for (var i = 0; i &lt; env.CPU; i++) {
        cluster.fork();
    }

    cluster.on('fork', worker =&gt; {
        log(`worker ${worker.process.pid} forked success`, 'info', logOptions);
    });

    cluster.on('online', worker =&gt; {
        log(`worker ${worker.process.pid} responded after it was forked`, 'info', logOptions);
    });

    cluster.on('exit', function (worker, code, signal) {
        log(`worker ${worker.process.pid} died (${signal || code})`, 'warn', logOptions);
        cluster.fork();
    });
} else {
    require('../app.js');
}
</code></pre><p>想请教下这种情况下，Sequelize的实例初始化应该在什么阶段？</p>







标题：新书《遗传算法与机器学习编程》试读
作者：sean-xu
发布日期：发布于 3 个月前
文章内容：<p>最近刚出的一本书，通过游戏和趣味问题讲解常见机器学习算法和概念，适合想了解机器学习的童学自学。
用的Python和JS，不借助现成的机器学习库，从零构建算法。
<strong>50页试读</strong>：链接：<a href="https://pan.baidu.com/s/1dnrKT4pVkL0m-jEMgbn45A">https://pan.baidu.com/s/1dnrKT4pVkL0m-jEMgbn45A</a>   提取码：blrd
天猫有售：<a href="https://detail.tmall.com/item.htm?id=697149470819">https://detail.tmall.com/item.htm?id=697149470819</a></p>
<p><img src="//static.cnodejs.org/Fr7d_YfB_ELo8CbQMZ30OlQGsThs" alt="宣传页-封面.png">
<img src="//static.cnodejs.org/FhYb4FQMvsi9LFVINs_CqsVoil-4" alt="宣传页-从零开始.png">
<img src="//static.cnodejs.org/FiMgemy-bx8a8Sc8xd_huJgPQyjf" alt="宣传页-趣味问题.png">
<img src="//static.cnodejs.org/FuVZMsVl9FJNbYIRnEYB5RGRxNAZ" alt="宣传页-可视化2.png">
<img src="//static.cnodejs.org/FvAZkejEyT-EbZP6eTLagaUG8IA7" alt="宣传页-亚马逊2.png"></p>







标题：node.js基于 cmake-js 进行插件开发实战
作者：zhoutk
发布日期：发布于 3 个月前
文章内容：<p>以前工作在node.js环境下，做微服务产品; 三年前转回到C++环境，已经有一些代码积攒。我将以往基于node.js与C++的相关项目结合起来（C++代码以addon插件嵌入），实现了一个微服务快速（rest api service）开发框架。该框架以关系数据库为基础，现在支持（mysql、sqlite3、postgres），同时支持windows, linux, macos。本文以该项目为蓝本，来说明使用C++为node.js开发插件的实践经验。</p>
<h2>项目结构</h2>
<ul>
<li>addon ： C++插件封装代码目录，这是一个node.js与C++的适配器，具体的C++功能都在thirds目录中</li>
<li>src ： node.js源码目录，一套完整的智能微服务代码，基于关系数据，提供标准的rest api service， 不需要写一行代码，详见 <a href="https://gitee.com/zhoutk/gels">gels项目</a></li>
<li>test ： 单元测试代码目录，提供了全面测试，同时也是很好的示例代码</li>
<li>thirds ： C++项目都放在这个目录下</li>
</ul>
<pre class="prettyprint"><code>|-- CMakeLists.txt
|-- addon                       //c++插件封装
|   |-- export.cc
|   |-- index.cc
|   `-- index.h
|-- package.json
|-- src                         //node.js核心源码
|   |-- config                  //只列出了目录
|   |-- dao
|   |-- db
|   |-- inits
|   |-- middlewares
|   `-- routers
|-- test                        //rest api 测试
|   `-- test.js
|-- thirds                      //依赖的c++项目
|-- package.json
`-- tsconfig.json
</code></pre><h2>Nodejs扩展基本开发</h2>
<h3>编译扩展，两种方式</h3>
<ul>
<li>node-gyp</li>
<li>cmake-js</li>
</ul>
<h3>开发环境</h3>
<p>因为，本人的C++项目都使用cmake进行项目管理的，所以我选择使用cmake-js来进行node.js的扩展开发。开发环境：</p>
<ul>
<li>windows : cmake &gt; 3.18, node.js &gt;= 16, visual studio &gt;= 2019; 若使用vs2022， windows SDK 必须安装10.的版本，只装11版本的话，编译会出错</li>
<li>linux : cmake &gt; 3.18, node.js &gt;= 16, gcc &gt;= 7.5</li>
<li>macOs : cmake &gt; 3.18, node.js &gt;= 16, clang &gt;= 12</li>
</ul>
<h3>项目依赖</h3>
<p>项目依赖，请参看package.json中相关小节，与插件开发相关的主要是以下三个项目：</p>
<ul>
<li>cmake-js</li>
<li>bindings</li>
<li>node-addon-api</li>
</ul>
<h3>CMakeLists.txt关键点说明</h3>
<p>完整的代码请自行到项目中去获取，我再这里只是节选，并进行一些说明</p>
<blockquote>
<p>c++版本指定，因为依赖库Zjson最低需要c++17</p>
</blockquote>
<pre class="prettyprint"><code>set (CMAKE_CXX_STANDARD 17)                             
SET(CMAKE_CXX_FLAGS "-D_GLIBCXX_USE_CXX17_ABI=0")
</code></pre><blockquote>
<p>windows必须增加如下的参数设定，必须将动态链接库的内存与主程序融合</p>
</blockquote>
<pre class="prettyprint"><code>set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} /MTd")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
</code></pre><blockquote>
<p>linux下的特殊要求, 其它环境不设这个变量，在链接的时候就只有linux会加上 dl这个参数</p>
</blockquote>
<pre class="prettyprint"><code>set(dlLinkParam dl)
...
target_link_libraries(${PROJECT_NAME} ${CMAKE_JS_LIB} ${MysqlDll} ${pqName} ${sqliteName} ${dlLinkParam})
</code></pre><blockquote>
<p>cmake-js最基本的编译设定</p>
</blockquote>
<pre class="prettyprint"><code>set(NODE_LINK_LIBS "")
set(NODE_EXTERNAL_INCLUDES "")

FILE(GLOB_RECURSE SOURCE_FILES "./addon/*.cc") 
FILE(GLOB_RECURSE HEADER_FILES "./addon/*.h") 

add_library(${PROJECT_NAME} SHARED ${HEADER_FILES} ${SOURCE_FILES} ${CMAKE_JS_SRC})
set_target_properties(${PROJECT_NAME} PROPERTIES PREFIX "" SUFFIX ".node")
message("-------- CMAKE_JS_INC -------" ${CMAKE_JS_INC})
# Include Node-API wrappers
target_include_directories(${PROJECT_NAME} PRIVATE  
    ${CMAKE_SOURCE_DIR}/node_modules/node-addon-api 
    ${CMAKE_SOURCE_DIR}/node_modules/node-addon-api/src
    ${CMAKE_JS_INC})
target_link_libraries(${PROJECT_NAME} PRIVATE ${CMAKE_JS_LIB})
</code></pre><p><strong>注： sqlite3 必须以动态链接库的形式接入，直接将.c和.h加入到主程序中，能编译通过，也能运行，但查询系统表的时候会出现异常</strong></p>
<h3>插件开发代码解析</h3>
<blockquote>
<p>addon 目录下是与C++项目适配的代码，C++的功能，先写成cmake管理的项目，放到thirds目录，再适配进addon插件，这样能做到相对的独立
一般需要三个文件：<a href="http://export.cc">export.cc</a>， index.h, <a href="http://index.cc">index.cc</a></p>
</blockquote>
<p><strong><a href="http://export.cc">export.cc</a></strong></p>
<pre class="prettyprint"><code>#include "index.h"

//导出接口
Napi::Object InitAll(Napi::Env env, Napi::Object exports) {
  return Zorm::Init(env, exports);
}

NODE_API_MODULE(Zorm, InitAll)
</code></pre><p><strong>index.h</strong></p>
<pre class="prettyprint"><code>#include &lt;napi.h&gt;           //node.js插件开发头文件
#include "Idb.h"            //数据库通用接口头文件

class Zorm : public Napi::ObjectWrap&lt;Zorm&gt;{
public:
    //导出函数
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    static Napi::FunctionReference constructor;
    //构造函数，生成一个orm对象，保存到 成员变量 db 中
    Zorm(const Napi::CallbackInfo&amp; info);
    //公用的类方法，要实现数据库通用接口的所有方法适配
    Napi::Value select(const Napi::CallbackInfo&amp; info);
    ...
private:
    ZORM::Idb* db;   //成员变量
};
</code></pre><p><strong><a href="http://index.cc">index.cc</a></strong></p>
<blockquote>
<p>初始化函数，定义所有成员方法</p>
</blockquote>
<pre class="prettyprint"><code>Napi::Object Zorm::Init(Napi::Env env, Napi::Object exports)
{
    Napi::HandleScope scope(env);
    Napi::Function func =
        DefineClass(env, "Zorm",            //除了这个函数，其它基本都是规定写法
                    {                       //定义外部能调用的所有成员方法
                        InstanceMethod("select", &amp;Zorm::select),  
                        ...
                    });

    constructor = Napi::Persistent(func);
    constructor.SuppressDestruct();

    exports.Set("Zorm", func);
    return exports;
}
</code></pre><blockquote>
<p>构造函数适配</p>
</blockquote>
<pre class="prettyprint"><code>
Zorm::Zorm(const Napi::CallbackInfo&amp; info) : Napi::ObjectWrap&lt;Zorm&gt;(info), db(nullptr)
{
    int len = info.Length();
    Napi::Env env = info.Env();
    if (len &lt; 2 || !info[0].IsString()) {               //函数参数解析，json对象我都用字符串进行传递；二进制使用Napi::Array jsNativeArray接收C++的char*
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    }
    std::string dbDialect = info[0].As&lt;Napi::String&gt;().ToString();
    std::string opStr = info[1].As&lt;Napi::String&gt;();
    ZJSON::Json options(opStr);
    db = new ZORM::DbBase(dbDialect, options);
}
</code></pre><blockquote>
<p>成员方法示例</p>
</blockquote>
<pre class="prettyprint"><code>Napi::Value Zorm::select(const Napi::CallbackInfo&amp; info)
{
    int len = info.Length();
    Napi::Env env = info.Env();
    if (len &lt; 1 || !info[0].IsString()) {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    }
    std::string tableName = info[0].As&lt;Napi::String&gt;().ToString().Utf8Value();

    ZJSON::Json params;
    if(len &gt;= 2){
        params.extend(ZJSON::Json(info[1].As&lt;Napi::String&gt;().ToString().Utf8Value()));
    }
    std::string fieldStr;
    if(len &gt;= 3){
        fieldStr = info[2].As&lt;Napi::String&gt;().ToString().Utf8Value();
    }

    ZJSON::Json rs = db-&gt;select(tableName, params, ZORM::DbUtils::MakeVector(fieldStr));
    return Napi::String::New(info.Env(), rs.toString());
}
</code></pre><h2>项目地址</h2>
<pre class="prettyprint"><code>https://gitee.com/zhoutk/zrest
或
https://github.com/zhoutk/zrest
</code></pre><h2>安装运行</h2>
<ul>
<li>新建配置文件，./src/config/configs.ts， 指定数据库：<pre class="prettyprint"><code>export default {
    inits: {
        directory: {
            run: false,
            dirs: ['public/upload', 'public/temp']
        },
        socket: {
            run: false
        }
    },
    port: 12321,
    db_dialect: 'sqlite3',              //数据库选择，现支持 sqlite3, mysql, postgres
    db_options: {
        DbLogClose: false,              //是否显示SQL语句
        parameterized: false,           //是否进行参数化查询
        db_host: '192.168.0.12',
        db_port: 5432,
        db_name: 'dbtest',
        db_user: 'root',
        db_pass: '123456',
        db_char: 'utf8mb4',
        db_conn: 5,
        connString: ':memory:',         //内存模式运行
    }
}
</code></pre></li>
<li>在终端（Terminal）中依次运行如下命令<pre class="prettyprint"><code>git clone https://gitee.com/zhoutk/zrest
cd ztest
npm i -g yarn
yarn global add typescript eslint nodemon
yarn
tsc -w          //或 command + shift + B，选 tsc:监视
yarm configure  //windows下最低vs2019, gcc 7.5, macos clang12.0
yarn compile    //编译c++插件, 若有问题，请参照 [Zorm](https://gitee.com/zhoutk/zorm) 文档，特别是最后的注释
yarn start      //或 node ./dist/index.js
export PACTUM_REQUEST_BASE_URL=http://127.0.0.1:12321
yarn test       //运行rest api接口测试，请仔细查看测试文件，其中有相当完善的使用方法
                //修改配置文件，可以切换不同的数据，运行测试；使用mysql或postgres时，请先手动建立dbtest数据，编码使用Utf-8
</code></pre></li>
<li>测试运行结果图<br>
测试运行输出<br>
<img src="//static.cnodejs.org/FgdBimw8jMVFjN8qoNr-G5EfsSmO" alt="test_result_01.jpg"><br>
项目日志（包括请求和sql语句）<br>
<img src="//static.cnodejs.org/FgmFiliCEfuv_gNB-nRrl1huYEup" alt="test_result_02_.jpg"></li>
</ul>
<h2>相关项目</h2>
<ul>
<li><a href="https://gitee.com/zhoutk/zrest">Zrest</a>  node.js嵌入c++插件项目，实现跨平台多数据库无缝切换的微服务开发框架</li>
<li><a href="https://gitee.com/zhoutk/gels">gels</a>  node.js项目，基于koa2实现的rest api服务框架，功能齐全; 以gels为入口，实现本项目，c++项目以插件方式集成</li>
<li><a href="https://gitee.com/zhoutk/zjson">Zjson</a>  c++项目，实现简单高效的json处理</li>
<li><a href="https://gitee.com/zhoutk/zorm">Zorm</a>  c++项目，以json对象为媒介，实现了一种ORM映射;设计了通用数据库操作接口规范，能无缝的在多种数据库之间切换</li>
</ul>







标题：请教一下compressing这个压缩组件如何压缩空目录？
作者：wldlzt
发布日期：发布于 4 个月前
文章内容：<p>如题，compressing压缩的目录清单中，如果有空目录，是不会压缩进去的，请问有朋友解决过这个问题吗？</p>







标题：sequelize 怎么实现 (AllTestID,ChildTestID) in((2000591,-1),(9002339,9000207))
作者：yuexiangqianlong
发布日期：发布于 4 个月前
文章内容：<p>比如  大题ID（AlltestID） 小题ID （ChildtestID）
sql 语句是 select * from test where userID =1 and  (AllTestID,ChildTestID) in((2000591,-1),(9002339,9000207))
用sequelize 实现上面的sql 怎么实现</p>







标题：Vue3 技术揭秘
作者：muwoo
发布日期：发布于 4 个月前
文章内容：<p>随着 Vue 3 正式版本的发布，未来 Vue 3 将会成为前端的主流框架，这个毋庸置疑。Vue 3 在使用方面会兼容部分 Vue 2.x 的特性，比如 <code>options API</code>。
所以，究竟是要先学习 Vue 2 打好基础，还是直接学习 <code>Vue 3</code> 呢？
当 Vue 作者尤大面对这样的提问时，直接给出了非常坚定的回答：<strong>直接学 <code>Vue 3</code> 就行了，基础概念是一模一样的</strong>。
不过，在学习使用 Vue 3 的过程中，很多小伙伴会遇到一些痛点问题，比如：</p>
<ul>
<li>Vue 3 渲染器做了哪些事情？</li>
<li>Vue 3 的响应式和 Vue 2 相比有什么不同？</li>
<li>Vue 3 编译器的过程是什么样的？</li>
<li>Vue 3 传说中的编译时优化，究竟做了哪些工作？</li>
<li>Vue 3 一些内置内容究竟是如何运作的？</li>
<li>……</li>
</ul>
<p>只有解答了上述这些问题，才能更好地使用高性能的 Vue.js，也可以帮助你在做项目的时候，在了解 Vue 运行机制的前提下，写出性能更优的代码。另外，很值得一提的是，在阅读 Vue 3 源码的时候，你会发现大量优秀的设计模式和算法，让人拍案叫绝。</p>
<p>但是，直接去啃 Vue 3 源码会非常晦涩难懂，<strong>比如一个 baseCreateRenderer 函数就有接近 2000 行代码</strong>，可能会让你半途而废（妥妥地 “从入门到放弃”），这个估计很多小伙伴们都深有体会。
所以，《Vue 3 技术揭秘》一方面会对 Vue 3 核心源码做适量的精简，让你可以只用关注核心逻辑实现；另一方面，也配了大量的插图，一图胜千言，可以更加生动地向你展示源码的运行机制。
《Vue 3 技术揭秘》主要划分为了 5 大模块 来依次为你揭开 Vue 3 的 “神秘面纱”。</p>
<ul>
<li>模块一：渲染器实现原理。从根组件初始化开始，一步步介绍组件实例化、完整更新、diff 过程等。</li>
<li>模块二：响应式原理。核心介绍 Vue 3 基于 Proxy 实现的响应式原理，深入解读依赖收集过程、响应式触达过程和相关联的 watch、computed、inject/provide 函数实现以及异步批量更新原理。在学习的过程中，你会渐进式体会到与 Vue 2 响应式原理的差异以及异步批量更新的不同之处。</li>
<li>模块三：编译器实现原理。重点讲解模板是如何被一步步编译成渲染函数的，以及在编译时 Vue 3 所做的大量编译时优化的工作。</li>
<li>模块四：内置组件实现原理。主要介绍 Vue 3 几个常用的内置组件：Transition、KeepAlive、Teleport 、Suspense 相关的组件运行机制和实现原理。</li>
<li>模块五：特殊元素 &amp; 指令。重点分析 v-model 是如何实现双向数据绑定的，以及 slot 插槽是如何实现内容分发的。</li>
</ul>
<p>目前还有少量五折码：5pmiBJ4S。
小册将会通过渐进式的方式带大家通读 Vue 3 的源码和设计理念。
<a href="https://juejin.cn/book/7146465352120008743">掘金地址：Vue 3 技术揭秘</a></p>







标题：请教下大家：如何保存chrome中页面控制台输出的所有信息？环境是NW.JS，可以拿到chrome的对象
作者：wldlzt
发布日期：发布于 4 个月前
文章内容：<p>用什么办法能把谷歌页面控制台中所有打印的信息（包括页面debug的各类异常信息，如变量不存在之类）给输出或保存起来？</p>







标题：xeokit 一个国外人写的 3d模型js库，有大佬用过没
作者：dyjiang
发布日期：发布于 9 个月前
文章内容：<p>这个库网上教材太少了，学习起来好费劲、 有大佬有好的笔记或者学习方法没，</p>







标题：关于 NodeJS 在 Windows 上杀死启动的进程问题
作者：JZLeung
发布日期：发布于 4 个月前
文章内容：<p>环境：Electron + NodeJS(windows10 ，不考虑 Linux)。</p>
<p>程序是这样的：</p>
<ol>
<li>node 使用 spawn，传入 execFile （有可能只是个 xxx.bat 脚本）和 args ，启动了一个 java 进程（监听端口 8080 ）。</li>
<li>返回的 <code>child_process</code> 有一个 PID （如 11111 ），但它是属于启动的 cmd 的 PID ，实际 java 进程的 PID 是 22222 。</li>
<li>程序运行期间，会不断访问 java 程序的心跳接口。</li>
<li>退出前，使用 <code>taskkill /T /F /PID 11111</code>，能把这两个进程直接杀掉，但是！该 8080 端口还有很多状态为 <code>TIME_WAIT</code> 的连接没被一同 kill 掉，导致端口一直是被占用的状态。
当然，如果我直接用任务管理器将 java 进程强制终止，那也一样会有 <code>TIME_WAIT</code> 的连接，需要等待一段时间，才能解除端口占用。</li>
</ol>
<p>求教各位大佬，怎么才能一劳永逸的直接杀死进程。</p>
<p>PS: 并不知道这个进程的名称（就没办法用 taskkill /F /IM ${name} 来杀进程）是啥。</p>







标题：如何用Node.js平滑关闭正在使用中的http服务占用的端口？
作者：wldlzt
发布日期：发布于 4 个月前
文章内容：<p>如题…没想到在这样不起眼的问题上掉坑了，以前都是是直接用cmd关闭端口，现在出于某些原因需要用node.js来平滑关闭，但试了好多方案都不行，请教一下有了解的同学，麻烦指点一二，谢谢~~~~</p>







标题：有人用svelte吗？看油管那些UP主讲得很好
作者：xinggsf
发布日期：发布于 4 个月前
文章内容：<p><a href="https://github.com/sveltejs/svelte">https://github.com/sveltejs/svelte</a>
还是麻省理工学院出的
<a href="https://www.youtube.com/watch?v=sCAcDWqrORQ">https://www.youtube.com/watch?v=sCAcDWqrORQ</a></p>







标题：反直觉的问题，请教下如何关闭http的服务并释放端口？
作者：wldlzt
发布日期：发布于 4 个月前
文章内容：<p>之前觉得这个问题很简单，但不管是server.close还是对所有连接对象进行close，似乎都不能释放已经占用的3000端口。请教下大家如何直接关闭这个http服务并释放占用的端口？</p>
<pre class="prettyprint language-js"><code>let http = require('http');
let hostname = '127.0.0.1';
let port = 3000;
let ret = 'Hello World';
let server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  console.log(ret);
  res.end(ret);
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>






标题：请教一下大家，用node.js调用bat脚本时,如何给bat脚本中的某个变量动态传参？
作者：wldlzt
发布日期：发布于 10 个月前
文章内容：<p>如题。
假设bat是用来下载某个文档，但又不想在bat中写死，除了重新生成bat的文件内容外，有没办法直接给bat的下载地址变量进行传参？</p>







标题：node新版官网
作者：yuu2lee4
发布日期：发布于 5 个月前
文章内容：<p><img src="//static.cnodejs.org/Ft8_cCdj8Hzp2gGqC7lDvGGk3oZt" alt="image.png"></p>
<p><a href="https://nodejs.dev">https://nodejs.dev</a></p>







标题：介绍下Web3赏金黑客们必备的开箱即用 Web3 元宇宙 NFT 开发必备脚手架
作者：lyman
发布日期：发布于 4 个月前
文章内容：<p>你好呀，我是 Bruce，元宇宙赏金黑客组织 Web3HackerDAO 创始人，在这里我主要分享我对世界的所见所闻、Web3 的一些看法理解以及技术积累文字。</p>
<p>Web3HackerDAO 是一个由“元宇宙赏金黑客”为中坚产品开发力量的从全人类角度思考而开发的 Web3 产品的一个去中心化的黑客组织。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f40bebec14407b888bbd03af0eff33~tplv-k3u1fbpfcp-watermark.image?" alt="1.commit-list.png"></p>
<p>这个脚手架是 Bruce 多次比赛并连续拿了 10 几个Web3黑客松奖后积累的一套可以开箱即用的 Web3 前端脚手架，这个月Web3 黑客松比赛有好几个，目前要参赛的 idea 正在疯狂脑暴构思中，昨天刚刚从新过了一遍&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483743&amp;idx=4&amp;sn=53d1e5956ebcc781acc408079e06a0f4&amp;chksm=c3240a62f45383743ea6ea1e7b35a1d4b8817045c0f642ec46c5a1a23ad77d3f3fa00eb30465&amp;token=1516207029&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="一个解决方案来让你的 NFT 拥有无限可能">一个解决方案来让你的 NFT 拥有无限可能</a>&nbsp;的 Diamond 合约架构的脚手架代码。</p>
<p>昨天到今天刚刚加入了 2 位 赏金黑客，要一起参与这轮的 Web3 黑客松比赛，忽然发现我可能没有介绍清楚这套代码的逻辑，幸亏第一位加入的黑客同学是正好也有类似的逻辑才一看我之前的文章介绍就明白这个“赏金黑客”脚手架的意义！</p>
<p><strong>在文章结尾我附带了两个已经开源的拿了Web3黑客松奖的部分组件代码，欢迎查看！</strong></p>
<p>时间紧迫，这里我简单介绍下这个 Web3 开发前端脚手架的核心几个特性，以及整个 Web3HackerDAO 生态的后续整体架构脉络。</p>
<h2>开箱即用的 Web3 前端开发脚手架</h2>
<p>Web2 从业 10 几年，到最后会发展到了低代码等，其实本质是对代码的进一步抽象。虽然各种框架语言不断推陈出新，但是从业务角度来看，不外乎各种登录、支付、数据组件业务的抽象化，使其方便后续快速开发等。</p>
<p>到了 Web3，一样的出现各种不同的框架方案，当然在前端还是 Vue，React 或其他 Web2 一样的前端框架，而核心关键在于有一套乘手的解决方案。</p>
<p>对于市面上各种 Web3 教程或者资料合集、Awesome 系列研究了一波后，总结了这样一套基于 Vue3 技术栈的框架方案，目的在于帮助还不熟悉 Web3 开发的同学可以比较低成本的能介入开发一个完整的 Web3 应用。</p>
<p>当然这个框架方案并不是只能在初级阶段使用，而是适用于产品化应用开发项目的，基本上是 Bruce 最近半年的最佳实践的反复总结的。</p>
<p>前端框架使用 Vue3，是基于 <a href="https://github.com/antfu/vitesse">https://github.com/antfu/vitesse</a> 提供的最佳实践脚手架基础上增加了 Web3 业务组件搭建的。</p>
<h3>1. 添加了常用的组件，整套 UI 是基于 TailwindCSS 的</h3>
<ul>
<li>
<p>•&nbsp;loading</p>
</li>
<li>
<p>•&nbsp;LoginModal: Web3 登录</p>
</li>
<li>
<p>•&nbsp;OnboardModal: 在用户浏览器未安装 Metamask 时进行引导下载的组件</p>
</li>
<li>
<p>•&nbsp;基本按钮组件: 添加了点击音效功能</p>
</li>
<li>
<p>•&nbsp;弹窗组件: 用于信息提示等</p>
</li>
<li>
<p>•&nbsp;编辑器组件：基于 <a href="/user/kangc">@kangc</a>/v-md-editor 包进行了二次封装</p>
</li>
</ul>
<p>下方截图中一些目录是某些不同项目的组件的目录，非所有组件都是公共组件。</p>
<p>一般是先针对某个项目开发了某个组件，后面多个项目确实重复使用了某个组件才去抽离出来作为通用组件。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff7b5271377d49749c37054f6a2c97cf~tplv-k3u1fbpfcp-watermark.image?" alt="2.component-list.png"></p>
<h3>2. 基于 IPFS 服务的图片、文件管理组件</h3>
<ul>
<li>
<p>•&nbsp;可拖拽上传</p>
</li>
<li>
<p>•&nbsp;单个图片上传及展示: 可用于头像、文章头图的上传表单使用</p>
</li>
<li>
<p>•&nbsp;多个图片上传及展示: 可用于相册等表单组件</p>
</li>
<li>
<p>•&nbsp;图片自动上传到 IPFS（基于 NFT.Storage 的服务封装）</p>
</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3d367d00314633a0dba2f3350f8615~tplv-k3u1fbpfcp-watermark.image?" alt="3.fileuploader.png"></p>
<h3>3. 使用&nbsp;<code>.env</code>&nbsp;文件来本地开发可以设置&nbsp;<code>VITE_PROJECT_FOLDER</code></h3>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee8cfc527ab4446bd382a80950bfd09~tplv-k3u1fbpfcp-watermark.image?" alt="4.dot-env.png"></p>
<ul>
<li>
<p>•&nbsp;多个不同项目可以放在一个代码库里而互相不干涉，我们以建立新项目&nbsp;<code>awesome-web3</code>&nbsp;为例</p>
</li>
<li>
<p>•&nbsp;不同项目在 pages 目录下新建一个对应的子目录即可，这里我们建立&nbsp;<code>/pages/awesome-web3</code>&nbsp;目录</p>
</li>
<li>
<p>•&nbsp;复制&nbsp;<code>/public/default</code>&nbsp;目录为&nbsp;<code>/public/awesome-web3</code>&nbsp;目录，可以自行替换里面的图片 logo 等为新项目的 logo，这些 logo 会被用到浏览器 favico 或者一些组件的布局 logo 里面</p>
</li>
<li>
<p>•&nbsp;<code>.env</code>&nbsp;内设置&nbsp;<code>VITE_PROJECT_FOLDER=awesome-web3</code></p>
</li>
</ul>
<h3>4. 自动化的部署策略</h3>
<p>目前代码是部署到 vercel 上并设置了自动化的域名映射的，简单来说是这样的：</p>
<ul>
<li>
<p>•&nbsp;不同的 branch 会在 vercel 上有对应设置的域名映射</p>
</li>
<li>
<p>•&nbsp;不同的 branch 在 vercel 上也有设置不同的环境变量参数</p>
</li>
<li>
<p>•&nbsp;一旦 push 新的代码到该 branch，则 vercel 会自动触发 build 该域名的代码，而不会和其他项目冲突</p>
</li>
<li>
<p>•&nbsp;在某个项目开发到一定程度阶段时，再 merge 到 main 分支，这样该项目开发过程中新增的一些公共的组件或者功能则可以共享给其他项目使用</p>
</li>
</ul>
<p>还有其他更多特性，待这个月密集的几个 Web3 黑客松比赛过后（总奖金超过 100万美金：<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483749&amp;idx=1&amp;sn=32b2315069f2083ef879a7c1552714f4&amp;chksm=c3240a58f453834e6b61ee20435840c64b3dd2ea0fc16113851c5fe48d9396dac8c70d2124a0&amp;token=1902673380&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="Web3 赏金黑客 11月-12月可以关注的几个黑客松比赛 ，总共奖金超过100万刀！">Web3 赏金黑客 11月-12月可以关注的几个黑客松比赛 ，总共奖金超过100万刀！</a>），会回过头来整理下项目的多语言官网以便更多黑客伙伴加入“元宇宙赏金黑客”组织一起改进这个脚手架！</p>
<p>是的，要作为全球的一个统一的 Web3 前端开发平台来发展的！因为本身“元宇宙赏金黑客”组织要开发的 Web3 产品基本上都是基于全人类使用的角度来做的，并不会太在意国内或者国外市场的区别的。</p>
<h2>招募这个月一起参与 Web3 黑客松的伙伴</h2>
<p>目前已经有两位伙伴加入，欢迎更多想要介入 Web3 开发的伙伴加入成为“元宇宙赏金黑客”的一员！一起打造 “Web3 的 DApp 工厂”。</p>
<p>这个月接下来时间 Bruce 会花更多在和 “赏金黑客" 成员一起快速构建几个 idea 参加几个 Web3 黑客松比赛上，欢迎感兴趣的黑客们加入，一起使用改进这个“开箱即用”的 Web3 开发套件脚手架！</p>
<p><strong>参与开发项目的伙伴，如果项目有拿到 Web3 黑客松奖，则会根据具体贡献分配一部分奖金做为贡献奖励！</strong></p>
<p>Web3HackerDAO 的伙伴分以下几类：</p>
<h3>1. 赏金黑客</h3>
<p>这是整个组织的核心开发力量，他们要具备极强的好奇心，也乐于学习新的技术及知识，能全栈开发整个产品，这样一旦有什么新的 idea 可以非常快速的在 DAO 内组建人数极少的“赏金黑客” 小分队，快速的迭代开发产品。</p>
<p>加入者需要具备一定的开发能力，不一定需要马上是技能点都点满的。</p>
<p>因为最终在整个 DAO 内，赏金黑客是自由流动的，他们可能是某个项目的核心开发者，也可能同时是多个不同项目的早期开发者，但是中后期作为维护支持即可。取决于每个项目及每个“赏金黑客”的意愿。</p>
<h3>2. VC/基金/早期投资者 成员</h3>
<p>此类成员需要满足一定的条件，当然最核心会满足资源资金上的限定，否则 DAO 内孵化的项目组会疲于与不同的“走马观花”的所谓投资者沟通而浪费大量的可以 Build 的时间。</p>
<p>赏金黑客经过一定时间的开发后，DAO 会组织线上的多项目同时的 Pitch 大会，让这类成员可以一次性看多个 DAO 孵化产出的项目。</p>
<p>后面 DAO 也会开发一系列的工具来做 VC 成员的资产零知识验证。</p>
<h3>3. 早期尝鲜种子用户</h3>
<p>此类用户为平台的“种子用户”，会成为平台的热心用户，帮助各个项目组早期找 bug，同时在项目成熟推向市场时，会给与极大的宣传帮助。</p>
<p>当然，各个项目也会在平台的统一的“黑客增长”相关模块功能下，给与此类用户明确的项目奖励。</p>
<p>以上是目前规划的 《元宇宙赏金黑客》组织 Web3HackerDAO 的几类用户，也许后续也会进一步调整。具体的要求规则可以联系 Web3Hacker ！</p>
<h2>两个开源的获奖的代码说明</h2>
<h3>1.&nbsp;Stockx3[1]</h3>
<p>这个项目一开始是想开发个 Web3 版本的 <a href="http://Stockx.com">Stockx.com</a> 来着，后来发现可能要做真正球鞋交易平台，可能对于平台运营来说比较重，后面就简化成，任何人可以在上面发布自己的产品信息了。</p>
<p>每发布一个产品信息其实就是发布了一个新的 ERC1155 的 NFT，只是我在产生 NFT 的元数据提交到 IPFS 并使用 LitProtocol 来做了加密部分信息的处理，这样只有购买了此 NFT 的用户，才可以获得加密后的信息。</p>
<p>这个产品已经在 Web3HackerDAO 内立项，并会从新整理并开发为 “<a href="http://SellX3.com">SellX3.com</a>”，作为 Web3 的亚马逊吧。</p>
<h3>2.&nbsp;NftTop.Best: Web3-ProductHunt[2]</h3>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1af042039f5e4050ab26347c45734db3~tplv-k3u1fbpfcp-watermark.image?" alt="ntb.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aedcb4618f14ae4915f508d9515f499~tplv-k3u1fbpfcp-watermark.image?" alt="stockx3.png">
顾名思义，有用过 Product Hunt 的同学应该明白什么意思，不过这个项目有更加进一步的动作。</p>
<p>他相当于集成了产品提交、众筹、捐赠、评论、投票几个功能为一体的 Product Hunt， 虽然我看到 Product Hunt 现在也推出了 Web3 频道，不过似乎他并没有真正融入 Web3，这个项目后续会进一步运用落地到 <a href="https://NFTTop.Best">https://NFTTop.Best</a> ， 作为 DAO 孵化项目对外公开的一个渠道，这样所有用户都可以对我们的产品进行投票、捐赠、评论。</p>
<p>ok，以上就是今天的内容，感兴趣加入 Web3HackerDAO 的同学欢迎加 Web3Hacker !</p>
<hr>
<p>—全文完</p>
<h2>往期文章推荐</h2>
<ul>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483765&amp;idx=1&amp;sn=b6dca6f49547305c7285e6f44890d034&amp;chksm=c3240a48f453835e40a91169c538427b656c749be7d3a194eb71becfc8966cc4770d5e326562&amp;token=1902673380&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="元宇宙赏金黑客传奇》的相关计划">元宇宙赏金黑客传奇》的相关计划</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483757&amp;idx=1&amp;sn=98fa5602a844296e8fd1421f0649c241&amp;chksm=c3240a50f45383468a8b68582ba8daf5406da2430526aec923b4af9c8234e48e2851ea4e7329&amp;token=1902673380&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="为什么说加入元宇宙赏金黑客组织 Web3HackerDAO 能改变世界？">为什么说加入元宇宙赏金黑客组织 Web3HackerDAO 能改变世界？</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483749&amp;idx=1&amp;sn=32b2315069f2083ef879a7c1552714f4&amp;chksm=c3240a58f453834e6b61ee20435840c64b3dd2ea0fc16113851c5fe48d9396dac8c70d2124a0&amp;token=1902673380&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="Web3 赏金黑客 11月-12月可以关注的几个黑客松比赛 ，总共奖金超过100万刀！">Web3 赏金黑客 11月-12月可以关注的几个黑客松比赛 ，总共奖金超过100万刀！</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483766&amp;idx=1&amp;sn=f7abe02641f48309021ea8bfa206aed0&amp;chksm=c3240a4bf453835db79e588f61c1d62a1ac3afcad880b59b0452455f1f4e453904b79764ed6d&amp;token=1902673380&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="脑洞大开之从中医是先人个人努力打造的大数据系统累积的结果联想到的 Web3 对世界的作用">脑洞大开之从中医是先人个人努力打造的大数据系统累积的结果联想到的 Web3 对世界的作用</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483715&amp;idx=1&amp;sn=4c39648183b0cb2781819e3a065d0a86&amp;chksm=c3240a7ef45383681fff64cff623ef0a9590abf8f6f31e015975210ebc64d1f1b67f26356fa7&amp;token=1411723489&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="一个解决方案来让你的 NFT 拥有无限可能">一个解决方案来让你的 NFT 拥有无限可能</a>&nbsp;当前 1244 阅读，￥2000 赞赏</p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483724&amp;idx=1&amp;sn=fc41f238ce5c49147e8e2e06a6af3843&amp;scene=21#wechat_redirect" title="开源一个连续拿了 3 个 Web3 黑客松奖项目">开源一个连续拿了 3 个 Web3 黑客松奖项目</a>&nbsp;当前 953 阅读，￥300 赞赏</p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483708&amp;idx=1&amp;sn=0d2d49eea145f6cb5a9e1775a0b8e940&amp;chksm=c3240a01f4538317dc0d95c240a0ce44ff8c99b85ef3d4d0f8aa321ce9ca27a0c3153a97ecfe&amp;token=1411723489&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="Gumroad 发展史来看 Web3 的精益创业">Gumroad 发展史来看 Web3 的精益创业</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483703&amp;idx=1&amp;sn=89763660ee0a38f7a828c4da38bc57c2&amp;chksm=c3240a0af453831c4d36cb08761055282f377764f9b395c321e0f4e30cef1422b97c3fa5a613&amp;token=1411723489&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="一起做个 Web3 精益创业的实验： Web3Space 平台种子用户招募中！">一起做个 Web3 精益创业的实验：Web3Space 平台种子用户招募中！</a></p>
</li>
<li>
<p>•&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=Mzk0NDM5NzkwNg==&amp;mid=2247483696&amp;idx=1&amp;sn=fba0087567509edec610a603f19b8262&amp;chksm=c3240a0df453831b873334141549226ab57192c85fa75d05c35499b0f52650cd268bcd892c04&amp;token=1411723489&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="SBT.Dating，全球首个零知识证明的约会 DApp">SBT.Dating，全球首个零知识证明的约会 DApp</a></p>
</li>
</ul>
<h4>引用链接</h4>
<p><code>[1]</code>&nbsp;Stockx3:&nbsp;<em><a href="https://github.com/NftTopBest/stockx3">https://github.com/NftTopBest/stockx3</a></em><br>
<code>[2]</code>&nbsp;NftTop.Best: Web3-ProductHunt:&nbsp;<em><a href="https://github.com/NftTopBest/hackathon-city-filecoin-nervos">https://github.com/NftTopBest/hackathon-city-filecoin-nervos</a></em></p>







标题：React native开发苹果APP方便吗？支持硬件API的调用吗？
作者：xinggsf
发布日期：发布于 5 个月前
文章内容：<p>例如我要开发的APP，要支持直接输出打印机输出，能不能在React native做到？会不会很麻烦？
做过类似APP项目的出来亮亮相</p>







标题：ws库内存溢出
作者：yh4922
发布日期：发布于 5 个月前
文章内容：<h2>项目描述</h2>
<p>node创建一个ws服务端 接收python(算法端)发送过来的图片数据(base64)，收到后进行业务处理 并合成视频</p>
<h2>问题描述</h2>
<p>ws接收数据的时候会出现内存溢出的情况，但是不是每次都会出现，有时候会出现，有时候不会出现</p>
<h2>代码</h2>
<pre class="prettyprint language-javascript"><code>const WebSocketServer = require('ws').Server;
const WSS = new WebSocketServer({
  path: '/ws',
  maxPayload: 2048000,
  perMessageDeflate: true,
  // ...
})

WSS.on('connection', (ws) =&gt; {
  ws.on('message', (data) =&gt; {
    // 收到图片数据 进行处理
  })
})
</code></pre><h2>调试了挺久 一直没什么进展，有没有大佬遇到过这种情况，或者有什么思路可以提供一下</h2>







标题：我整了个在线简历制作工具，有找工作需求的朋友可以来看看！
作者：lblblong
发布日期：发布于 6 个月前
文章内容：<p>地址： <a href="https://open-resume.netlify.app/">https://open-resume.netlify.app/</a></p>
<p>开源地址： <a href="https://github.com/lblblong/open-resume">https://github.com/lblblong/open-resume</a></p>
<p>预览：</p>
<p><a href="https://imgse.com/i/xwuVPO"><img src="https://s1.ax1x.com/2022/10/14/xwuVPO.png" alt="xwuVPO.png"></a></p>
<p>祝找工作的朋友们金秋十月找个好工作！</p>







标题：Node真该改改了
作者：enzh
发布日期：发布于 1 年前
文章内容：<p>写node的最大感受就是，不断地用脚本在写路由，用了框架也是如此，本来这些属于服务器的任务，结果变成了脚本的任务，令人厌倦，实在烦了，难怪创始人都走了。
如果asp开源，独立出iis，支持跨平台、js新特性，吸收node，php，.net，Java，ruby等技术的优点，不断升级，成为一个轻量级的技术。那么，会果断把node给扔了，不再用这玩意。可惜了asp。
现在，把node的各种包，加上node本身，整个体积和php差不多，越来越臃肿。
如果node官方，能改改，把路由变成exe里的一部分，成为类似apache、tomcat的东西，接管路由，不再是现在一个路由文件负责。或者变成双模式，由config。xml，或config。json进行一下配置，可以延续原有的路由模式，或者象其他语言的一样，由服务器接管，那就好了。有个选择，总比没有要好太多。</p>
<p>设想：</p>
<p>1，设置根目录下的 config.json 或 server.json，发挥基础作用</p>
<p>2，后缀改变，。njs 取代 。js，直接废掉静态目录设定</p>
<p>由于要废掉静态目录设置，所以有必要区分 js
。njs 给 node 的，只能后端执行，动态文件
。js 是给前端的，只能前端执行，静态文件</p>
<p>njs 是默认后缀，也可以在前面的json配置中，改为任意名称</p>
<p>3，单入口模式终结，保留单入口模式，增加多入口模式，也就是 exe 接管路由
serve。json里设置采用什么模式
单入口模式，假设叫特殊模式，启动采用：node 入口
多入口模式，假设叫常规模式，由 node。exe 接管路由，有更大权力
启动时，直接根目录下：
node 或 node .
自动加载 。json 配置
抛弃以前的单入口路由模式。</p>
<p>常规模式下，所有的 。njs 都会被直接执行。</p>
<p>4，config.json 或 server.json，设置路径作用</p>
<p>在 json中可以设置访问路径
{
// 虚拟路径 》实际路径
虚拟路径：实际路径，
// 或者 虚拟路径 》虚拟路径 》实际路径
虚拟路径：{
		虚拟路径： 实际路径
	},
// 或者 虚拟路径 》实际路径 》实际路径
虚拟路径：{
		实际路径： 实际路径
	}
}
废掉 express 等框架</p>
<p>5，url的访问，默认是同名 njs
如：
http：//url/list
实际访问 list。njs</p>
<p>如果设置了虚拟路径，则 json配置的虚拟路径生效，更高优先级。</p>
<p>如果访问目录
http：//url/list/
默认访问 list/ 目录下的 index。njs</p>
<p>可以在前面的 json 配置文件设置影响所有目录的默认访问文件，也可以单独为不同目录设置不同的首个默认文件。
如果不设置，默认为 index。njs</p>
<p>6，node作为服务器的安全提升，无需第三方工具以防宕机</p>
<p>7，依然使用 js，而不用 ts</p>
<p>8，以上的设想，不是再用 js 写个新的框架，而是用 C和C++从底层彻底改变 node。exe</p>







标题：Sutando: 新的 ORM 轮子
作者：kiddyuchina
发布日期：发布于 6 个月前
文章内容：<p>Sutando 是一个全新的 Node.js ORM，支持 MySQL, PostgreSQL, MariaDB, SQLite 等多种数据库，目前只支持 Javascript。</p>
<p>Sutando 借鉴了 PHP 框架 Laravel 的 ORM - Eloquent，如果你之前用过 Laravel，那你使用 Sutando 几乎没有学习成本，因为它们的使用起来几乎相同。</p>
<p>项目地址：
<a href="https://github.com/sutandojs/sutando">https://github.com/sutandojs/sutando</a></p>
<p>文档地址：<a href="https://cn.sutando.org">https://cn.sutando.org</a></p>
<h3>为什么要用 Sutando？</h3>
<p>你可能会问，现在已经有那么多成熟的 ORM 了，为什么还要用 Sutando 呢？</p>
<p>一句话说，就是它 <strong>友好易用的 API</strong>：</p>
<ol>
<li>
<p>更加符合直觉的查询筛选方式</p>
<p>Sutando 没有选择把所有查询放在一个参数对象里，也没有特别去设定操作符，而是完全使用链式操作去构建查询语句。下面是一个简单对比的例子，查询出 <strong>某个作者</strong> 或 <strong>浏览量大于 100</strong> 的文章：</p>
<pre class="prettyprint language-js"><code>// sequelize
Post.findAll({  
  where: {  
    [Op.or]: [  
      { author_id: 12 },  
      { views: {
        [Op.gt]: 100
      } } 
    ]  
  }  
});

// prisma
prisma.post.findMany({
  where: {
    OR: [
      { author_id: 12 },
      { views: {
        gt: 100
      } }
    ]
  }
});

// sutando
Post.query().where('author_id', 12).orWhere('views', '&gt;', 100).get();
</code></pre><p>这个例子已经足够简单，但依然能看出 sutando 要比 sequelize 和 prisma 清晰很多，而且你可能会发现这个写法有点眼熟，没错，Sutando 的查询构造器就是基于 knex。</p>
</li>
<li>
<p>更方便的模型关联查询</p>
<p>这个就不做对比了，大家可以自行脑补其他 ORM 的实现方式，有的 ORM 需要写原生 SQL 语句才能做到（说的就是 prisma）。</p>
<pre class="prettyprint language-js"><code>// 预加载, 查找 50 岁以上的用户，并附带查询他们 所有的文章 和 红色的汽车
const users = await User.query()
  .with(
    'posts',
    { cars: q =&gt; q.where('color', 'red') }
  )
  .where('age', '&gt;', 50)
  .get();

// 延迟加载，已经查询到用户的情况下，加载他们的所有文章到相应用户的属性里
await users.load('posts');

// 直接获取关联数据
const posts = await user.getRelated('posts');

// 关联筛选
const redCars = await user.related('cars').where('color', 'red').get();

// 关联模型计数，这样每个用户会多出来一个 posts_count 属性
const users = await User.query().withCount('posts').get();
</code></pre></li>
<li>
<p>其他一些常用的使用方式</p>
<pre class="prettyprint language-js"><code>// 分页，会附带 total, currentPage 等一些常用属性和方法
const users = await User.query().where('age', '&gt;', 23).paginate(15);

// whereX，可以在 where 后直接加上字段名
const users = await User.query().whereAge('&gt;', 23).paginate(15);

// 模型定义
const { Model } = require('sutando');
class User extends Model {
  // 自定义访问器
  // user.full_name
  getFullNameAttribute() {
	return this.attributes.first_name + ' ' + this.attributes.last_name;
  }

  // 自定义作用域
  // User.query().popular().get()
  scopePopular(query) {
	return query.where('votes', '&gt;', 100);
  }

  // 自定义模型关联
  // user.posts
  relationPosts() {
	return this.hasMany(Post);
  }
}
</code></pre></li>
</ol>







标题：开源一个连续拿了 3 个 Web3 黑客松奖（奖金总计超过 10wRMB）的项目 Discord NFT 挖掘机器人
作者：lyman
发布日期：发布于 5 个月前
文章内容：<p>这个项目是去年业余时间开发的，累计开发时间应该不超过 8*5 小时，偶然间看到 Web3 的黑客松比赛便投稿了，3 个比赛均在 NFT 领域获得奖项。</p>
<p>项目并不是非常复杂的算法或者合约逻辑，只是把 Web2 的 Discord 和 当时火热的 NFT mint 结合在一起。</p>
<p>在我们的 深入浅出NFT 系列文章中，我们将创建一系列应用来让你的 NFT 的程序逻辑对你的现实生活中的商业活动产生影响。</p>
<p>NFT 对于 PFP 项目来说就是图片，当然还附带了项目方官网列下来的一系列愿景了。然后也可以是游戏（Axie, StepN)。最终其可以是任何事物，因为其最终可以代表任何事物的拥有权！</p>
<p>Discord 已经是 NFT 项目方常使用的社区工具了。因为其有强大的功能来支撑其聚合用户并创建一个靠谱的社区。</p>
<p>显然 NFT 就是 Web3 的核心。如果我们能使用 Discord 平台来集成 NFT 那么会对我们的 Web3 创意很有帮助。</p>
<p>这篇文章则是简单介绍如何 使用 Discord.js, NFT.Storage 及 Node.JS 为你的公会创建一个 Discord NFT 制造机器人。</p>
<p>当然市面上已经有很多和 NFT 有关的机器人的（例如 Collab.land，但是我们不用他们的原因是我们自己写的代码的自由度更大，使用别人的服务总是会受到各种限制，除非他本身提供了非常灵活的定制逻辑（这个可能在我们未来的 SaaS 版本的 Discord NFT 挖掘机器人中实现）。</p>
<p>对于我们的 Discord NFT 挖掘机器人，我们可以将其应用到你现实生活中的商业中，比如咖啡馆、鞋店、服装店、课程培训、某种俱乐部等。</p>
<p>图片</p>
<p>在这篇文章中，我们将构建一个你的公会成员通过输入 ~mint 及一些参数的命令即可获得（mint) NFT的 Discord 机器人。这个创意是我去年写的并获得了 3 个 web3 的黑客松比赛的奖。其功能如下：</p>
<p>• 机器人拥有者可以指定 NFT 合约地址、NFT 的链</p>
<p>• 机器人拥有者可以重新部署命令、检测状态</p>
<p>• 公会成员可以设置其自己的 NFT.Storage 的 api key 来通过 NFT.Storage 服务 在 discord 的聊天框内上传内容到 IPFS</p>
<p>• 公会成员可以通过在聊天框内输入 ~mint 命令来挖到公会的 NFT</p>
<p>此文章是一篇 太长；不想看 风格的，我们只列出了必要的步骤，没有做过多的解释，细节解释会在我们 Web3课程 中详细介绍。</p>
<p>在 discord 开发者中心创建应用及机器人
• 你应该在 discord 中有创建了公会了或者可以马上新建一个，是免费的</p>
<p>• 访问 <a href="https://discord.com/developers/applications/me">https://discord.com/developers/applications/me</a></p>
<p>• 点击 Bot, Add Bot 然后最终点击 Yes, do it</p>
<p>• 访问https://discord.com/oauth2/authorize?client_id=APP_ID&amp;scope=bot[1] , 替换掉 APP_ID 为你从应用页面复制的 Application ID，这样便可把机器人加到你的服务器中（或者让服务器管理员帮你加）。如果你需要斜杠命令，添加 %20applications.commands 到上面的网址的末尾即可</p>
<p>• 复制机器人 token 并临时保存的某处之后我们会用到</p>
<p>设置代码
• git clone <a href="mailto:git@github.com">git@github.com</a>:DiscordNFTMinterSaaS/DiscordNFTMinterSingle.git</p>
<p>• npm i</p>
<p>• 复制 config.js.example 并命名为 config.js</p>
<p>• 复制 .env-example 并命名为 .env, 所有在文件中的字段都是必填的</p>
<p>• node index.js 来启动机器人</p>
<p>部署到 Heroku[2]
Heroku 提供了一个让你连接 GitHub 代码库到你的 Heroku 应用的解决方案并且其会在你推送更新到 GitHub 时自动部署。以下是我们怎么做到的过程：</p>
<p>• 导航到你的 Heroku 应用页面</p>
<p>• 在 deploy 环节，选择第二个选项 GitHub</p>
<p>• 你将会看到一个输入框，搜索你的仓库名并点击链接</p>
<p>• 一旦仓库连接上，你可以选择 enable automatic deploys</p>
<p>• 一旦你推送代码到 GitHub，Heroku 将自动部署代码（依据 Procfile 文件内的配置）</p>
<p>以上则是 Discord NFT 挖掘机器人 开源项目的简单使用介绍说明，下面是基于该项目做一个 SaaS 版本平台的一个创业项目征集。</p>
<p>精益创业：召集 1000 人赞助 Discord NFT 挖掘机器人 发展成一个链接 1000 个商业项目和 NFT 的 SaaS 平台
一个产品如果仅仅是团队自嗨型的疯狂开发无数功能而至于用户买单与否都不确定的，那么该产品团队终究有解散的一天。</p>
<p>因为每次新增功能都是在耗费有限的团队资源，在耗费了很大资源情况下推出的产品压根没有用户愿意买单那么团队就是得失败的。</p>
<p>Web3HackerDAO 的所有产品和想法都会以这样的模式推进，在项目的开始阶段就开始召集付费的种子用户，用户早期付费在最终项目上线获得利润后再回馈种子用户。</p>
<p>同时种子用户也必须是真实觉得这个产品对他是有用的，在产品演化过程中也会提出各种想法和建议的（开发团队不一定会接受建议并开发对应功能）。</p>
<p>开发的过程中，不断获得更多付费用户及用户反馈，那么才能更好地确保产品是符合市场的预期的。</p>
<p>对于已经开源的单机版的 Discord NFT 挖掘机器人，所有人可以自由拿去自由开发，因为是基于 MIT 协议开源的。而 Web3HackerDAO 则会在此基础上，改造成 SaaS 版本的 Discord NFT 挖掘机器人，这样没有编程经验或者无开发团队的项目方可以通过简单的按钮点击即可使用到自己想要的 Discord NFT 挖掘机器人 机器人。</p>
<p>SaaS 版本会先列出一系列将开发的功能，会根据付费的种子用户的投票来决定开发方向及进度。以下是一些目前列的可能会开发的功能，这些功能都是在 Web 页面上操作即可无需接触代码， 当前功能主要围绕 NFT 项目的裂变增长及和项目方提供的对于其用户有用的产品的角度思考的：</p>
<p>• 管理员可以在 web 管理端界面上设置指定的 NFT 合约及链</p>
<p>• 公会成员在邀请的用户达到 X 数量后自动 mint NFT 给该用户（ X 是管理员可以后台设定的）</p>
<p>• 公会成员可以找管理员凭 NFT 来兑换实际的商品（可能是实物或者虚拟商品），管理员在 discord 内即可设定标记该成员的 NFT 已经兑换过产品</p>
<p>• 公会成员可以在 discord 内根据不同的角色等级来获得不同的 mint NFT 的价格（即 NFT 项目常见的不同类型等级的白名单逻辑）</p>
<p>• 未来的更多的功能，主要都围绕让 NFT 的项目方可以在 discord 内给其用户带来实际的产品体验价值兑换使用功能以及项目本身的增长裂变相关功能</p>
<p>成为 Discord NFT 挖掘机器人 SaaS 平台种子用户方式</p>
<ol>
<li>
<p>赞赏 ￥300（备注：Discord NFT 挖掘机器人） 并转发本文章到朋友圈(前 1000 名报名者以赞赏时间为准)</p>
</li>
<li>
<p>添加 vx: Web3Hacker 并备注 Discord NFT 挖掘机器人</p>
</li>
<li>
<p>注意，报名成为 Discord NFT 挖掘机器人 SaaS 平台付费种子用户并不是成为 Builder 协议：NFT 真相揭秘及其无限可能 课程的学员，两个是不同的项目</p>
</li>
</ol>
<p>Web3HackerDAO 课程： Builder Protocol: Reveal the NFT truth and infinity possibilities
我们在 一个解决方案来让你的 NFT 拥有无限可能 文中推出了 召集 100 人一起深入浅出的理解什么是真正的 NFT 的课程，目的是为了面向所有对 Web3 及 NFT 感兴趣的同学一起分享交流。</p>
<p>此前课程是以赞赏 ￥200 即可报名，现在将调整为 ￥300（由于微信每次赞赏最多只能 ￥256，故需要分两次赞赏，总和达到￥300 即可）</p>
<p>并加入了邀请返现机制：</p>
<p>• 已报名同学邀请：每邀请一名新同学加入课程可获得 ￥50 现金奖励，同时新同学在报名成功后会获得 ￥50 元优惠（所有奖励及优惠在总报名人数达到 100 人开课时发放）</p>
<p>• 未报名同学邀请：每邀请一名新同学加入课程可获得 ￥50 现金奖励，同时新同学在报名成功后会获得 ￥25 元优惠（所有奖励及优惠在总报名人数达到 100 人开课时发放）</p>
<p>• 所有未付费报名的邀请者需先转发本文章到朋友圈及 Twitter 并截图给 Web3Hacker 微信备注 成为邀请者 才可生效邀请者身份</p>
<p>• 所有奖励发放将在课程总共达到 100 人开课时统一通过微信转账发放</p>
<p>• 所以大家尽量看下赞赏头像中有认识的人找认识的人报名课程吧！</p>
<p>下面再详细列下课程内容及本次新增的课程内容。</p>
<p>课程内容</p>
<p>• 课程名字将定为：Builder 协议：NFT 真相揭秘及其无限可能 (Builder Protocol: Reveal the NFT truth and infinity possibilities）</p>
<p>• 面向所有人深入浅出介绍 NFT（技术/非技术人员兼容）</p>
<p>• NFT 代码层面的介绍</p>
<p>• NFT 市面上的一些功能（抽奖模式、分成模式、带数量限制的默克尔树白名单等），并实际教学发布一个 NFT 到测试网</p>
<p>• 获得 Web3HackerDAO 的翻译文章内容(不会完整翻译，仅翻译主要比较有用的部分)</p>
<p>• <a href="https://info.diamonds">https://info.diamonds</a></p>
<p>• EIP-2535[3] (TBD)</p>
<p>• EIP-5791[4] (TBD)</p>
<p>• 没有会议、最后期限以及全职雇员 <a href="https://sahillavingia.com/work">https://sahillavingia.com/work</a></p>
<p>• 从泡沫到泡沫 <a href="https://sahillavingia.com/bubble">https://sahillavingia.com/bubble</a></p>
<p>• 回顾构建一个百亿美金公司的失败经历 <a href="https://sahillavingia.com/reflecting">https://sahillavingia.com/reflecting</a></p>
<p>• 及其他未来可能增加的资料</p>
<p>• 本次新增课程内容</p>
<p>• 线上教学实操部署 Discord NFT 挖掘机器人，可能需要一些电脑的前期设置及账号注册，届时会提前告知同学提前准备</p>
<p>额外福利，将从前 100 名付费者中随机 10 名会员获得</p>
<p>• 获得 Web3HackerDAO 的 R1 会员 NFT 空投（将在合约正式部署后分发）</p>
<p>• R1 会员 NFT 正式售卖价格将在 1000 RMB 以上</p>
<p>• R1 会员权益如下：</p>
<p>• Web3HackerDAO 线上茶话会参与资格</p>
<p>• Web3HackerDAO 孵化的项目的早期种子轮的优先 invest 资格</p>
<p>• 其他权益待定，陆续增加</p>
<p>报名方式</p>
<ol>
<li>
<p>赞赏 ￥300（备注：Web3 NFT 课程）， 并转发文章到朋友圈(前 100 名报名者以赞赏时间为准, 需要分两次赞赏，因为微信一次赞赏最多 ￥256)</p>
</li>
<li>
<p>添加 vx: Web3Hacker 并备注 Web3 NFT 课程，如果有推荐人记得加完微信敬请告知以便 Bruce 做记录</p>
</li>
<li>
<p>注意 一个解决方案来让你的 NFT 拥有无限可能 文中的 ￥200 的付费在本篇文章发布时正式失效，新报名同学需要按此文的费用计算付费</p>
</li>
</ol>
<p>-------全文完</p>
<p>我是 Web3 赏金猎人 Bruce，5 月份辞职开始 All in Web3, 几个月下来连续 Buidl 了 5+个围绕 NFT 的 PoC 并拿到了 10+ 个 Web3 黑客松赛道奖，接下来将专注于打造给世界带来减熵的 Web3 DApp 工厂 Web3HackerDAO。</p>
<p>• 个人微信：Web3Hacker</p>
<p>• 个人 Twitter: <a href="/user/Web3HackerNinja">@Web3HackerNinja</a></p>
<p>• 公众号：Web3HackerDAO</p>
<p>引用链接
[1] <a href="https://discord.com/oauth2/authorize?client_id=APP_ID&amp;scope=bot:">https://discord.com/oauth2/authorize?client_id=APP_ID&amp;scope=bot:</a> <a href="https://discord.com/oauth2/authorize?client_id=APP_ID&amp;scope=bot">https://discord.com/oauth2/authorize?client_id=APP_ID&amp;scope=bot</a>
[2] 部署到 Heroku: <a href="https://devcenter.heroku.com/articles/deploying-nodejs">https://devcenter.heroku.com/articles/deploying-nodejs</a>
[3] EIP-2535: <a href="https://eips.ethereum.org/EIPS/eip-2535">https://eips.ethereum.org/EIPS/eip-2535</a>
[4] EIP-5791: <a href="https://eips.ethereum.org/EIPS/eip-5791">https://eips.ethereum.org/EIPS/eip-5791</a></p>







标题：开发累了就摸个鱼🐟，帮我修改一下中式英语
作者：zhennann
发布日期：发布于 5 个月前
文章内容：<p>上学时喜欢帮同桌找错，一个英文句子如果能找到5处错误，心里就美滋滋的。如今轮到自己写技术文档，面对满篇的中式英语却有心无力。好心的网友，如果开发累了，就摸个鱼🐟，帮我找找错吧，也找回学生时代的感觉</p>
<ul>
<li>原文链接：<a href="https://cabloy.com/articles/how-to-read.html">How to Study CabloyJS</a></li>
</ul>
<p>============ 正文分隔线 ============</p>
<hr>
<h1><strong>How to Study CabloyJS?</strong></h1>
<h2><strong>Document Audiences</strong></h2>
<p>Software development is like building houses and bridges, which can be the towering palaces in the north, the elegant courtyards in the south, and even the precipitous and isolated bridges beyond mountains. Then, different languages and frameworks attract a group of fans by their inherent qualities. They work tirelessly to create different ecosystems and present different development styles and experiences. Just as <code>Rails to Ruby</code>, <code>Lavaral to PHP</code>, <code>Django to Python</code>, and <code>Spring Boot to Java</code>. So, what will be to Javascript? There is no doubt that Javascript faces more usage scenarios, such as front-end, back-end, mobile, IOT, etc. Different scenarios have excellent solutions. Moreover, based on different usage habits, the javascript ecosystem is split into two style systems, which are <code>Javascript</code> and <code>Typescript</code>. So, based on business development, in terms of the current node ecology, we can say that <code>Nest to Typescript</code>, and <code>Cabloy to Javascript</code></p>
<p>Because different languages and frameworks will have different solutions and styles. Therefore, whether you use <code>CabloyJS</code> or not, it is necessary to come in and see what kind of flowers can grow on the soil of sticking to the pure javascript (Vanilla JS). Therefore, whether you are a fan of front-end development, back-end development, full stack development, or other languages, or a technical manager, product manager, or project manager, you can learn different ideas and methods for solving problems from the documents and videos provided by CabloyJS, communicate with each other, learn from each other, and make progress together!</p>
<table>
<thead>
<tr>
<th><strong>Language</strong></th>
<th><strong>Framework</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ruby</td>
<td>Rails</td>
</tr>
<tr>
<td>PHP</td>
<td>Lavaral</td>
</tr>
<tr>
<td>Python</td>
<td>Django</td>
</tr>
<tr>
<td>Java</td>
<td>Spring Boot</td>
</tr>
<tr>
<td>Typescript</td>
<td>Nest</td>
</tr>
<tr>
<td>Javascript</td>
<td>Cabloy</td>
</tr>
</tbody>
</table>
<h2><strong>What is CabloyJS</strong></h2>
<p>CabloyJS is a NodeJS full-stack framework with workflow engine, a low-code development platform for developers, is also a PAAS platform with both out-of-the-box and flexible-customization. Only one set of codes is needed to realize the admin management system at backend and the applications at frontend at the same time. Only one set of codes is needed to adapt to PC and mobile at the same time, and the mobile is close to the native experience</p>
<h2>Framework styles and design principles of CabloyJS</h2>
<h3>1. Framework styles: <code>brief-but-not-simple</code></h3>
<h3>2. Design principles: <code>out-of-the-box</code> + <code>flexible-customization</code></h3>
<p>Many friends feedback that they are unfamiliar with the concepts of CabloyJS, so they don’t know where to start?</p>
<p>Different languages and architecture concepts determine the style of a framework. In order to create a truly easy-to-use full stack business framework, CabloyJS abstracts and refines the concepts behind the real business requirements, which not only achieves the effect of out-of-the-box, but also can be customized flexibly</p>
<p>Therefore, this also determines that the overall style of CabloyJS framework is: <code>brief-but-not-simple</code>. When you are familiar with this style, you will find that the really comfortable development experience should be like this</p>
<h3>1. Take a case at backend</h3>
<p>If you want to implement the <code>CRUD</code> features, the codes can be designed very simply, and you can even know how to use it without referencing the documents</p>
<blockquote>
<p>We can recall that most of the other backend MVC frameworks or backend API frameworks provide the <code>CRUD</code> features, while often stop there steps here?</p>
</blockquote>
<p>Then, let’s introduce some real business requirements:</p>
<ol>
<li>
<p>Add a <code>draft</code> copy of the data. When we modify the <code>draft</code>, the original data that has been formally submitted will not be affected</p>
</li>
<li>
<p>Add some <code>history</code> copies of the data, so as to record the historical version of the data</p>
</li>
<li>
<p>Add a <code>approval workflow</code>. Business data will be approved after the draft is submitted, and will be transferred to the <code>formal</code> copy only after it is approved</p>
</li>
<li>
<p>Add <code>cms static rendering mechanism</code>: as CRUD are generally managed in the backend, we need to output the data statically for the frontend system to access, and realize the SEO optimization of the website</p>
</li>
<li>
<p>Add <code>category</code> and <code>tag</code> features to facilitate further classification of data</p>
</li>
<li>
<p>For these characteristics mentioned above:</p>
<ol>
<li>
<p>How to refine general concepts</p>
</li>
<li>
<p>How to design the development interface (to achieve the effect of <code>out-of-the-box</code> and <code>flexible-customization</code>)</p>
</li>
<li>
<p>How to configure flexibly (enable or disable some features conveniently). As the saying goes: it is easy to reduce dimensions, but difficult to increase dimensions. We need to have these features first, and then decide whether to enable them according to business requirements</p>
</li>
<li>
<p>How to adapt more business scenarios (rather than only applicable to a certain type of business data), such as blog posts, community posts, leave forms, reimbursement forms, purchase orders, contracts, projects, assets, financial documents, etc.</p>
</li>
</ol>
</li>
<li>
<p>It is doomed that the concept of business data is not simple, but CabloyJS has implemented a brief development interface, which can be used <code>out-of-the-box</code> and <code>flexible-customization</code></p>
</li>
</ol>
<blockquote>
<p>See Also：Bilibili Video：<a href="https://www.bilibili.com/video/BV1yL4y1w7dc/">新建业务表单+审批工作流</a> (Translation Wanted)</p>
</blockquote>
<h3>2. Take a case at frontend</h3>
<ol>
<li>
<p><code>Question</code>: With the popularization and upgrading of mobile devices, a large number of business scenarios need mobile support. Then, how can the admin management system support the mobile devices more elegantly?</p>
</li>
<li>
<p><code>Traditional solution</code>: At present, most of the admin management frameworks on the market are compatible with PC and Mobile by using <code>CSS media query</code></p>
<ol>
<li><code>Disadvantages of the traditional solution</code>: However, the UI interaction experiences of PC and Mobile are different, and the page layouts are different either. Therefore, only relying on <code>CSS media query</code> can only make PC pages available on the Mobile, but it is far from achieving the effect of the native Mobile</li>
</ol>
</li>
<li>
<p><code>New solution</code>: CabloyJS provides a unique  adaptive layout of <code>pc=mobile+pad</code>, so that only one set of codes is needed to adapt to PC and mobile at the same time, and the mobile is close to the native interactive experience</p>
<ol>
<li><code>Advantages of the new solution</code>: This solution also implements the design principle of <code>out-of-the-box</code> + <code>flexible-customization</code>, with the style of <code>brief-but-not-simple</code>. All you need to do is to understand this mechanism by referencing documents or watching videos. The codes required for actual frontend page development will be much less than <code>CSS media query</code></li>
</ol>
</li>
</ol>
<blockquote>
<p>See Also：Bilibili Video: <a href="https://www.bilibili.com/video/BV1St4y1j7kv/">独树一帜的跨端方案：pc=mobile+pad自适应布局</a> (Translation Wanted)</p>
</blockquote>
<h2>Basic Concepts</h2>
<p>It is recommended that you read the following documents to have a preliminary understanding of the basic concepts of CabloyJS</p>
<ul>
<li>
<p><a href="https://cabloy.com/articles/guide-quick-start.html">Quick Start</a></p>
</li>
<li>
<p><a href="https://cabloy.com/articles/module-create.html">Modularization And Create Module</a></p>
</li>
<li>
<p><a href="https://cabloy.com/articles/module-compile.html">Module Compilation and Publish</a></p>
</li>
</ul>
<h2>Basic knowledges</h2>
<p>CabloyJS is based on EggJS, VueJS and Framework7. These underlying framework documents do not have to be read first. CabloyJS provides enough samples and test codes to facilitate rapid development. It is recommended to run CabloyJS project first, and then gradually introduce relevant knowledge as needed</p>
<p>Of course, if you have the knowledges of EggJS and Framework7 in advance, it is easier to understand what innovations and transformations CabloyJS has made on the basis of these two</p>
<ul>
<li>Frontend
<ul>
<li><a href="https://v2.vuejs.org/v2/guide/">Vue2</a></li>
<li><a href="https://v5.framework7.io/">Framework7</a></li>
</ul>
</li>
<li>Backend
<ul>
<li><a href="https://eggjs.org">EggJS</a></li>
</ul>
</li>
</ul>
<h2>Learn through practice</h2>
<p>CabloyJS has many built-in core modules, which encapsulates and implements most of the functions and features commonly used in specific businesses. Therefore, it is recommended that you first create a project, run it, and preview the functions and features provided by CabloyJS. In this way, when you develop your own system, you will know how to refer to the existing paradigm to get twice the result with half the effort</p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/guide-quick-start.html">Quick Start</a></li>
</ul>
<h2>Free Video Courses</h2>
<p>CabloyJS offers some free video courses. This set of courses is taught by the author of CabloyJS, zhennann. Through on-site coding and actual combat, it takes you into the real scene of NodeJS full stack development, so that you can quickly improve development skills and quickly start the development of various business systems after learning</p>
<ul>
<li>
<p>See Also: <a href="https://course.cabloy.com/zh-cn/articles/A-001.html">A-001: CabloyJS全栈框架：从入门到精通</a> (Translation Wanted)</p>
</li>
<li>
<p>See Also: <a href="https://course.cabloy.com/zh-cn/articles/A-002.html">A-002: CabloyJS全栈框架：功能特性演示</a> (Translation Wanted)</p>
</li>
<li>
<p>See Also: <a href="https://course.cabloy.com/zh-cn/articles/B-001.html">B-001: 微信一起点菜项目进度复盘</a> (Translation Wanted)</p>
</li>
</ul>
<h2>Tutorials</h2>
<p>On the basis of <code>CabloyJS</code> framework, it is very fast and convenient to redevelop specific business modules. From the following <code>tutorials</code> section, you can see what steps are needed to develop a <code>business module</code></p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/tutorial-introduce.html">Tutorials</a></li>
</ul>
<h2>EggBornJS</h2>
<p>By reading the <code>EggBornJS</code> section, you can understand what features <code>EggBornJS</code> has extended on the basis of <code>EggJS</code> in order to achieve <code>business modularity</code></p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/eggborn-introduce.html">What is EggBornJS</a></li>
</ul>
<h2>CabloyJS</h2>
<p>By reading the <code>CabloyJS</code> section, you can understand what core modules <code>CabloyJS</code> provides to improve the efficiency and convenience of business development</p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/cabloy-introduce.html">What is CabloyJS</a></li>
</ul>
<h2>NodeJS Workflow Engine</h2>
<p><code>NodeJS workflow engine</code> is the core component of a business development platform. By reading this chapter, you can understand how CabloyJS’s own workflow engine supports the development of business systems in a simple, flexible and efficient way</p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/flow-introduce.html">What is NodeJS Workflow Engine</a></li>
</ul>
<h2>Solutions</h2>
<p>Based on CabloyJS, corresponding solutions are implemented for different business scenarios, including:</p>
<ol>
<li>
<p><a href="https://cabloy.com/articles/cms-introduce.html">Cabloy-CMS</a></p>
</li>
<li>
<p><a href="https://cabloy.com/articles/community-introduce.html">Cabloy-Community</a></p>
</li>
<li>
<p><a href="https://cabloy.com/zh-cn/articles/wechat-introduce.html">Cabloy-Wechat</a> (Translation Wanted)</p>
</li>
<li>
<p><a href="https://cabloy.com/zh-cn/articles/wxwork-introduce.html">Cabloy-Wechat Work</a> (Translation Wanted)</p>
</li>
<li>
<p><a href="https://cabloy.com/zh-cn/articles/dingtalk-introduce.html">Cabloy-Dingtalk</a> (Translation Wanted)</p>
</li>
<li>
<p><a href="https://cabloy.com/zh-cn/articles/uniapp-introduce.html">Cabloy-Uniapp</a> (Translation Wanted)</p>
</li>
</ol>
<h2>Test Modules/Suites</h2>
<ul>
<li>
<p><code>test-party</code> : is the test suite of CabloyJS, including a large number of <code>test cases</code> and <code>Kitchen-sink</code></p>
<ul>
<li>See Also: <a href="https://store.cabloy.com/articles/test-party.html">test-party</a></li>
</ul>
</li>
<li>
<p><code>test-flow</code>: is the test module of NodeJS workflow engine, containing a large number of workflow related test cases</p>
<ul>
<li>See Also: <a href="https://store.cabloy.com/articles/test-flow.html">test-flow</a></li>
</ul>
</li>
<li>
<p><code>test-note</code>: is used to demonstrate how to use the Markdown rich text editor</p>
<ul>
<li>See Also: <a href="https://store.cabloy.com/articles/test-note.html">test-note</a></li>
</ul>
</li>
</ul>
<p>These test <code>modules/suites</code> not only facilitate the quick learning of knowledge points in all aspects of CabloyJS, but also provide a large number of code examples to facilitate the rapid start of actual project development. It is strongly recommended that you pay attention to and keep these test <code>modules/suites</code> updated, so as to always obtain the latest sample codes in time</p>
<ul>
<li>
<p>How to install test modules/suites, see also: <a href="https://cabloy.com/articles/cli-store.html">Cabloy Store Cli</a></p>
</li>
<li>
<p>How to disable test modules/suites, see also: <a href="https://cabloy.com/articles/disabled-modules.html">Disable Module/Suite</a></p>
</li>
<li>
<p>How to update test modules/suites, see also: <a href="https://cabloy.com/articles/update-cabloy.html">Update Cabloy</a></p>
</li>
</ul>
<h2>Core Modules</h2>
<p>By reading the source codes of the core modules provided by <code>CabloyJS</code>, you will find that the <code>CabloyJS</code> framework is flexible enough to allow you to deeply customize, replace, and extend the numerous functions and features provided by <code>CabloyJS</code></p>
<ul>
<li>See Also: <a href="https://cabloy.com/articles/modules-list.html">Core Modules</a></li>
</ul>
<h2>Contributions</h2>
<p>Welcome to participate in and contribute to the improvement of the CabloyJS full stack framework, which is also an effective way to quickly and deeply learn CabloyJS</p>







标题：一文讲透CabloyJS全栈框架的来龙去脉
作者：zhennann
发布日期：发布于 5 个月前
文章内容：<h2><strong>本文受众</strong></h2>
<p>咱们做软件开发，就好比是建造一幢幢房屋，一座座桥梁，既可以是北方宫殿的巍峨，也可以有南方庭院的雅致，更可以是横跨群山的峻险与孤悬。那么，不同的语言、不同的框架也都由其内在的秉质吸引着一批粉丝，坚持不懈的耕耘，营造出不同的生态，呈现出不同的开发风格和开发体验。正如<code>Rails之于Ruby</code>，<code>Lavaral之于PHP</code>，<code>Django之于Python</code>，<code>Spring Boot之于Java</code>。那么，又是什么之于Javascript呢？毋庸置疑，Javascript面对着更多的使用场景，前端、后端、移动端、IOT，等等。不同的场景都有出色的解决方案存在。而且，基于不同的使用偏好，又分裂出Javascript和Typescript两个风格体系。那么，基于业务开发而言，就目前的Node生态可以说，<code>Nest之于Typescript</code>，<code>Cabloy之于Javascript</code></p>
<p>正因为面对业务开发，不同的语言、不同的框架，会有不同的解决方案和风格体验。因此，不论您使用CabloyJS或者不使用CabloyJS，都有必要进来看看在坚守<code>原生Javascript</code>（Vanilla JS）的土壤上，可以开出怎样的花朵。因此，不论您是<code>前端开发</code>、<code>后端开发</code>、<code>全栈开发</code>，或者<code>其他语言的粉丝</code>，或者<code>技术经理</code>、<code>产品经理</code>、<code>项目经理</code>，都可以从CabloyJS提供的文档和视频中汲取不一样的解题思路和方法，相互交流，相互借鉴，共同进步！</p>
<blockquote>
<p>在英语语境中，原生Javascript有一个专属名称：Vanilla JS。而Vanilla有香草🌿之意，看来所言不虚</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>语言</strong></th>
<th><strong>框架</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Ruby</td>
<td>Rails</td>
</tr>
<tr>
<td>PHP</td>
<td>Lavaral</td>
</tr>
<tr>
<td>Python</td>
<td>Django</td>
</tr>
<tr>
<td>Java</td>
<td>Spring Boot</td>
</tr>
<tr>
<td>Typescript</td>
<td>Nest</td>
</tr>
<tr>
<td>Javascript</td>
<td>Cabloy</td>
</tr>
</tbody>
</table>
<h2>CabloyJS是什么</h2>
<p>CabloyJS 是一款自带<code>工作流引擎</code>的 Node.js 全栈框架，一款<code>面向开发者</code>的低代码开发平台，更是一款兼具低代码的<code>开箱即用</code>和专业代码的<code>灵活定制</code>的 PAAS 平台。只需一套代码，即可同时实现<code>中后台管理系统</code>和<code>前台应用</code>。只需一套代码，即可同时跨端<code>pc</code>和<code>mobile</code>，并且<code>mobile端</code>是接近原生体验</p>
<p>CabloyJS 内置的每一项特性都做到精心调校，均体现了从<code>开箱即用</code>到<code>灵活定制</code>的无缝衔接，包括：角色系统、用户认证、菜单权限、数据权限、表单渲染、表单验证、工作流引擎、字典、仪表板、在线推送、页面主题、多语言国际化、CMS 渲染引擎、微信接口、企业微信接口、钉钉接口，等等</p>
<h2><strong>技术栈</strong></h2>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>技术栈</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>前端</td>
<td>vue2 + framework7</td>
</tr>
<tr>
<td>后端</td>
<td>koa2 + egg2</td>
</tr>
<tr>
<td>数据库</td>
<td>mysql</td>
</tr>
<tr>
<td>分布式（缓存/队列/消息）</td>
<td>redis、bullmq、websocket</td>
</tr>
<tr>
<td>Markdown 富文本编辑</td>
<td>Prosemirror</td>
</tr>
</tbody>
</table>
<h2>在线演示</h2>
<p>CabloyJS提供了大量在线演示：</p>
<ol>
<li>
<p>演示如何在一套代码中同时开发<code>B端中后台管理系统</code>和<code>C端前台应用</code></p>
</li>
<li>
<p>演示如何在一套代码中同时跨端<code>pc</code>和<code>mobile</code>，并且<code>mobile端</code>是接近原生体验</p>
</li>
</ol>
<p>因此，强烈建议您移步查看：<a href="https://cabloy.com/zh-cn/articles/demo-online.html">在线演示</a></p>
<h2>引言</h2>
<blockquote>
<p>凡是可以用 JavaScript 来写的应用，最终都会用 JavaScript 来写 | Atwood 定律</p>
</blockquote>
<p>目前市面上出现的大多数与 NodeJS 相关的框架，基本都将 NodeJS 定位在<code>工具层</code>、<code>聚合层</code>、<code>中间层</code>、<code>代理层</code>，很少在业务层面进行深耕，认为这是 JAVA 的领域，NodeJS 不适合。这种思潮明显是与<code>Atwood 定律</code>相悖的</p>
<p>如果您想感受不同的 NodeJS 全栈开发体验，一定要试试自带工作流引擎的 CabloyJS 全栈开源框架。为了提升业务层面的开发效率和开发体验，CabloyJS 在前端和后端均提供了大量实用的工具和组件</p>
<h2><strong>CabloyJS 解决了哪些现实痛点问题？</strong></h2>
<p>在 NodeJS 开发领域，目前(截止 2022 年 11 月)存在以下几个痛点问题：</p>
<h3><strong>1. 中后台管理系统如何更优雅的支持移动端？</strong></h3>
<p>随着移动终端的普及和升级换代，大量业务场景都需要移动端的支持，比如管理层需要通过手机查看统计数据、审核业务单据；运维人员通过手机远程查看服务器状态，并进行调整优化</p>
<p>我们知道，市面上大多数中后台管理系统，都是优先适配 PC 端，然而移动端体验却不佳，处于<code>勉强可用，但不好用</code>的阶段</p>
<p>此外，大多数<code>XXX Admin框架</code>和<code>中后台管理框架</code>其本质是<code>代码模版</code>。在具体开发项目时，直接在<code>代码模版</code>中编写代码。这样，虽然修改起来很直接，但是不利于模版的持续升级和优化；也不利于业务代码的持续沉淀和迁移（至其他项目）。因此，当把<code>代码模版</code>从源码仓库下载下来之后，<code>修改三分之一</code>，<code>增加三分之一</code>，<code>删减三分之一</code>，从此就与<code>代码模版</code>的后续升级版本绝缘了</p>
<h3><strong>2. NodeJS 领域没有好用的工作流引擎！</strong></h3>
<p>如果单说 CRUD，大多数编程语言的开发框架都可以轻松实现，这不应该成为 NodeJS 开发业务系统的核心优势。若要让 NodeJS 深入业务领域的开发，<code>工作流引擎</code>是一个绕不过去的核心组件</p>
<h3><strong>3. 拖拽式低代码平台已经成为鸡肋方案！</strong></h3>
<p>大多数业务表单不仅仅是一些字段的简单组合和增删改查，不同的业务都有自己独特的业务诉求，往往需要前端界面的定制和后端逻辑的定制。拖拽式低代码平台，对于业务人员而言没有足够的工具进行深入定制，对于研发人员而言也没有足够的机制深入开发</p>
<p>许多拖拽式低代码平台认识到了这一点，所以针对不同的业务场景提供官方预配置的套装解决方案，这同样也把业务人员和研发人员置于<code>不上不下</code>的尴尬境地，成为<code>食之无味 弃之可惜</code>的鸡肋平台</p>
<h2><strong>CabloyJS 亮点介绍</strong></h2>
<p>基于上述分析的问题，CabloyJS 实现了如下<code>功能三大亮点</code>和<code>架构三大亮点</code></p>
<h3><strong>1. 功能三大亮点</strong></h3>
<p>1）<strong>自适应布局：pc = mobile + pad</strong></p>
<p>CabloyJS 首创独树一帜的<code>pc = mobile + pad</code>跨端自适应布局机制：只需要一套代码，就可以同时兼容<code>mobile端</code>和<code>pc端</code>。<code>mobile端</code>达到原生效果，同时将<code>mobile端</code>的操控体验和开发模式无缝带入<code>pc端</code></p>
<p>请大家分别在 PC 端和手机端打开<code>演示链接</code>: <a href="https://test.cabloy.com/">https://test.cabloy.com/</a> ，来体会与众不同的自适应机制</p>
<p>2）<strong>基于 JSON Schema 的表单自动渲染与数据验证引擎</strong></p>
<p>通过在一处定义<code>JSON Schema</code>，就可以同时支持前端的<code>表单自动渲染</code>和后端的<code>数据验证</code>，既能开箱即用又可灵活定制</p>
<p>3）<strong>内置 NodeJS 工作流引擎</strong></p>
<p>CabloyJS 充分利用 JS 语言的灵活性和 JSON 格式的便捷性，提供的 <code>NodeJS工作流引擎</code>远比 JAVA 领域的<code>Activiti</code> 简洁易用</p>
<p>比如，我们一般只知道如何使用<code>Activiti</code>中提供的<code>活动节点</code>和<code>边界事件</code>，却很少有途径来了解如何开发<code>自定义的活动节点</code>和<code>自定义的边界事件</code>。由于<code>Activiti</code>的架构繁杂，大多数人甚至不愿意尝试去阅读源码。但是 CabloyJS 提供的<code>工作流引擎</code>却可以轻松的定制所有的工作流元素，而且源码层次清晰，易于学习</p>
<h3><strong>2. 架构三大亮点</strong></h3>
<p>作为一款面向开发者的低代码开发平台，为了将低代码的<code>开箱即用</code>和专业代码的<code>灵活定制</code>有机融合，CabloyJS 在架构层面主要做了以下几点：</p>
<p>1）<strong>模块化开发体系与模块隔离</strong></p>
<p>为了满足大型业务系统开发的诉求，CabloyJS 采用<code>模块思维</code>规划系统架构，以业务功能为单位（比如出差申请），将与业务功能相关的前端组件与后端逻辑组织为一个<code>业务模块</code>，从而有利于业务功能的内聚与重用，也有利于以业务为单位进行团队分工</p>
<p>此外，业务模块内部的页面、数据、逻辑、路由、配置等元素均进行了命名空间隔离处理，从而避免模块之间的变量污染与冲突。换句话说，当我们在自己的业务模块中为某个资源命名时，不用担心其他业务模块是否存在相同名称的资源，从而减少心智负担</p>
<p>2）<strong>原生分布式架构</strong></p>
<p>EggJS 的定位是框架的框架，CabloyJS 后端在 EggJS 的基础上采用<code>自定义Loader</code>机制扩展出来了一套适配业务场景的新特性</p>
<p>比如，EggJS 原有的<code>Worker + Agent</code>进程模型，对于单机而言非常便利。但是面对多机集群，特别是基于<code>docker</code>的集群部署而言，<code>Agent进程</code>就失去了用武之地。更重要的是，如果一开始基于<code>Agent进程</code>进行开发，后续很难平滑的过渡到分布式场景。因此，CabloyJS 后端采用<code>Redis</code>，从框架底层就开始原生分布式的架构设计，并衍生出了<code>Broadcast、Queue、Schedule、Startup</code>等一系列分布式的开发组件，方便我们从一开始就进行分布式的开发。因此当系统起量后，可以轻松做集群扩展，参见：<a href="https://cabloy.com/zh-cn/articles/broadcast.html">Broadcast</a>, <a href="https://cabloy.com/zh-cn/articles/queue.html">Queue</a>, <a href="https://cabloy.com/zh-cn/articles/schedule.html">Schedule</a>, <a href="https://cabloy.com/zh-cn/articles/startup.html">Startup</a></p>
<p>3）<strong>前后端分离，全平台跨端开发</strong></p>
<p>通过前后端分离的架构设计，只需要一套代码就可以支持全平台业务的跨端开发，包括<code>B端后台管理应用</code>和<code>C端前台应用</code></p>
<table>
<thead>
<tr>
<th>平台</th>
<th>前端</th>
<th>后端</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC：Web</td>
<td>CabloyJS 前端</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>PC：Exe</td>
<td>CabloyJS 前端 + Electron</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>Mobile：IOS</td>
<td>CabloyJS 前端 + Cordova</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>Mobile：Android</td>
<td>CabloyJS 前端 + Cordova</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>微信公众号</td>
<td>CabloyJS 前端 + 微信 API</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>企业微信</td>
<td>CabloyJS 前端 + 企业微信 API</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>钉钉</td>
<td>CabloyJS 前端 + 钉钉 API</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>Slack</td>
<td>CabloyJS 前端 + Slack API</td>
<td>CabloyJS 后端</td>
</tr>
<tr>
<td>小程序：微信、支付宝等</td>
<td>Uni-app + CabloyJS 前端 SDK</td>
<td>CabloyJS 后端</td>
</tr>
</tbody>
</table>
<ul>
<li><code>后端</code>：由于完整的前后端分离设计，只需开发一套 CabloyJS 后端代码即可</li>
<li><code>前端</code>：所有可基于 H5 的场景，只需开发一套 CabloyJS 前端代码即可</li>
<li><code>小程序</code>：提供 CabloyJS 前端 SDK 让 Uni-app 可以轻松对接 CabloyJS 后端代码</li>
</ul>
<h2>CabloyJS可以开发什么系统</h2>
<ol>
<li>可以开发<code>多租户SAAS业务系统</code></li>
<li>可以开发前后端分离的<code>后台业务管理系统</code>，如OA、CRM、ERP、电商，等等</li>
<li>可以开发<code>JAMStack</code>架构的<code>CMS内容管理系统</code>，支持SEO优化，如博客、技术文档、社区、知识店铺，等等</li>
<li>既可以先开发<code>后台业务管理系统</code>，再延伸开发<code>CMS内容管理系统</code>；也可以反过来，先开发<code>CMS内容管理系统</code>，再延伸开发<code>后台业务管理系统</code></li>
<li>可以通过<code>Cordova</code>开发各类App应用，支持IOS、Android</li>
<li>可以通过<code>Electron</code>开发桌面应用</li>
<li>可以开发微信公众号、企业微信、钉钉，等第三方平台的应用，解决<code>信息孤岛</code>的问题</li>
<li>可以为<code>Uniapp小程序</code>开发后端API接口</li>
</ol>
<h2>CabloyJS的研发历程</h2>
<p>CabloyJS从2016年启动开发，主要历经两个研发阶段：</p>
<h3>1. 第一阶段：EggBornJS</h3>
<p>EggBornJS关注的核心就是<code>模块化体系</code>与<code>模块隔离</code>，并以此实现一套完整的全栈开发框架</p>
<p>比如模块<code>egg-born-front</code>是框架前端的核心模块，模块<code>egg-born-backend</code>是框架后端的核心模块，模块<code>egg-born</code>是框架的命令行工具，用于创建项目骨架</p>
<blockquote>
<p>这也是为什么所有业务模块都是以<code>egg-born-module-</code>为命名前缀的原因</p>
</blockquote>
<h3>2. 第二阶段：CabloyJS</h3>
<p>EggBornJS只是一个基础的全栈开发框架，如果要支持业务的快速开发，还需要考虑许多与业务相关的支撑特性，如：<code>工作流引擎</code>、<code>用户管理</code>、<code>角色管理</code>、<code>权限管理</code>、<code>菜单管理</code>、<code>参数设置管理</code>、<code>表单验证</code>、<code>登录机制</code>，等等。特别是在前后端分离的场景下，对<code>权限管理</code>的要求就提升到一个更高的水平</p>
<p>CabloyJS在EggBornJS的基础上，提供了一套核心业务模块，从而实现了一系列业务支撑特性，并将这些特性进行有机的组合，形成完整而灵活的上层生态架构，从而支持具体的业务开发进程</p>
<blockquote>
<p>有了EggBornJS，从此可复用的不仅仅是组件，还有业务模块</p>
</blockquote>
<blockquote>
<p>有了CabloyJS，您就可以快速开发各类业务应用</p>
</blockquote>
<h2>信念</h2>
<blockquote>
<p>凡是可以用JavaScript来写的应用，最终都会用JavaScript来写 | Atwood定律</p>
</blockquote>
<p>相信，Javascript的深度探索者都会被这句名言激发，共同努力，为Javascript生态添砖加瓦，构建更繁荣的应用生态</p>
<p>CabloyJS正是对这一名言的探索之作。欢迎您也加入CabloyJS的社区生态，一起促进Javascript的繁荣与应用</p>
<h2>名称的由来</h2>
<h3>1. EggBorn</h3>
<p>这个名称的由来比较简单，因为有了Egg(后端框架)，所以就有了EggBorn。有一部动画片叫《天书奇谭》，里面的萌主就叫“蛋生”，我很喜欢看（不小心暴露了年龄😅）</p>
<h3>2. Cabloy</h3>
<p>Cabloy来自蓝精灵的魔法咒语，拼对了Cabloy这个单词就会有神奇的效果。同样，CabloyJS是有关化学的魔法，基于模块的组合与生化反应，您将实现您想要的任何东西</p>
<h2>License</h2>
<p>MIT，免费商用</p>







标题：想开发一个web服务, 用javaScript, 不采用typescript, 现在哪个框架更合适
作者：yinhaixiang
发布日期：发布于 9 个月前
文章内容：<p>eggjs现在还有持续维护吗,  midwayjs可以开发直接用js开发吗, 这两个框架文档比较亲切, 看起来舒服</p>







标题：node+vue3+vite+ts开源免费的后台管理系统
作者：cool-team-official
发布日期：发布于 10 个月前
文章内容：<p><img src="//static.cnodejs.org/FqnBApmdD9YT_KDdMJ4i9Kslj-b8" alt="image.png"></p>
<p>midway官方推荐</p>
<p><a href="https://cool-js.com">官网</a></p>
<p><a href="https://github.com/cool-team-official">github</a></p>







标题：个人博客小程序构建，你也可以试试
作者：lh199507
发布日期：发布于 5 个月前
文章内容：<p><a href="https://github.com/AttemptWeb/Record/issues/36">本文原文地址</a>;</p>
<p>一直有构建个人博客小程序的想法，但又不想自己开发后端接口，想做到无后端，人又懒，就没有动手开干。</p>
<p>最近公司原因使用了语雀文档，觉得编辑界面蛮不错，功能强大，<code>思维导图</code>、<code>时序图</code>、<code>pdf</code>都支持，顺便将个人文章上传进行备份。后面在持续使用中，发现还提供<code>文档API</code>接口，于是萌生想法，是否可以考虑用<code>语雀接口</code>构建小程序。在<code>Postman</code> 测试了一波，发现字段基本都有，那就开始动手干了。</p>
<h2>uniapp&amp;语雀API</h2>
<p>小程序构建框架选择<a href="https://uniapp.dcloud.net.cn/">uniapp</a>，主要想尝试下不同的框架，之前有尝试使用 Taro 构建过下小程序：<a href="https://github.com/HerryLo/wxSapp">垃圾分类小程序</a>，就想试试其他框架了。之前听过群友聊过<a href="https://uniapp.dcloud.net.cn/">uniapp</a>，就决定试试。</p>
<p><a href="https://uniapp.dcloud.net.cn/">uniapp</a>主要是<code>vue</code>的语法，开发的流程按照<a href="https://uniapp.dcloud.net.cn/">uniapp 开发文档</a>就没有太大问题，平时尽管使用<code>React</code>开发，之前是接触和开发过<code>vue</code>项目，问题不太大。</p>
<p>既然<code>uniapp</code>开发问题不大，那就看看接口<code>语雀API</code>怎么样呢？</p>
<p>前期使用<code>Postman</code>调试以后，发现接口是可以调通的，不过语雀近期推出了<strong>会员功能</strong>，好像会和这个冲突，免费用户不知道后期是否可以调用<a href="https://www.yuque.com/yuque/developer/api">语雀 API</a>，找语雀官方人员确认之后：</p>
<blockquote>
<p>语雀回复：</p>
</blockquote>
<blockquote>
<p>你好，目前 api 已变更为会员权益功能</p>
</blockquote>
<p>。。。有点拉了，不过看在文档好用的份上，还是<strong>开了99的专业会员</strong>，不然<a href="https://www.yuque.com/yuque/developer/api">语雀 API</a>接口没办法调用，整体来说还划算吧？吧？吧？</p>
<h2>小程序界面</h2>
<p>界面简单整洁，格调清新（功能简单）。不吹了，有兴趣自己构建的同学，底部附有项目源码地址。（主要是不知道怎么设计，就成这个样子了）</p>
<p>&lt;div align=“center”&gt;
&lt;img src=“<a href="https://herrylo.github.io/image/IMG_2940.png">https://herrylo.github.io/image/IMG_2940.png</a>” style=“height: 60%; width: 60%;” /&gt;
&lt;img src=“<a href="https://herrylo.github.io/image/IMG_2941.png">https://herrylo.github.io/image/IMG_2941.png</a>” style=“height: 60%; width: 60%;” /&gt;
&lt;/div&gt;</p>
<p>目前只支持文章列表，文章总数等功能，后续应该会添加上评论、点赞功能。</p>
<p>如果你也想开发自己的个人博客系小程序项目，希望以上可以帮助到你！</p>
<h2>更多</h2>
<p>附上我自己的小程序项目，希望可帮到大家，项目为开源状态，有兴趣可以看看！！</p>
<p>项目地址：</p>
<blockquote>
<p><a href="https://github.com/HerryLo/uniapp-wxapp">uniapp 个人博客小程序 GitHub 地址</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/HerryLo/wxSapp">Trao 垃圾分类小程序 GitHub 地址</a></p>
</blockquote>
<p>博客二维码:</p>
<blockquote>
<p><img src="https://herrylo.github.io/image/gh_blog.jpg" alt=""></p>
</blockquote>
<p>注意： 框架使用的uniapp。文章是在语雀：<a href="https://www.yuque.com/yopai/pp6bv5">www.yuque.com</a> 发布的，然后语雀有提供API接口，可获取到在语雀上发布的文档列表；不过之前问语雀官方，官方回复是需要会员才可访问语雀API调取文档数据，免费用户是无法调取；</p>







标题：js 树形结构问题处理?
作者：xuwenliu
发布日期：发布于 5 个月前
文章内容：<p>将如下结构中的type=1的内容提取到父级。层级可能是无限极。</p>
<pre class="prettyprint language-js"><code>const routes = [
  {
    name: "首页",
    type: 0,
    children: [],
  },
  {
    name: "系统管理",
    type: 0,
    children: [
      {
        name: "用户管理",
        type: 0,
        children: [
          {
            name: "新建用户",
            type: 1,
            children: [],
          },
        ],
      },
      {
        name: "角色管理",
        type: 0,
        children: [
          {
            name: "新建角色",
            type: 1,
            children: [],
          },
          {
            name: "成员管理",
            type: 1,
            children: [],
          },
        ],
      },
    ],
  },
];
</code></pre><p>期望：</p>
<pre class="prettyprint language-js"><code>const routes = [
  {
    name: "首页",
    type: 0,
    children: [],
  },
  {
    name: "系统管理",
    type: 0,
    children: [
      {
        name: "用户管理",
        type: 0,
        children: [],
      },
      {
        name: "新建用户",
        type: 1,
        children: [],
      },
      {
        name: "角色管理",
        type: 0,
        children: [],
      },
      {
        name: "新建角色",
        type: 1,
        children: [],
      },
      {
        name: "成员管理",
        type: 1,
        children: [],
      },
    ],
  },
];
</code></pre>






标题：nodejs实现微服务实践指导？
作者：danielmlc
发布日期：发布于 5 个月前
文章内容：<p>nodejs实现微服务，有比较推荐的方案吗？大佬们都在用哪些方式实现呢？nestjs落地微服务靠谱吗？</p>







标题：不限新老，2核4g2M一年只需60
作者：cool-team-official
发布日期：发布于 5 个月前
文章内容：<p>联系客服咨询
<img src="https://cool-js.com/wechat.png" alt="wechat (5).png"></p>







标题：请教一下，child_process执行bat脚本时如何让cmd窗口在后台运行不显示出来？
作者：wldlzt
发布日期：发布于 5 个月前
文章内容：<p>请教一下大家，child_process执行一个bat脚本时，总要弹出cmd窗口，直到运行完成才消失，有没有办法不让这个窗口显示出来？</p>







标题：37个C++11特性的代码示例
作者：classfellow
发布日期：发布于 5 个月前
文章内容：<p>自己写的代码示例，总结了37个特性，每一个都有小例子，对学习使用C++11很有用。
工程地址：
<a href="https://github.com/x2jia/38-code-examples-for-cpp11">https://github.com/x2jia/38-code-examples-for-cpp11</a>
同时还包含了一个用C++11实现的Chrome线程模型，所以总共38个。</p>







标题：Node.js Server 偶发的神秘 404 告警排查
作者：xiaoxiaojx
发布日期：发布于 5 个月前
文章内容：<p><img src="https://user-images.githubusercontent.com/23253540/201381382-e077753f-f7d0-458c-a675-b7194bf91366.png" alt="image"></p>
<p>原文地址: <a href="https://github.com/xiaoxiaojx/blog/issues/48">https://github.com/xiaoxiaojx/blog/issues/48</a></p>
<h2>问题简述</h2>
<p>业务方反馈自己负责的服务端渲染项目出现了少量的 404 告警, 约 0.0677% 的量。听到这个问题描述还是比较惊讶, 印象中 404 可能是唯一不会出现的状态码, 原因如下</p>
<ol>
<li>进入 Node 服务的请求都是事先注册好了的路由, 没有注册的路由到网关就会被拦截, 流量到不了 Node 就谈不上 404</li>
<li>告警详情中发现出现 404 的路由在线上稳定运行已久，已知肯定存在的路由为何会 404 ?</li>
</ol>
<h2>问题排查</h2>
<p>难道是 Node Server 代码在某种条件下主动设置了 statusCode 为 404 ?</p>
<p>答案是否定的 ❌, 类似如下模拟的 Node Server 最简实现, 从代码初步判断只可能出现 render 正常渲染设置的 200 或者渲染错误 error 设置的 500 状态码</p>
<blockquote>
<p><a href="https://github.com/jshttp/on-finished">on-finished</a>: Execute a callback when a HTTP request closes, finishes, or errors.</p>
</blockquote>
<p>onFinished 回调函数中为本次 404 告警上报处 ⚠️（链路追踪中发现此时 error 中间件却没有上报渲染出错的记录）</p>
<pre class="prettyprint language-js"><code>// Node Server Demo

const Koa = require("koa");
const onFinished = require("on-finished")

function report(msg) {
    console.log(msg)
}
async function error(ctx, next) {
    try {
        await next()
    } catch (err) {
        ctx.status = 500
        report(`本次渲染出错: errorMsg: ${err.message}`)
    }
}
async function render(ctx, next) {
    await new Promise(res =&gt; {
        setTimeout(() =&gt; {
            ctx.body = "ok"
            ctx.status = 200;
            res()
        }, 100) // 模拟服务端渲染等待 100ms
    })
    await next()
}
async function monitor(ctx, next) {
    onFinished(ctx.res, (err, res) =&gt; {
    	// &gt;&gt;&gt; 本次 404 告警处 &lt;&lt;&lt;
        report(`本次请求 success: ${!err &amp;&amp; res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 400}, statusCode: ${res.statusCode}`)
    })
    await next()
}

const app = new Koa();
app.use(error)
app.use(monitor)
app.use(render)
app.listen(3000)
</code></pre><p>当然实际 Node Server 代码远比 Demo 复杂得多, 所以 k同学先在可能会抛错的代码与可能存在逻辑漏洞的代码处追加了日志, 反复上线了几次也没有找到比较有价值的线索</p>
<p>此时都在想是不是可以放弃排查了, 0.0677% 的量也不是很多, 但是对这种诡异的现象又充满了好奇</p>
<p>于是我陷入了一阵沉思与回想, 在 k同学严密的日志中问题应该会无所遁形才对, 那么 <strong><em>假设追加的日志所监控的代码就是一切正常没有抛错</em></strong>, 那么可能发生的情况就是错误在日志覆盖不到的地方<strong><em>或者是客户端的异常导致</em></strong>?</p>
<p>根据这个假设前提我就想到了一种可能, 比如用 Node 作为 Client 并且使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">AbortController</a> 来提前终止 tcp 连接进行验证</p>
<pre class="prettyprint language-js"><code>// Node Client Demo

const fetch = require('node-fetch')
let controller = new AbortController()
const signal = controller.signal

setTimeout(() =&gt; {
  controller.abort()
}, 50) // 小于 render 的 100ms 即可

fetch('http://localhost:3000', {
  signal,
  method: 'GET',
})
</code></pre><p>按照如上作为验证的 Client Demo, 那么完整的事故过程就是</p>
<ol>
<li>Client 发起请求（如浏览器新开 Tab 输入网页地址）</li>
<li>Server 收到请求开始进行 render 等处理流程</li>
<li>Client abort 了请求（如浏览器关闭了网页 Tab）</li>
<li>Server 收到 abort -&gt; tcp 连接即将断开 -&gt; onFinished 回调被调用, 上报了此时的状态码为 <strong><em>Koa 初始状态的 404</em></strong> -&gt; tcp 连接断开</li>
<li>Server 渲染结束, 设置响应 body 与状态码为 200, 由于 tcp 连接已经断开, 此时的设置没有了意义</li>
</ol>
<p>这里我们也可以把 Node.js Server Demo 的 render 时间从 100ms 改为 3s, 然后使用浏览器作为 Client 模拟用户打开 <a href="http://localhost:3000">http://localhost:3000</a>, 最后在 3s 内关闭网页 Tab 也能复现该过程 ✅</p>
<pre class="prettyprint language-bash"><code>本次请求 success: false, statusCode: 404
</code></pre><h2>问题结论</h2>
<p>on-finished 函数很实用, 但是不要忽略了 aborted 的情况。后续可以优化为 aborted 后单独上报一条记录, 监控 aborted 的量在一定预值即可</p>
<pre class="prettyprint language-diff"><code>async function monitor(ctx, next) {
    onFinished(ctx.res, (err, res) =&gt; {
+        ctx.req.aborted &amp;&amp; report("client aborted!")
+        report(`本次请求 success: ${ctx.req.aborted || (!err &amp;&amp; res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 400)}, statusCode: ${res.statusCode}`)
-        report(`本次请求 success: ${!err &amp;&amp; res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 400}, statusCode: ${res.statusCode}`)
    })
    await next()
}
</code></pre><blockquote>
<p><a href="https://github.com/jshttp/on-finished">on-finished</a>: Execute a callback when a HTTP request closes, finishes, or errors.</p>
</blockquote>
<p>其实回头想想, 如果能先彻底理解 on-finished 的定义与行为应该会少走一些弯路。一开始就下意识的认为 on-finished 只监听了 response 的 finish 事件, 仔细一瞧它的定义, 还包括了 close（aborted 是触发了该行为导致的连接提前关闭）以及 error 事件, on-finished 监听的所有事件见如下代码</p>
<p><img src="https://user-images.githubusercontent.com/23253540/201391197-d8adeff9-5eed-47db-925e-f4d7efbe8bcc.png" alt=""></p>







标题：精华



        我的 Node.js 十年 -- 写在 NodeParty 2022 前夕
作者：atian25
发布日期：发布于 9 个月前
文章内容：<blockquote>
<p>知乎原文地址：<a href="https://zhuanlan.zhihu.com/p/546175922">https://zhuanlan.zhihu.com/p/546175922</a> ， 求个赞~
NodeParty 2022.08.08 邀您线上围观，直播预约地址见文末。</p>
</blockquote>
<h2>相识于微末</h2>
<p>我是一个野生的程序猿，非科班出身，在非互联网小公司待了很多年。刚开始工作的时候，还没有前端这个岗位，不过高三的时候就接触过网页三剑客，一见钟情于 HTML/CSS/JS 的『所见即所得』，懵懵懂懂间经历过 JavaScript 停滞的那几年，也被 GMail 引领的翻身之战惊艳过，重新认识了前端。</p>
<p><img src="//static.cnodejs.org/FlRpbwKzQWfj6vKKPI7vRILJ7aqk" alt="yuque_diagram.jpg"></p>
<p>JavaScript 一开始只能在浏览器这个容器中运行，2009 年 Ryan Dah 在研究 V8 引擎时突发奇想，JavaScript 本身就是单线程的，而且浏览器发起的 AJAX 请求就是非阻塞的，如果将 JavaScript 和异步 IO 以及一个简单的 HTTP 服务器集合在一起，就会变成一个很酷的东西。于是在同年 05 月 01 日，Ryan Dah 在与 Tim Becker 的邮件讨论中正式把它命名为 node，同月 27 日发布第一个版本，随即在 11 月的 JSConf EU 上正式对外发布。</p>
<p>2011 年，正在沉浸于用 ExtJS 和 Flash 为电信 ERP 系统打工的我，时不时会写一些小工具来帮自己偷懒，但一直没找到合适的工具，苟且于 Groovy 和 Swing。有一天无意间刷 OSChina 资讯时看到 Node.js 的新闻，当时的第一反应是：『又一个 jQuery 轮子？切~~』，幸运的是基于『多少看一下反正不要钱，闲着也是闲着』的想法，点击了进去，于是发现了一个新的世界，真香~</p>
<p>记得当时微信公众平台刚出来，我的第一个练手项目就是 <a href="https://github.com/node-webot">node-webot</a>，也是第一次参与开源。</p>
<hr>
<h2>刀耕火种</h2>
<p>2013 年，入职了 UC。此时的业界，已经有了前端岗位，归属于设计部门，也叫重构工程师。前端开始进入富应用时代，但还非常的刀耕火种。</p>
<p>2014 年，在 UC 遇到了 云龙，有幸和他一起探索 UC 的前端工程化，基于 FIS 之上实现了 Scrat，那是一段很快乐的时光。 FIS 的实现本身虽然比较粗糙，是基于正则表达式而不是 AST 的，但它的工程化思维却非常的前沿。</p>
<p>现在很多人聊起 Node.js，第一印象可能是：『一个自不量力的想抢 Java 饭碗的语言』，但其实 <strong>命令行工具 才是 Node.js 最初落地及最大的应用场景，它给前端领域带来了巨大的变革：Grunt 的出现让前端有了自己的构建工具，Babel 的出现让我们停滞已久的标准化重焕生机，Webpack 的出现让前端工程化有了基石，前端基建进入新石器时代。</strong></p>
<p><img src="//static.cnodejs.org/FurQDrabVnkNOE4weUDSAw2aspUl" alt="1658733897206-5fb8a56d-1330-4108-b54a-287ff9a43c7e.png"></p>
<blockquote>
<p>参考阅读：《前端工具链十年盘点》，<a href="https://zhuanlan.zhihu.com/p/462985064">https://zhuanlan.zhihu.com/p/462985064</a></p>
</blockquote>
<hr>
<h2>全栈工程师</h2>
<p>2014 年，随着 UC 被阿里收购，我被动的完成了毕业时的目标之一。同年 6 月 21 日的 JSConf CN 大会上，赫门 分享了 《淘宝前后端分离实践》，吹响了国内前端 <strong>前后端分层</strong> 的号角，BFF 的基石也正是 Node.js 这一武器。</p>
<p>2015 年 11 月 13 日，在 苏千 的号召下，成立了 Node.js 虚拟工作组，聚集了来自蚂蚁、淘宝、ICBC、UC 等等 BU 的接口人进行共建，我作为 UC 的代表来到了杭州，核心成员闭关一周，产出了 EggJS，寓意是希望帮助各团队架构师孕育出适合团队业务场景的上层框架。随着它的完善，Node.js 生态有了三驾马车（ EggJS 框架、TNPM 包管理、AliNode 性能分析）的护航。</p>
<p><img src="//static.cnodejs.org/FrC78irYYLL0KKSRqE_NcrirPojf" alt="1658744625445-5ab86d91-d3b2-4548-b89e-fad3963508ba.png"></p>
<p>Node.js 在服务端的起点，是 BFF 聚合层。BFF 聚合层一直都存在，它不局限于语言，只不过之前由 Java 团队来负责。随着业务复杂度和专业度提升的要求，由前端团队来接管这一层，更有利于服务自治和高效协作，于是很多前端团队选择了 Node.js 来承载它。同时也有一拨人基于它来建设前端新基建，如 npmmirror 前端包镜像服务、前端研发平台、前端活动运营平台等等。</p>
<p><strong>在移动互联网的浪巅下，前端肆意地探索着自己的边界，从 PC 到 H5，从 WebView 到 APP，从 Browser 到 Server，这是属于前端的大航海时代，一时间人人都是全栈工程师。</strong></p>
<p>这是一个全栈爆发的时代，这是一个活力四射的时代。我们冲锋陷阵有了不少突破，但我们也留下了很多历史债。</p>
<hr>
<h2>静水深流</h2>
<p>2019 年初，我加入了蚂蚁体验技术部，来到了那个 EggJS、CNPM 诞生的地方，成为了一名前端基础技术人，专注于 Node.js 基础设施的建设。</p>
<p>真正投入到基础设施后，你会发现后端的领域非常广阔，要让一个新生的基础设施完善以及得到认可，需要一代代人的努力和沉淀。</p>
<ul>
<li>我们实现了各种后端服务的 SDK，因为在那个年代跨语言支持友好性不像今天这样是一个共识。</li>
<li>我们实现了 EggJS 框架、TNPM 包管理、AliNode 性能分析 三驾马车来为业务开发护航。</li>
<li>我们实现了自己的研发平台，收敛研发模式，对接下游 PaaS 等基础设施。</li>
<li>我们在语雀、云凤蝶、雨燕等场景都大规模的深度使用了 Node.js。</li>
</ul>
<p>近年来，我们进入了平台治理期，我们变得更耐心和更克制，围绕着前端核心场景去深入，不会把 Node.js 作为锤子去找钉子。</p>
<p><strong>我们不再追求人人都是全栈工程师，前端领域目前已经足够广大，术业有专攻，我们的目标是把部分前端培养成全栈，成为前端新基建的护航者，让一线前端可以无感的没有额外负担的享受到这些能力，从而给业务带来创新。</strong></p>
<p>我们不再追求全民 BFF 化，而是会帮助业务一起分析架构选型，协建上层业务平台的方式来提升效能和 ROI。我们重新审视原来的基础设施，结合最新的前端实践进行更极致的翻新，如过去一年在 CNPM Rapid 等方面的实践。</p>
<blockquote>
<p>“<strong>Any application that can be written in JavaScript, will eventually be written in JavaScript</strong>.” – Jeff Atwood（任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。）</p>
</blockquote>
<p>这段话曾经在前端圈很流行，我个人觉得它既对，也不对。在那个时代，Node.js 这个少年处于野蛮生长时代，年轻人总需要去证明一点什么，证明这世界上没有什么是不可能的，一切皆有可能。但成长后的少年，已经不需要去为了证明什么而去做些什么，而是需要聚焦回核心航道上的事，不用分心在可以做但没必要做的事上。</p>
<blockquote>
<p>“<strong>The strength of JavaScript is that you can do anything. The weakness is that you will.</strong>” – Reg Braithwaite （JavaScript 的优点是可以写任何东西，缺点是你真的会用它去写这些东西。）</p>
</blockquote>
<p>这句话，我认为是对上一段话的回应，或者说下联，我们需要正确且理智的看待手中的武器，并使用在合适的场景。</p>
<hr>
<h2>Node Party</h2>
<p>不知不觉，Node.js 已经陪伴了我十年，在工作中一直在深度实践，在社区也一直在做 Node.js 的科普工作。但我一直不觉得自己是 Node.js 布道师，我只是一个记录者，我也不觉得 Node.js 是万能的，不觉得它能拳打脚踢 Java 等语言，每个团队的起点、技术背景、基础设施都不一样，不能一概而论。</p>
<p><strong>我坚信它对前端领域的价值，是一个不可或缺的基础设施，或许未来前端的变革使得一切工程问题从根本上得到解决，但不管怎样，我只是希望当下能认真记录自己以及同行者们在这个领域的所见所想，与正在经历前端工业化演进并被此过程困扰的同学交流心得，让大家有所参考从而迈出自己的路。</strong></p>
<p>经历过前端大航海时代的同学，一定还记得当年 JSConf CN、Node Party、前端圈等各种大会，那真是一个令人怀念的纯真的技术年代啊。近几年来，各种大会少了不少，也有人会吐槽没啥干货，其实不必纠结，因为前端已经到了一个平台期了，它涉猎的范围太广了，自然会显得有点平淡，其实不尽然，我们一直都在前行着。</p>
<p>去年底 苏千 找我说，办个 Node Party 吧，我一开始有点疑虑，因为我们正在做的很多都是内部的治理工作，社区的同学不一定能理解和有所收获。苏千说：『没关系的，我们既然一直在这条路上走着，我们有义务跟社区分享下我们的所思所得，让大家知道，还有这么一群人一直在前行着』。</p>
<p>因此，今天诚邀大家参与蚂蚁集团举办的 <strong>Node Party 2022.08.08 线上直播</strong>，我们分享的内容包括：</p>
<ul>
<li><strong>Node.js What’s Next</strong>，来自 Node.js Contributor 的分享，介绍  Node.js 工作组正在推进的战略计划，以及如何参与定义  Node.js 的未来。</li>
<li><strong>基于 cnpmcore 实现企业级包管理服务</strong>， 来听一听 cnpm registry 全新重构的技术内幕和架构思考。</li>
<li><strong>cnpm rapid 正式开源</strong>，上半年我们曾分享过的 『深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒』，终于到 show me the code 环节了。</li>
<li><strong>从 Egg 到 Artus，谈谈框架的框架的初心</strong> ，分享来自蚂蚁、字节、蔚来团队的共建。</li>
</ul>
<p>也许我们还没完全准备好，还在持续的完善中，但我们希望能让社区的同学知道，我们一直都在前行，等你~</p>
<p>B 站预约传送门： <a href="https://live.bilibili.com/21726701">https://live.bilibili.com/21726701</a>，敬请关注。</p>







标题：请教下大家关于在NW.JS中使用webview的若干问题
作者：wldlzt
发布日期：发布于 5 个月前
文章内容：<p>大家好，请教下大家如下两个问题，麻烦稍有思路或方案的朋友可以指点一二，第一个问题比较重要：
1：原先在启动页面可以直接引用的nw.gui，在webview里却无法引用，提示gui对象不存在，请问要如何解决？
2：因性能问题，需要把原先在NW.JS中的iframe更换成webview，因为后者与NW.JS有进程隔离，现在造成无法直接高效地在启动页的主进程中与webview通信，当然这个可以通过net模块来管理。但原本想借助chrome.runtime来通信的方案一直无法打通，请教下大家有无比较高效的交互方案？</p>







标题：国产凹语言开源季度总结
作者：chai2010
发布日期：发布于 5 个月前
文章内容：<p>凹语言（凹读音“wā”）是 国内 Gopher 针对 WASM 平台设计的通用编程语言。凹语言作为WASM原生 的编程语言，天然对浏览器环境亲和，同时支持 Linux、macOS 和 Windows 等主流操作系统，此外通过 LLVM 后端对本地应用和单片机等环境提供支持。</p>
<ul>
<li>凹语言官网: <a href="https://wa-lang.org">https://wa-lang.org</a></li>
<li>凹语言仓库: <a href="https://github.com/wa-lang/wa">https://github.com/wa-lang/wa</a></li>
</ul>
<p>凹语言最近刚刚发布 v0.3.0，而正式开源不知不觉已经过去一个季度，这是凹语言开源的第一个季度的非正式总结，也是对未来的计划和展望。</p>
<p>完整内容请参考：<a href="http://wa-lang.org/smalltalk/st0011.html">http://wa-lang.org/smalltalk/st0011.html</a></p>
<p><img src="https://wa-lang.org/st0011-02.png" alt=""></p>







标题：开源免费的nodejs快速开发框架
作者：cool-team-official
发布日期：发布于 10 个月前
文章内容：<p><img src="//static.cnodejs.org/Fsyfj4K3_SFWi9sswtHl3Zcl1WUY" alt="show (1).png"></p>
<p><a href="https://www.bilibili.com/video/BV1a34y1X7Sa/">快速体验</a></p>
<p><a href="https://cool-js.com">文档地址</a></p>







标题：基于声网 Web SDK 实现一对一视频通话
作者：kylezhang
发布日期：发布于 6 个月前
文章内容：<p>视频互动直播是当前比较热门的玩法，我们经常见到有PK 连麦、直播答题、一起 KTV、电商直播、互动大班课、视频相亲等。本文将演示如何通过声网 视频 SDK 在 Web 端实现一个视频直播应用。话不多说，我们开始动手实操。</p>
<h1>前提准备</h1>
<p>在声网开发者控制台 Console  <a href="https://console.agora.io">https://console.agora.io</a> 注册声网开发者账号后，需要获取项目 AppID。另外，开发者每个月可获得 10000 分钟的免费使用额度，可实现各类实时音视频场景。</p>
<h1>先来体验下 Demo</h1>
<p>我们在 GitHub 上提供一个开源的基础视频通话示例项目，在开始开发之前你可以通过该示例项目体验音视频通话效果。</p>
<ul>
<li>在线 demo：<a href="https://webdemo.agora.io/basicVideoCall/index.html">https://webdemo.agora.io/basicVideoCall/index.html</a></li>
<li>源码 Github 地址：<a href="https://github.com/AgoraIO/API-Examples-Web/tree/main/Demo/basicVideoCall">https://github.com/AgoraIO/API-Examples-Web/tree/main/Demo/basicVideoCall</a>
<img src="https://img-blog.csdnimg.cn/0ca3e7286f0b45beb5b8a1a4f66d5969.jpeg#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1>动手实践</h1>
<p>从 Web 前端页面引入声网 SDK，发起视频通话。</p>
<h2>开发环境</h2>
<p>声网 SDK 的兼容性良好，对硬件设备和软件系统的要求不高，开发环境和测试环境满足以下条件即可，以下是本文的开发环境和测试环境：</p>
<ul>
<li>浏览器：Chrome、Firefox、Safari 及 Edge</li>
<li>开发环境
<ul>
<li>MacBook Pro (13-inch, M1, 2020)</li>
<li>Visual Studio Code (1.67.1)</li>
<li>AgoraWebSDK (4.12.2)</li>
</ul>
</li>
<li>测试环境
<ul>
<li>Chrome (101.0.4951.64)</li>
</ul>
</li>
</ul>
<h2>手动集成设置</h2>
<h4>文件组织结构</h4>
<p>实现视频通话之前，参考如下步骤设置你的项目：
如需创建新项目，可以在 Visual Studio Code 里 File &gt; New Window，创建 Web 项目。完整的目录结构如下，根据个人经验会有所变化。</p>
<pre class="prettyprint language-bash"><code>.
├── index.css # 用于设计 Web 应用的用户界面样式
├── index.html # 用于设计 Web 应用的用户界面
├── index.js # 通过 AgoraRTCClient 实现具体应用逻辑的代码。
└── vendor # 第三方前端插件，辅助页面布局和交互，本教程中是下载到本地使用，你也可以使用 CDN 的方式
    ├── bootstrap.bundle.min.js
    ├── bootstrap.min.css
    └── jquery-3.4.1.min.js
</code></pre><h3>前端页面集成声网 SDK</h3>
<p>声网可以下载到本地使用，也可以直接使用声网的 CDN 引入， 本文推荐使用 CDN 方式集成Agora SDK。</p>
<p>在 index.html 中添加以下代码</p>
<pre class="prettyprint language-html"><code>
&lt;!DOCTYPE html&gt;
...
  &lt;link rel="stylesheet" href="./vendor/bootstrap.min.css"&gt;
  &lt;link rel="stylesheet" href="./index.css"&gt;
...
  &lt;script src="./vendor/jquery-3.4.1.min.js"&gt;&lt;/script&gt;
  &lt;script src="./vendor/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"&gt;&lt;/script&gt;
  &lt;script src="./index.js"&gt;&lt;/script&gt;
...
</code></pre><h4>最终完整代码为</h4>
<p>可以直接复制运行。</p>
<pre class="prettyprint language-html"><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
  &lt;title&gt;Basic Video Call -- Agora&lt;/title&gt;
  &lt;link rel="stylesheet" href="./vendor/bootstrap.min.css"&gt;
  &lt;link rel="stylesheet" href="./index.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container-fluid banner"&gt;
    &lt;p class="banner-text"&gt;Basic Video Call&lt;/p&gt;
    &lt;a style="color: rgb(255, 255, 255);fill: rgb(255, 255, 255);fill-rule: evenodd; position: absolute; right: 10px; top: 4px;"
      class="Header-link " href="https://github.com/AgoraIO-Community/AgoraWebSDK-NG/tree/master/Demo"&gt;
      &lt;svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"&gt;&lt;/path&gt;&lt;/svg&gt;
    &lt;/a&gt;
  &lt;/div&gt;
 
 
  &lt;div id="success-alert" class="alert alert-success alert-dismissible fade show" role="alert"&gt;
    &lt;strong&gt;Congratulations!&lt;/strong&gt;&lt;span&gt; You can invite others join this channel by click &lt;/span&gt;&lt;a href="" target="_blank"&gt;here&lt;/a&gt;
    &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;
      &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;
    &lt;/button&gt;
  &lt;/div&gt;
  &lt;div id="success-alert-with-token" class="alert alert-success alert-dismissible fade show" role="alert"&gt;
    &lt;strong&gt;Congratulations!&lt;/strong&gt;&lt;span&gt; Joined room successfully. &lt;/span&gt;
    &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;
      &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;
    &lt;/button&gt;
  &lt;/div&gt;
  &lt;div id="success-alert-with-token" class="alert alert-success alert-dismissible fade show" role="alert"&gt;
    &lt;strong&gt;Congratulations!&lt;/strong&gt;&lt;span&gt; Joined room successfully. &lt;/span&gt;
    &lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;
      &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;
    &lt;/button&gt;
  &lt;/div&gt;
   
  &lt;div class="container"&gt;
    &lt;form id="join-form"&gt;
      &lt;div class="row join-info-group"&gt;
          &lt;div class="col-sm"&gt;
            &lt;p class="join-info-text"&gt;AppID&lt;/p&gt;
            &lt;input id="appid" type="text" placeholder="enter appid" required&gt;
            &lt;p class="tips"&gt;If you don`t know what is your appid, checkout &lt;a href="https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-nameappidaapp-id"&gt;this&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="col-sm"&gt;
            &lt;p class="join-info-text"&gt;Token(optional)&lt;/p&gt;
            &lt;input id="token" type="text" placeholder="enter token"&gt;
            &lt;p class="tips"&gt;If you don`t know what is your token, checkout &lt;a href="https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-namekeyadynamic-key"&gt;this&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class="col-sm"&gt;
            &lt;p class="join-info-text"&gt;Channel&lt;/p&gt;
            &lt;input id="channel" type="text" placeholder="enter channel name" required&gt;
            &lt;p class="tips"&gt;If you don`t know what is your channel, checkout &lt;a href="https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#channel"&gt;this&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
      &lt;/div&gt;
 
      &lt;div class="button-group"&gt;
        &lt;button id="join" type="submit" class="btn btn-primary btn-sm"&gt;Join&lt;/button&gt;
        &lt;button id="leave" type="button" class="btn btn-primary btn-sm" disabled&gt;Leave&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
 
    &lt;div class="row video-group"&gt;
      &lt;div class="col"&gt;
        &lt;p id="local-player-name" class="player-name"&gt;&lt;/p&gt;
        &lt;div id="local-player" class="player"&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="w-100"&gt;&lt;/div&gt;
      &lt;div class="col"&gt;
        &lt;div id="remote-playerlist"&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
 
  &lt;script src="./vendor/jquery-3.4.1.min.js"&gt;&lt;/script&gt;
  &lt;script src="./vendor/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"&gt;&lt;/script&gt;
  &lt;script src="./index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3>视频通话逻辑</h3>
<p>注：以下代码都将在 index.js 中添加</p>
<h5>1）初始化Client</h5>
<pre class="prettyprint language-javascript"><code>var client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
</code></pre><h5>2）加入RTC 频道并创建本地音频轨道</h5>
<pre class="prettyprint language-javascript"><code>// Join a channel and create local tracks. Best practice is to use Promise.all and run them concurrently.
[ options.uid, localTracks.audioTrack, localTracks.videoTrack ] = await Promise.all([
  // Join the channel.
  client.join(options.appid, options.channel, options.token || null, options.uid || null),
  // Create tracks to the local microphone and camera.
  AgoraRTC.createMicrophoneAudioTrack(),
  AgoraRTC.createCameraVideoTrack()
]);
</code></pre><h5>3）播放本地视频</h5>
<pre class="prettyprint language-javascript"><code>// Play the local video track to the local browser and update the UI with the user ID.
localTracks.videoTrack.play("local-player");
</code></pre><h5>4）发布本地音视频到频道中</h5>
<pre class="prettyprint language-javascript"><code>// Publish the local video and audio tracks to the channel.
await client.publish(Object.values(localTracks));
</code></pre><h5>5）监听远端用户音视频</h5>
<pre class="prettyprint language-javascript"><code>// Add an event listener to play remote tracks when remote user publishes.
client.on("user-published", handleUserPublished);
client.on("user-unpublished", handleUserUnpublished);
 
function handleUserPublished(user, mediaType) {
  const id = user.uid;
  remoteUsers[id] = user;
  subscribe(user, mediaType);
}
 
function handleUserUnpublished(user, mediaType) {
  if (mediaType === 'video') {
    const id = user.uid;
    delete remoteUsers[id];
    $(`#player-wrapper-${id}`).remove();
  }
}
 
 
async function subscribe(user, mediaType) {
  const uid = user.uid;
  // subscribe to a remote user
  await client.subscribe(user, mediaType);
  console.log("subscribe success");
  if (mediaType === 'video') {
    const player = $(`
      &lt;div id="player-wrapper-${uid}"&gt;
        &lt;p class="player-name"&gt;remoteUser(${uid})&lt;/p&gt;
        &lt;div id="player-${uid}" class="player"&gt;&lt;/div&gt;
      &lt;/div&gt;
    `);
    $("#remote-playerlist").append(player);
    user.videoTrack.play(`player-${uid}`);
  }
 
  if (mediaType === 'audio') {
    user.audioTrack.play();
  }
}
</code></pre><h5>6）离开频道</h5>
<pre class="prettyprint language-javascript"><code>async function leave() {
  for (trackName in localTracks) {
    var track = localTracks[trackName];
    if(track) {
      track.stop();
      track.close();
      localTracks[trackName] = undefined;
    }
  }
 
  // Remove remote users and player views.
  remoteUsers = {};
  $("#remote-playerlist").html("");
 
  // leave the channel
  await client.leave();
 
}
</code></pre><h4>最终完整的代码</h4>
<pre class="prettyprint language-javascript"><code>// create Agora client
var client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
 
 
var localTracks = {
  videoTrack: null,
  audioTrack: null
};
var remoteUsers = {};
// Agora client options
var options = {
  appid: null,
  channel: null,
  uid: null,
  token: null
};
 
// the demo can auto join channel with params in url
$(() =&gt; {
  var urlParams = new URL(location.href).searchParams;
  options.appid = urlParams.get("appid");
  options.channel = urlParams.get("channel");
  options.token = urlParams.get("token");
  if (options.appid &amp;&amp; options.channel) {
    $("#appid").val(options.appid);
    $("#token").val(options.token);
    $("#channel").val(options.channel);
    $("#join-form").submit();
  }
})
 
$("#join-form").submit(async function (e) {
  e.preventDefault();
  $("#join").attr("disabled", true);
  try {
    options.appid = $("#appid").val();
    options.token = $("#token").val();
    options.channel = $("#channel").val();
    await join();
    if(options.token) {
      $("#success-alert-with-token").css("display", "block");
    } else {
      $("#success-alert a").attr("href", `index.html?appid=${options.appid}&amp;channel=${options.channel}&amp;token=${options.token}`);
      $("#success-alert").css("display", "block");
    }
  } catch (error) {
    console.error(error);
  } finally {
    $("#leave").attr("disabled", false);
  }
})
 
$("#leave").click(function (e) {
  leave();
})
 
async function join() {
 
  // add event listener to play remote tracks when remote user publishs.
  client.on("user-published", handleUserPublished);
  client.on("user-unpublished", handleUserUnpublished);
 
  // join a channel and create local tracks, we can use Promise.all to run them concurrently
  [ options.uid, localTracks.audioTrack, localTracks.videoTrack ] = await Promise.all([
    // join the channel
    client.join(options.appid, options.channel, options.token || null),
    // create local tracks, using microphone and camera
    AgoraRTC.createMicrophoneAudioTrack(),
    AgoraRTC.createCameraVideoTrack()
  ]);
   
  // play local video track
  localTracks.videoTrack.play("local-player");
  $("#local-player-name").text(`localVideo(${options.uid})`);
 
  // publish local tracks to channel
  await client.publish(Object.values(localTracks));
  console.log("publish success");
}
 
async function leave() {
  for (trackName in localTracks) {
    var track = localTracks[trackName];
    if(track) {
      track.stop();
      track.close();
      localTracks[trackName] = undefined;
    }
  }
 
  // remove remote users and player views
  remoteUsers = {};
  $("#remote-playerlist").html("");
 
  // leave the channel
  await client.leave();
 
  $("#local-player-name").text("");
  $("#join").attr("disabled", false);
  $("#leave").attr("disabled", true);
  console.log("client leaves channel success");
}
 
async function subscribe(user, mediaType) {
  const uid = user.uid;
  // subscribe to a remote user
  await client.subscribe(user, mediaType);
  console.log("subscribe success");
  if (mediaType === 'video') {
    const player = $(`
      &lt;div id="player-wrapper-${uid}"&gt;
        &lt;p class="player-name"&gt;remoteUser(${uid})&lt;/p&gt;
        &lt;div id="player-${uid}" class="player"&gt;&lt;/div&gt;
      &lt;/div&gt;
    `);
    $("#remote-playerlist").append(player);
    user.videoTrack.play(`player-${uid}`);
  }
  if (mediaType === 'audio') {
    user.audioTrack.play();
  }
}
 
function handleUserPublished(user, mediaType) {
  const id = user.uid;
  remoteUsers[id] = user;
  subscribe(user, mediaType);
}
 
function handleUserUnpublished(user) {
  const id = user.uid;
  delete remoteUsers[id];
  $(`#player-wrapper-${id}`).remove();
}
</code></pre><h2>运行效果</h2>
<p>通过本地浏览器开两个 tab 运行网页，使用两个用户加入同一个频道，如果在每个 Tab 页中能看见两个视频源，说明你集成成功了。
<img src="https://img-blog.csdnimg.cn/d8bf2ca32d1d4b0592b7e777b33e7fd5.png" alt="在这里插入图片描述"></p>
<h2>完整代码工程下载</h2>
<p><a href="https://download.agora.io/sdk/release/Agora_Web_SDK_v4_14_0_FULL.zip">https://download.agora.io/sdk/release/Agora_Web_SDK_v4_14_0_FULL.zip</a></p>
<hr>
<p>以上就是基于声网 Web SDK 实现一对一视频通话的全部内容。有问题欢迎到「RTE 开发者社区」<a href="https://www.agora.io/cn/community/">https://www.agora.io/cn/community/</a> 交流吐槽。</p>







标题：使用hel-micro制作远程antd、tdesign-react
作者：fantasticsoul
发布日期：发布于 7 个月前
文章内容：<p><a href="https://github.com/tnfe/hel"><strong>hel-micro</strong></a>，模块联邦sdk化，免构建、热更新、工具链无关的微模块方案 ，欢迎关注与了解</p>
<h1>制作远程react图形组件库</h1>
<p>使用hel-micro模块联邦技术sdk化方案，基于<a href="https://github.com/hel-eco/hel-tpl-remote-react-comp-ts">react组件模板</a>制作远程<a href="https://ant.design/components/overview-cn/">antd</a>库（<a href="https://github.com/hel-eco/hel-antd">hel-antd</a>）、远程<a href="https://tdesign.tencent.com/react/overview">tdesign-react</a>库（<a href="https://github.com/hel-eco/hel-tdesign-react">hel-tdesign-react</a>）。</p>
<blockquote>
<p>hel-antd、hel-tdesign-react 两者制作过程完全一样，区别仅是安装的库不同，你可以参考此文将其他优秀的<code>react</code>图形组件库制作为对应的远程库，以下步骤以制作 hel-antd 为主。</p>
</blockquote>
<p>传统的react图形组件库导入方式，多项目升级时很麻烦：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ee455457684ec6b4537954825fb62c~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>基于hel-micro提升为远程库后，被其他项目使用时，实际运行逻辑不参与项目打包，可以做到使用方无感知动态升级（顺带也降低了项目打包体积，并提高编译速度），以antd为例，假如你有5个项目用到了antd2.20，某一天暴露出2.20存在了一个严重bug，官方升级到了2.21版本，这时候你需要把你的5个项目全部安装一下最新的antd版本并重新部署一遍，而如果是引用的hel-antd，就只需要基于2.21版本重新发布一下hel-antd即可，所用使用方就可以运行最新版本的antd了。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b842ead3542c4682bea0e353c4d27410~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<p>基于代理对象技术使用方可以像使用本地antd一样使用远程antd、远程tdesign-react，见在线示例：<a href="https://codesandbox.io/s/hel-demo-use-antd-tjy3ep?file=/src/App.js:27-482">使用hel-antd</a>
、<a href="https://codesandbox.io/s/hel-demo-use-tedesign-nw8bfb?file=/src/App.js">使用hel-tdesign-react</a>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15c9451ee4184f4193b9d5a1ebae0d38~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<h2>克隆react模板库</h2>
<p>克隆react模板库，保存为<code>hel-antd</code>目录，接下来的步骤里，我们都将基于此目录下的文件改造</p>
<pre class="prettyprint language-bash"><code>git clone https://github.com/hel-eco/hel-tpl-remote-react-comp-ts.git hel-antd
</code></pre><blockquote></blockquote>
<h2>修改模块名称</h2>
<ul>
<li>修改<code>package.json</code>里的模块名称为<code>hel-antd</code></li>
</ul>
<pre class="prettyprint language-diff"><code>- "name": "hel-tpl-remote-react-comps-ts",
- "appGroupName": "hel-tpl-remote-react-comps-ts",
+ "name": "hel-antd",
+ "appGroupName": "hel-antd",
</code></pre><ul>
<li>修改项目里 <code>src/configs/subApp.ts</code> 的 <code>LIB_NAME</code> 为 <code>hel-antd</code>（如不修改，构建时会报模块名不一致错误）</li>
</ul>
<pre class="prettyprint language-diff"><code>- export const LIB_NAME = 'hel-tpl-remote-react-comps-ts';
+ export const LIB_NAME = 'hel-antd';
</code></pre><blockquote>
<p>可根据需要修改为自己想要的命名，此处仅为示例</p>
</blockquote>
<h2>安装antd</h2>
<p>此处我们基于<code>4.23.4</code>版本的antd构建远程antd库</p>
<pre class="prettyprint language-bash"><code>npm i antd@4.23.4
</code></pre><h2>导出antd模块</h2>
<p>导出antd模块主要包含2个部分，</p>
<ul>
<li>导出<strong>运行时代码</strong>供<code>webpack</code>打包用，方便<code>hel-micro</code>可以动态拉取已构建的运行代码</li>
<li>导出<strong>代理对象</strong>供<code>rollup</code>打包用，方便使用方可以安装远程模块类型文件，并在文件头使用<code>import</code>静态导入远程模块</li>
</ul>
<h3>运行时代码导出</h3>
<p>我们先在<code>src/components</code>下导出我们想要暴露的远程组件</p>
<pre class="prettyprint language-diff"><code>- import HelloRemoteReactComp from './HelloRemoteReactComp';
- export {
-   HelloRemoteReactComp,
- }

+ import * as antd from 'antd';
+ export { default as TestExport } from './TestExport';
+ export default antd;
</code></pre><p>注意此处额外导出了一个<code>TestExport</code>组件，用于示范可以扩展原始<code>antd</code>库加入自己的新组件</p>
<pre class="prettyprint language-jsx"><code>function TestExport() {
  return &lt;span&gt;TestExport Component&lt;/span&gt;
};
TestExport.displayName = 'TestExport';
export default TestExport;
</code></pre><p>然后在<code>src/entrance/libProperties.ts</code>里合并导出模块（此合并逻辑也可在<code>src/components</code>里面处理），并同时暴露推导出的模块类型对象</p>
<pre class="prettyprint language-diff"><code>- import comps from 'components';
- export type LibProperties = typeof comps;
- export default comps;

+ import antd, { TestExport } from 'components';
+ const toExport = { ...antd, TestExport };
+ export type LibProperties = typeof toExport;
+ export default toExport;
</code></pre><h3>代理对象导出</h3>
<p><code>src/entrance/libTypes.ts</code>文件内容表示导出代理对象，对象的实际内容由使用方<code>hel-micro</code>模块的<code>preFetchLib</code>函数填充，如下面的一行也不修改也是没问题的</p>
<pre class="prettyprint language-ts"><code>import type { LibProperties } from './libProperties';
import { exposeLib } from 'hel-lib-proxy';
import { LIB_NAME } from 'configs/subApp';

export const lib = exposeLib&lt;LibProperties&gt;(LIB_NAME);
export type Lib = LibProperties;
export default lib;
</code></pre><p>但使用方只能使用default导出语法，而不能在文件头直接解构</p>
<pre class="prettyprint language-ts"><code>// ok
import antd from 'hel-antd';
const { Button } = antd;

// error
import  { Button } from 'hel-antd';
</code></pre><p>为了支持文件头直接解构的写法，我们需要调整<code>src/entrance/libTypes.ts</code>文件内容，单独导出<code>antd</code>的各个组件</p>
<pre class="prettyprint language-diff"><code>// 以下单个导出，支持 import { Button } from 'hel-antd'; 直接解构的语法
+ export const Affix = lib.Affix;
+ export const Alert = lib.Alert;
</code></pre><h2>引入样式文件</h2>
<p>在<code>src/index.ts</code>文件里导入antd的样式文件，因 hel-antd支持使用css变量自定义主题，所以导入的时调整后的样式文件（将原始css文件的关键颜色替换为css变量）</p>
<pre class="prettyprint language-diff"><code>import { libReady, isMasterApp } from 'hel-lib-proxy';
import { LIB_NAME } from './configs/subApp';
+ import './styles/theme.css';
+ import './styles/antd-style.css';
</code></pre><p>如不需要此功能，直接导入原始样式文件即可</p>
<pre class="prettyprint language-diff"><code>import { libReady, isMasterApp } from 'hel-lib-proxy';
import { LIB_NAME } from './configs/subApp';
+ import 'antd/dist/antd.css'
</code></pre><h2>打包与发布</h2>
<p>修改<code>package.json</code>里的<code>version</code>版本号为<code>1.0.0</code>，运行build命令打包</p>
<pre class="prettyprint language-bash"><code>npm run build
</code></pre><p>运行publish命令发布</p>
<pre class="prettyprint"><code>npm publish
</code></pre><p>发布成功后，可以访问unpkg链接获取元数据验证是否已发布到cdn：</p>
<ul>
<li>
<p>js入口文件 <a href="https://unpkg.com/hel-antd">https://unpkg.com/hel-antd</a></p>
</li>
<li>
<p>元数据json描述文件 <a href="https://unpkg.com/hel-antd@1.0.0/hel_dist/hel-meta.json">https://unpkg.com/hel-antd@1.0.0/hel_dist/hel-meta.json</a></p>
</li>
</ul>
<h2>使用远程antd</h2>
<p>使用远程antd包括预加载远程模块和导入代理模块两个步骤</p>
<h3>预加载远程模块</h3>
<p>使用npm命令按照代理模块</p>
<pre class="prettyprint"><code>npm i hel-antd
</code></pre><p>入口文件后移，绑定react公共对象，预加载<code>hel-antd</code>，让远程模块的实际运行代码通过<code>hel-micro</code>填充到代理模块里</p>
<pre class="prettyprint language-ts"><code>import { preFetchLib, bindReactRuntime } from "hel-micro";
import React from "react";
import ReactDOM from "react-dom";
import ReactIs from "react-is";

bindReactRuntime({ React, ReactDOM, ReactIs });

async function main() {
  // 预加载远程模块 ，例如 hel-antd
  await preFetchLib("hel-antd", { enableDiskCache: true });
  await import("./loadApp"); // 你的原始入口文件
}

main().catch(console.error);
</code></pre><p><code>preFetchLib</code>默认总是拉取最新版本模块，如需运行时锁定版本号，透传版本号即可。</p>
<pre class="prettyprint language-ts"><code>  await preFetchLib("hel-antd", { enableDiskCache: true, versionId:'1.0.0' });
</code></pre><blockquote>
<p>此时可把版本号集中放后台某个地方管理（例如配置中心、自建的模块管控中心等），并统一下发到前端，就可以很方便的按需定制版本加载策略了。</p>
</blockquote>
<h3>导入代理模块</h3>
<p>接下来你可以在项目里除<strong>入口文件</strong>之外的其他任意文件想导入本地模块一样导入远程模块并使用了。</p>
<pre class="prettyprint language-tsx"><code>import { Button } from "hel-antd";

// render antd  Button
&lt;Button danger&gt;remote antd button&lt;/Button&gt;
</code></pre><p>新窗口访问在线示例：<a href="https://codesandbox.io/s/hel-demo-use-antd-tjy3ep?file=/src/App.js:27-482">使用hel-antd</a>
、<a href="https://codesandbox.io/s/hel-demo-use-tedesign-nw8bfb?file=/src/App.js">使用hel-tdesign-react</a></p>
<h2>自定义cdn</h2>
<p>hel-micro默认采用的是<code>unpkg</code>文件cdn服务，如有自建的<code>unpkg</code>私服，可调整打包策略注入自己的cdn服务前缀，只需要修改<code>config/subApp.js</code>即可</p>
<pre class="prettyprint language-diff"><code>- const subApp = helDevUtils.createReactSubApp(pkg, { npmCdnType: 'unpkg' });
+ const subApp = helDevUtils.createReactSubApp(pkg, { npmCdnType: 'unpkg', homePage: 'http://my-unpkg.com' });
</code></pre><blockquote>
<p>自建npm+unpkg私服可参考<a href="https://github.com/tnfe/hel/issues/19">issue 19</a></p>
</blockquote>
<h2>结语</h2>
<p>使用<code>hel-micro</code>，可以用极低的代价来铺开模块联邦技术，优势见往期文章<a href="https://juejin.cn/post/7138792768234586148">hel-micro 模块联邦新革命</a>，欢迎了解与使用^_^</p>
<hr>
<p>附：我的其他开源作品友链（欢迎关注与了解）：</p>
<p><a href="https://github.com/concentjs/concent">concent</a>，一个自带依赖收集、提供setup特性的react数据流方案</p>
<p><a href="https://github.com/tnfe/limu">limu</a>，一个比immer更高效的js不可变操作库</p>







标题：独立开发者工具：electron-egg桌面软件开发框架，基于node.js
作者：wallace5303
发布日期：发布于 7 个月前
文章内容：<p>过去两年，我做两个项目：
1：小明云存储，可以理解为一个聚合图床。
2：GitHub阅读器，利用GitHub1s，可以方便的阅读GitHub项目源码。</p>
<p>但因为种种原因，软件没有达到我预期效果。</p>
<p>后来把用到的技术做成了一个开源框架，反而有了不少用户。</p>
<p>框架名称是：electron-egg，一个桌面软件开发框架。</p>
<p>想做桌面软件的独立开发者，可以尝试一下
<img src="https://wallace5303.gitee.io/ee/images/electron-egg/mac-socket.png" alt=""></p>
<p>项目地址：
●  gitee： <a href="https://gitee.com/wallace5303/electron-egg">https://gitee.com/wallace5303/electron-egg</a>
●  github： <a href="https://github.com/wallace5303/electron-egg">https://github.com/wallace5303/electron-egg</a></p>







标题：【吃瓜】egg是倒闭了么？
作者：zy445566
发布日期：发布于 7 个月前
文章内容：<p><img src="//static.cnodejs.org/FrXepHv032txKQ06TUMbS1jctYiY" alt="image.png"></p>







标题：分享下腾讯云双11活动，轻量服务器很便宜，1年才几十块钱
作者：lovegnep
发布日期：发布于 5 个月前
文章内容：<p>轻量云服务器很适合新手来练手，1年50块钱左右吧，2核2G部署个nodejs服务足够了。
楼主部署了个nodejs服务用来视频转gif，目前感觉也没遇到什么问题
<a href="https://url.cn/EnyBkCb6">https://url.cn/EnyBkCb6</a>
<a href="https://url.cn/EnyBkCb6">【腾讯云】领&nbsp;11111元代金券大礼包，购后抽奖100%中奖，开团冲榜赢iPhone 14 Pro https://cloud.tencent.com/act/cps/redirect?redirect=2853&amp;cps_key=f4723c0e29795b85ed88a907176f4e4c&amp;from=console</a></p>
<p>另外消费138元就可以入会了<img src="//static.cnodejs.org/FivD4ywUgMcRkNd7Nx4C4GmCjBFY" alt="iShot_2022-11-06_21.03.57.png"></p>







标题：helux，一个鼓励服务注入的响应式react状态库
作者：fantasticsoul
发布日期：发布于 6 天前
文章内容：<h2>关于helux</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是一个鼓励服务注入，并支持响应式变更react的全新数据流方案，它的前身是<a href="https://github.com/concentjs/concent">concent</a>（一个类vue开发体验的高性能状态管理框架），但concent自身因为需要兼容class和function保持一致的语法，且为了对其<code>setup</code>功能，导致内部代码量实在太大，压缩后有<code>70</code>多kb，api暴露得也非常多，导致学习难度急剧上升，为了更符合现在非常流行的<code>DDD</code>围绕业务概念构建领域模型的编码趋势，<code>helux</code>一开始就设计为<code>鼓励服务注入</code>、<code>支持响应式变更</code>、<code>支持依赖收集</code>的轻量级react数据流方案。</p>
<p>它拥有以下优势：</p>
<ul>
<li>轻量，压缩后2kb</li>
<li>简单，仅暴露7个api，高频使用的仅<code>createShared</code>、<code>useObject</code>、<code>useSharedObject</code>、<code>useService</code>4个接口</li>
<li>高性能，自带依赖收集</li>
<li>响应式，支持创建响应式对象，在视图之外变更对象将同步更新视图</li>
<li>服务注入，配合<code>useService</code>接口轻松控制复杂业务逻辑，总是返回稳定的引用，可完全避免<code>useCallback</code>依赖烦扰了</li>
<li>状态提升0改动，所以地方仅需将<code>useObject</code>换为<code>useSharedObject</code>即可提升状态共享到其他组件</li>
<li>避免forwordRef 地狱，内置的<code>exposeService</code>模式将轻松解决父掉子时的<code>ref</code>转发晦涩理解问题和传染性（隔代组件需要层层转发）</li>
<li>ts友好，100% ts 编写，为你提供全方位类型提示</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88176d2bc14643e8b81d29fd72902a9d~tplv-k3u1fbpfcp-watermark.image?" alt="2.gif"></p>
<blockquote>
<p>该gif图和以下所有api均对应有在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>,欢迎fork并修改体验。</p>
</blockquote>
<p>为什么起名<code>helux</code>，虽然内心上我是把它作为<code>concent</code> v3版本去开发的，但因为它的变化实在太大，除了依赖收集不继承任何<code>concent</code>的特性，同时它也是伴随我开发的<a href="https://github.com/tnfe/hel">hel-micro</a>诞生一款作品，我期望它成为 hel-micro 生态的 luxury 级别的贡献，就将 hel-micro 和 luxury 两个词拼一起成为了 <code>helux</code>。</p>
<p>欢迎点星关注<a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>，它虽然较新，但已在我自己的使用场景中发挥功不可没的作用，现已加入hel-micro生态大仓，期待能成为你愿意挑选的一款可心数据流方案。</p>
<h2>快速上手</h2>
<p>极致的简单是helux最大的优势，了解以下6个api后，你可以轻松应付任何复杂场景，最大的魅力在于<code>useSharedObject</code>和<code>useService</code>两个接口，且看如下api介绍，或访问在线<a href="https://codesandbox.io/s/demo-show-service-dev-mode-ikybly?file=/src/App.tsx">示例1</a>和<a href="https://codesandbox.io/p/sandbox/use-service-to-replace-ref-e5mgr4?file=%2Fsrc%2FApp.tsx">示例2</a>fork并修改来体验。</p>
<h3>useObject</h3>
<p>使用 useObject 有两个好处</p>
<ul>
<li>1 方便定义多个状态值时，少写很多 useState</li>
<li>2 内部做了 unmount 判断，让异步函数也可以安全的调用 setState，避免 react 出现警告 :
“Called SetState() on an Unmounted Component” Errors</li>
</ul>
<pre class="prettyprint language-ts"><code>// 基于对象初始化一个视图状态
const [state, setState] = useObject({a:1});
// 基于函数初始化一个视图状态
const [state, setState] = useObject(()=&gt;({a:1}));
</code></pre><h3>useForceUpdate</h3>
<p>强制更新当前组件视图，某些特殊的场景可以使用它来做视图重刷新</p>
<pre class="prettyprint language-ts"><code>const forUpdate = useForceUpdate();
</code></pre><h3>createSharedObject</h3>
<p>创建一个共享对象，可透传给 <code>useSharedObject</code>，具体使用见 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const sharedObj = createSharedObject({a:1, b:2});
// 基于函数初始化一个共享对象
const sharedObj = createSharedObject(()=&gt;({a:1, b:2}));
</code></pre><h3>createReactiveSharedObject</h3>
<p>创建一个响应式的共享对象，可透传给 useSharedObject</p>
<pre class="prettyprint"><code>// 初始化一个共享对象
const [reactiveObj, setState] = createReactiveSharedObject({a:1, b:2});

sharedObj.a = 111; // 任意地方修改 a 属性，触发视图渲染
setSharedObj({a: 111}); // 使用此方法修改 a 属性，同样也能触发视图渲染，深层次的数据修改可使用此方法
</code></pre><h3>createShared</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function createShared&lt;T extends Dict = Dict&gt;(
  rawState: T | (() =&gt; T),
  enableReactive?: boolean,
): {
  state: SharedObject&lt;T&gt;;
  call: &lt;A extends any[] = any[]&gt;(
    srvFn: (ctx: { args: A; state: T; setState: (partialState: Partial&lt;T&gt;) =&gt; void }) =&gt; Promise&lt;Partial&lt;T&gt;&gt; | Partial&lt;T&gt; | void,
    ...args: A
  ) =&gt; void;
  setState: (partialState: Partial&lt;T&gt;) =&gt; void;
};
</code></pre><p>创建一个响应式的共享对象，可透传给 useSharedObject，它是<code>createReactiveSharedObject</code>和<code>createSharedObject</code>的结合体，当需要调用脱离函数上下文的服务函数时（即不需要感知组件props时），可使用该接口，第二位参数为是否创建响应式状态，为 true 时效果同 <code>createReactiveSharedObject</code> 返回的 sharedObj</p>
<pre class="prettyprint"><code> const ret = createShared({ a: 100, b: 2 });
 const ret2 = createShared({ a: 100, b: 2 }, true); // 创建响应式状态
 // ret.state 可透传给 useSharedObject
 // ret.setState 可以直接修改状态
 // ret.call 可以调用服务函数，并透传上下文
</code></pre><p>以下将举例两种具体的定义服务函数的方式，之后用户便可在其他其他地方任意调用这些服务函数修改共享状态了，如需感知组件上下文，则需要用到下面介绍的<code>useService</code>接口去定义服务函数。</p>
<pre class="prettyprint"><code>// 调用服务函数第一种方式，直接调用定义的函数，配合 ret.setState 修改状态
function changeAv2(a: number, b: number) {
   ret.setState({ a, b });
}
*
// 第二种方式，使用 ret.call(srvFn, ...args) 调用定义在call函数参数第一位的服务函数
function changeA(a: number, b: number) {
   ret.call(async function (ctx) { // ctx 即是透传的调用上下文，
     // args：使用 call 调用函数时透传的参数列表，state：状态，setState：更新状态句柄
     // 此处可全部感知到具体的类型
     // const { args, state, setState } = ctx;
     return { a, b };
   }, a, b);
 }
</code></pre><h3>useSharedObject</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>function useSharedObject&lt;T extends Dict = Dict&gt;(sharedObject: T, enableReactive?: boolean): [
  SharedObject&lt;T&gt;,
  (partialState: Partial&lt;T&gt;) =&gt; void,
]
</code></pre><p>接收一个共享对象，多个视图里将共享此对象，内部有依赖收集机制，不依赖到的数据变更将不会影响当前组件更新</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
</code></pre><p><code>useSharedObject</code>默认返回非响应式状态，如需要使用响应式状态，透传第二位参数为true即可</p>
<pre class="prettyprint language-ts"><code>const [ obj, setObj ] = useSharedObject(sharedObj);
// now obj is reactive
 setInterval(()=&gt;{
  state.a = Date.now(); // 触发视图更新
 }, 2000);
</code></pre><h3>useService</h3>
<p>函数签名</p>
<pre class="prettyprint"><code>/**
 * 使用用服务模式开发 react 组件：
 * @param compCtx
 * @param serviceImpl
 */
function useService&lt;P extends Dict = Dict, S extends Dict = Dict, T extends Dict = Dict&gt;(
  compCtx: {
    props: P;
    state: S;
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
  },
  serviceImpl: T,
): T &amp; {
  ctx: {
    setState: (partialState: Partial&lt;S&gt;) =&gt; void;
    getState: () =&gt; S;
    getProps: () =&gt; P;
  };
}
</code></pre><p>它可搭配<code>useObject</code>和<code>useSharedObject</code>一起使用，会创建服务对象并返回，该服务对象是一个稳定的引用，且它包含的所有方法也是稳定的引用，可安全方法交给其它组件且不会破会组件的pros比较规则，避免烦恼的<code>useMemo</code>和<code>useCallback</code>遗漏相关依赖</p>
<p>搭配<code>useObject</code>时</p>
<pre class="prettyprint language-ts"><code>function DemoUseService(props: any) {
  const [state, setState] = useObject({ a: 100, b: 2 );
  // srv本身和它包含的方法是一个稳定的引用，
  // 可安全的将 srv.change 方法交给其它组件且不会破会组件的pros比较规则
  const srv = useService({ props, state, setState }, {
    change(a: number) {
      srv.ctx.setState({ a });
    },
  });
  
  return &lt;div&gt;
    DemoUseService:
    &lt;button onClick={() =&gt; srv.change(Date.now())}&gt;change a&lt;/button&gt;
  &lt;/div&gt;;
}
</code></pre><p>搭配<code>useSharedObject</code>时，只需替换<code>useObject</code>即可，其他代码不用做任何改变</p>
<pre class="prettyprint language-diff"><code>+ const sharedObj = createSharedObject({a:100, b:2})

function DemoUseService(props: any) {
-  const [state, setState] = useObject({ a: 100, b: 2 );
+  const [state, setState] = useSharedObject(sharedObj);
</code></pre><h4>getState 和 getProps</h4>
<p>因 <code>state</code> 和 <code>props</code> 是不稳定的，所以服务内部函数取的时候需从<code>srv.ctx.getState</code>或<code>srv.ctx.getProps</code></p>
<pre class="prettyprint language-ts"><code>// 抽象服务函数
export function useChildService(compCtx: {
  props: IProps;
  state: S;
  setState: (partialState: Partial&lt;S&gt;) =&gt; void;
}) {
  const srv = useService&lt;IProps, S&gt;(compCtx, {
    change(label: string) {
      // !!! do not use compCtx.state or compCtx.state due to closure trap
      // console.log("expired state:", compCtx.state.label);

      // get latest state
      const state = srv.ctx.getState();
      console.log("the latest label in state:", state.label);
      // get latest props
      const props = srv.ctx.getProps();
      console.log("the latest props when calling change", props);

      // your logic
      compCtx.setState({ label });
    }
  });
  return srv;
}

export function ChildComp(props: IProps) {
  const [state, setState] = useObject(initFn);
  const srv = useChildService({ props, state, setState });
}

 return (
    &lt;div&gt;
      i am child &lt;br /&gt;
      &lt;button onClick={() =&gt; srv.change(`self:${Date.now()}`)}&gt;
        change by myself
      &lt;/button&gt;
      &lt;h1&gt;{state.label}&lt;/h1&gt;;
    &lt;/div&gt;
  );
</code></pre><h4>exposeService</h4>
<p>当孩子组件props上透传了<code>exposeService</code>函数时，<code>useService</code> 将自动透传服务对象给父亲组件，是一种比较方便的逃离<code>forwardRef</code>完成父调子的模式</p>
<pre class="prettyprint language-ts"><code>import { ChildSrv, Child } from "./Child";

function App() {
  // 保存孩子的服务
  const childSrv = React.useRef&lt;{ srv?: ChildSrv }&gt;({});
  const seeState = () =&gt; {
    console.log("seeState", childSrv.current.srv?.ctx.getState());
  };

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; childSrv.current.srv?.change(`${Date.now()}`)}&gt;
        call child logic
      &lt;/button&gt;
      &lt;Child
        unstableProp={`${Date.now()}`}
        exposeService={(srv) =&gt; (childSrv.current.srv = srv)}
      /&gt;
    &lt;/div&gt;
  );
}
</code></pre><h2>结语</h2>
<p><a href="https://github.com/tnfe/hel/tree/main/packages/helux">helux</a>是把<a href="https://github.com/concentjs/concent">concent</a>内部精华全部萃取提炼再加工后的全新作品，期望能得到你的喜欢与鼓励。❤️</p>







标题：fabric.js开发图片编辑器可以实现哪些功能？多图
作者：nihaojob
发布日期：发布于 6 天前
文章内容：<p>最近使用fabric.js开发了一个图形编辑器并开源了，已收到900+star，<strong>很多开发者咨询fabric.js能实现哪些功能</strong>，今天就用文字加动图的形式直观的分享出来，帮助大家做参考。</p>
<p>fabric.js 提供强大的底层能力，可实现<strong>自定义模板、素材、字体，图片滤镜、辅助线、组合、裁剪等功能，也提供了自定义元素等高级的用法</strong>。</p>
<p>项目：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a></p>
<p>预览：<a href="https://nihaojob.github.io/vue-fabric-editor/#/">https://nihaojob.github.io/vue-fabric-editor/#/</a></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89169a52052245839413826e3a9b9ac0~tplv-k3u1fbpfcp-watermark.image?" alt="screenshot-20230415-142257.png"></p>
<h2>画布功能</h2>
<p><strong>画布属性：尺寸、预设大小、背景色。</strong>
支持修改画布尺寸，也有预常用预设的画布尺寸，可以便捷设置，有背景色修改属性，同时提供常用颜色的快捷修改。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/044e2d09049f489f9341263862674fb9~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415120741_rec_.gif"></p>
<p><strong>画布缩放：放大、缩小、自动适应、鼠标滚轮缩放。</strong>
支持画布放大缩小操作，可按照1:1尺寸展示或自适应展示，页面窗口改变时会根据窗口大小自适应展示；滑动鼠标滚轮时可快捷缩放画布。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6950ef15074c494e9d277a5b46c2c9f2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415121804_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570f0c1bb2434593949b65234972f1b4~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122049_rec_.gif"></p>
<p><strong>其他细节：拖拽画布、画布区域外显示控制条。</strong>
画布支持拖拽操作，按住alt快捷键，可以拖动画布；当元素拖拽到画布外区域时，仍然展示控制条，但元素并不会被展示出来，所见即所得。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b050ef702a4449dbce41b27a525a7e2~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415122246_rec_.gif"></p>
<h2>辅助功能</h2>
<p><strong>控制条：</strong> 在满足元素缩放、旋转的基础上尽量让其简洁，提供了2种样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69bba9a276e24db99653513bafb23f75~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123406_rec_.gif"></p>
<p><strong>标尺：</strong> 标尺与辅助线可以满足我们更高要求的设计场景。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3489af30b75e4ecdbd037f7dddfbd10a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415123622_rec_.gif"></p>
<p><strong>快捷调整：</strong> 图层管理、右键菜单、快捷键。
图层可以直观的定位元素的层级顺序，右键菜单提供了常用的快捷功能，还支持复制、删除等快捷键操作，提高操作效率。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b2176cb3e4ce0bc973d27cd58d705~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415125124_rec_.gif"></p>
<h2>基础元素</h2>
<p><strong>字体元素：</strong> 字体元素有普通字体、框字体，框字体可调整外边框，自动换行。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2dd53747534bbba5273787cced287a~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130158_rec_.gif"></p>
<p><strong>基础形状：</strong> 有矩形、圆形、三角形、多边形，可直接点击或拖拽添加到画布。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa5a10f62049cdbd7a6f0d10760e29~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130303_rec_.gif"></p>
<p><strong>线条元素：</strong> 支持箭头、线条元素绘制。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1209cdaee70b4f38b7eef8987d6d676d~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131152_rec_.gif"></p>
<p><strong>插入元素：</strong> 支持插入多种图片类型，图片图片、SVG元素、SVG字符串。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba18715bb24d46719d8883a90d127152~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415130901_rec_.gif"></p>
<p><strong>自定义素材：</strong> 素材在左侧分类展示，可定义图片素材、字体样式素材。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97231aaa1f145f1965c1a7ee935e442~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131012_rec_.gif"></p>
<h2>文件功能</h2>
<p><strong>数据保存：</strong> 支持导出/导出JSON文件方便存储数据，可自定义设计模板。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff449fe3b9b4f08b5e51f5072b164ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131754_rec_.gif"></p>
<p><strong>图片保存：</strong> 可清空画布、预览图片、保存图片文件。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9b6eef8f2d46a284acccaa15710f39~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415131852_rec_.gif"></p>
<h2>属性设置</h2>
<p><strong>基础操作：</strong> 所有元素都可以在属性面板调整透明度、坐标、旋转角度。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457b96af734d4a03bfeb003de4d04865~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133918_rec_.gif"></p>
<p><strong>锁定与组合：</strong> 锁定元素后元素将不会收到其他操作影响；可将多个元素组合为一个组元素，也可以将组元素拆分为多个元素。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d836659d849d0ba115a5ec2e3b959~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132328_rec_.gif"></p>
<p><strong>元素对齐：</strong> 单个元素支持相对于画布的水平、垂直、水平垂直居中，多个元素支持上、下、左、右对齐，水平居中、垂直居中、垂直平均分布、水平平均分布功能。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71eae7cab77489d8ffb51edb3c66f11~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415132516_rec_.gif">
**自定义字体：**可自定义字体、对齐方式、行高、背景色、下划线、删除线等信息。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eae4c5d03474d28b25fa64e82ef87e4~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>渐变配置：</strong> 渐变是设计的重要形式之一，支持为元素、字体设置渐变颜色。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf12add8983481cb2a11bcd0a33614e~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p><strong>边框设置：</strong> 支持为元素增加边框样式。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349ce94cbc0f4aae99ec59d72ea73346~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415134137_rec_.gif"></p>
<p><strong>图片操作：</strong> 快捷替换、简单滤镜、复杂滤镜。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4998294d7f11404fad58321bfb4f22ae~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133617_rec_.gif"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21f01ec7ccd40458693d0e0b8cb43a7~tplv-k3u1fbpfcp-zoom-1.image" alt="20230415133505_rec_.gif"></p>
<h2>总结</h2>
<p>fabric.js 的底层能力非常强大，这依赖于灵活的底层接口，但是太过灵活也有一个弊端，那就是我们必须掌握更多的细节才能用起来得心应手，这对于开发者来说并不会太轻松。</p>
<p><a href="https://github.com/nihaojob/vue-fabric-editor">vue-fabric-editor</a>项目致力于打造一个开箱即用的web图片编辑器应用，同时<strong>沉淀一个介于web图片编辑器应用与fabric.js之间的封装层</strong>，期望封装层面向开发者设计，<strong>提供更简单的接口，让开发者可以轻松的实现图片应用开发</strong>。</p>
<h2>邀请</h2>
<p>通过技术社区和开源的方式和大家相识是一种很奇妙的体验，大部分都是在使用fabric.js做项目的开发者，我们组建了fabric.js开发者交流群，一起抱团取暖互相支招，一边吐槽文档，一起实现功能，欢迎你的加入交流群。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e358ff17a16e4f6e946291c7beeac0d4~tplv-k3u1fbpfcp-watermark.image?" alt="WechatIMG391.jpeg"></p>
<p>我们离目标还有很长的距离，如果你对这件事情感兴趣，真诚的邀请你加入，我们一起沉淀fabric.js的最佳实践，<strong>你会得到包括不限于以下列表的收获，你只要会简单的Git和Javascript语法就可以</strong>。</p>
<ul>
<li>熟悉开源协作方式，成为项目贡献者。</li>
<li>Vue3 + TS实践，边学边开发。</li>
<li>fabric.js开发，边学边开发。</li>
<li>入门单元测试，边学边开发。</li>
<li>众多的fabric.js开发者交流。</li>
</ul>
<p>我自己是第一次搞开源项目，感谢项目的贡献者的帮助和社区的推动，<strong>这是一个很新的项目和社区，期待你的加入，希望我们一起边走边学，在未来一起成为知名开源项目的开发者</strong>。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d96501901c48c8ba76d6a64ca4a185~tplv-k3u1fbpfcp-watermark.image?" alt="海报.png"></p>







标题：聊聊 WebCodecs 实现 GIF 视频转码
作者：kinglisky
发布日期：发布于 8 天前
文章内容：<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d9d33079b840e3aa3d7d0b603139eb~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp?" alt=""></p>
<p>被裁了，最近在摸鱼写文档，这两天研究了下浏览器环境下摆脱 ffmpeg.wasm 实现 GIF 转视频的功能，现在浏览器提供的 API 越来越靠近底层，浏览器在发展个几年可能真没 Electron 啥事了 [狗头] 。</p>
<p>不重复发文了，发掘金了：<a href="https://juejin.cn/post/7221557738537549879">聊聊 WebCodecs 实现 GIF 视频转码</a></p>
<p>欢迎大佬们指教~</p>







标题：自己开发了编程课程搜索的小程序，基本慕课网的课程都能搜到
作者：mikfake
发布日期：发布于 9 天前
文章内容：<p>小程序使用uniapp开发，后端使用java。因为实后端java开发，前端不擅长，有一些地方写的不是很合理。不过主要目的还是分享免费的编程课程。正在找编程资源的可以看看，可能你要的就能搜到，每天都会更新一些资源。
<img src="//static.cnodejs.org/FmBeKhXk1La4M-1xzwnIiLRZq_Ip" alt="素材1.png">
<img src="//static.cnodejs.org/FgF93KX8qwHSlleM5X6Gmug5RFo2" alt="素材2.png">
<img src="//static.cnodejs.org/Fo3cR9S0MO2OPOBe9X1Mhb7M7GXg" alt="素材3.png">
<img src="//static.cnodejs.org/FnMtv4MbZU0NRrn1Q8Ql1gRYJDCc" alt="素材4.png">
<img src="//static.cnodejs.org/Fl4_GBEs_KDU3A8PzuqpHtym9FFg" alt="二维码.jpg"></p>







标题：NodeJS+Sequelize在生产环境下，最合适的建立连接池的方式是？
作者：monkeytwins
发布日期：发布于 15 天前
文章内容：<p>看官网文档里提到关于多进程的情况下，必须为每一个进程都创建sequelize实例：</p>
<blockquote>
<p>If you’re connecting to the database from multiple processes, you’ll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected.</p>
</blockquote>
<p>生产环境下，肯定是多负载多进程的情况，并且一般用cluster模块去进行进程处理</p>
<pre class="prettyprint language-js"><code>if (cluster.isMaster) {
    for (var i = 0; i &lt; env.CPU; i++) {
        cluster.fork();
    }

    cluster.on('fork', worker =&gt; {
        log(`worker ${worker.process.pid} forked success`, 'info', logOptions);
    });

    cluster.on('online', worker =&gt; {
        log(`worker ${worker.process.pid} responded after it was forked`, 'info', logOptions);
    });

    cluster.on('exit', function (worker, code, signal) {
        log(`worker ${worker.process.pid} died (${signal || code})`, 'warn', logOptions);
        cluster.fork();
    });
} else {
    require('../app.js');
}
</code></pre><p>想请教下这种情况下，Sequelize的实例初始化应该在什么阶段？</p>







标题：last-cjs-version 方便使用cjs 版本 sindresorhus 的包
作者：magicdawn
发布日期：发布于 6 个月前
文章内容：<p>越来越多模块在迁移到 <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">esm</a>, like execa, got, globby, zx …
但是如果项目本身是 cjs, 需要使用 dynamic import <code>import()</code> 函数来使用 esm
这个模块可以找到最后更新的 commonjs 版本, 要不然得去人肉去翻 changelog / release note 才能确定
<a href="https://github.com/magicdawn/last-cjs-version">https://github.com/magicdawn/last-cjs-version</a></p>
<pre class="prettyprint language-sh"><code>$ last-cjs-version execa
5.1.1

$ last-cjs-version got
11.8.3

$ last-cjs-version execa -m
5

$ echo pnpm add execa@`last-cjs-version -m execa`
pnpm add execa@5

# this will exec 'pnpm add execa@5'
$ pnpm add execa@`last-cjs-version -m execa`
</code></pre><p>以上.</p>







标题：虚拟化服务，JS服务架构的未来
作者：zy445566
发布日期：发布于 6 个月前
文章内容：<p>由于近两年一直在从事serverless系统的开发，本篇文章算是在未来serverless开发方向的一些心得，对这套开发模式未来的一些走向提供一些自己的所见所想，也基于目前过于传统的serverless的实现在表达不满的同时，自己也重写做了一些实现以及在项目中的一些工程化的实践，得出一些结论和大家共享。当然毕竟一千个人的眼里就有一千个哈姆雷特，所以意见不同请轻喷，感谢。</p>
<h1>序言</h1>
<p>在双逢干涉中，我们有理由怀疑这个世界的真实性。在docker诞生后，我们可以虚拟化当前的环境。那么如果实现一个让代码层面就直接实现虚拟化，是不是有点意思？</p>
<h1>虚拟化-核心</h1>
<p>核心作为实现node.js虚拟化的第一步，我们要有各种欺骗代码的一些技巧。比如为每块代码都提供出对应的容器,而对于容器而言需要虚拟的部分主要在于虚拟module和process以及一个重写过的require。大致结构如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8c0af2234c49bb9778b92ab8ed5c9e~tplv-k3u1fbpfcp-watermark.image?" alt="app.png"></p>
<p>虚拟的module的主要作用是打断和宿主module的联系，也就是说在虚拟容器中发生的引用可能对于宿主module来说根本就没有发生过。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ac2d61dd7a430fb12bc1aea3fb1cab~tplv-k3u1fbpfcp-watermark.image?" alt="module.png"></p>
<p>虚拟process的目的是让虚拟环境对process的修改只对自己生效，而不会影响到宿主环境的process，即是环境变量方向的一种欺骗。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e618673e168f4dadbe1048e573d5fbc2~tplv-k3u1fbpfcp-watermark.image?" alt="proxy.png"></p>
<p>重写的require目的和虚拟module的区别主要是实现对系统模块或第三方模块或引用路径的重写或权限限制。比如不允许你引用当前目前外的代码，再比如就是重写fs模块，让你读取的文件表明是在服务器而实质是可能是某个分布式数据库中。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4abf53eece7c4d5c80e9a5c94e8acf9e~tplv-k3u1fbpfcp-watermark.image?" alt="file.png"></p>
<p>源代码传送门: <a href="https://github.com/virtual-less/vaas-core">https://github.com/virtual-less/vaas-core</a></p>
<h1>虚拟化-服务框架</h1>
<p>有了核心，我想是时候跟目前传统的微服务架构和函数即服务再见了，首先我们要有更加优雅的实现。</p>
<ul>
<li>是时候跟使用仓库隔离来防止引用说再见了👋 我们可以直接在引用层拦截 ✅</li>
<li>是时候跟callback和ctx.body={…}这种丑陋的写法说再见了👋 我们直接用return返回数据，throw抛出异常✅</li>
<li>是时候跟中心化路由这种集中化配置导致易发冲突的方式说再见了👋 我们直接用装饰器的去中心化路由实现【具体如下个例子】✅</li>
</ul>
<pre class="prettyprint language-ts"><code>import {VaasServerType, Decorator } from 'vaas-framework'
export default class Hello {
    @Decorator.VassServer({type:'http',method:'get',routerName:'/hello'})
    async hello({req,res}:VaasServerType.HttpParams) {
        return {
            hello:'world'
        }
    }
}
</code></pre><p>以上是虚拟化服务框架中最简单的代码例子，这里代表了在/hello/hello中能返回{hello:‘world’}的结果。其中：</p>
<ul>
<li>每一个变量有拥有其变量提示</li>
<li>路由通过装饰器VassServer来配置，同时支持另外两种类型rpc和websocket</li>
<li>通过return返回数据，通过throw来抛出Error类型异常</li>
</ul>
<p>既然作为使用虚拟化框架，也就意味着不同的APP不能相互实现阻塞和相互的影响，所以在架构实现上对于每个App都支持配置多线程数量，且每个多线程中使用vm进行对应的虚拟化工作。同时依托于线程池控制，即可实现多个请求复用worker。而每个App的代码非常巧妙在worker中进行了缓存且被不断的使用，直到长期无请求导致worker过期回收。具体架构如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23683883506e43f1b5c0f2260b6274cf~tplv-k3u1fbpfcp-watermark.image?" alt="vass-framework.png"></p>
<p>这个架构之下还有一个好处就是不需要过度关心内存泄漏问题，因为单次请求结束且超时时间外没有新连接则默认释放内存，这个模式类似PHP，但是和PHP不同点为不会马上释放，且可以复用多线程的模式。</p>
<p>如果想要体验，可以使用npm的初始化脚本进行体验(系统需要支持git且需要在命令行中翻墙，win系统请谨慎尝试)</p>
<pre class="prettyprint language-sh"><code>npm init vaas
</code></pre><p>源代码传送门: <a href="https://github.com/virtual-less/vaas-framework">https://github.com/virtual-less/vaas-framework</a></p>
<h1>虚拟化-服务平台</h1>
<p>光有框架，我觉得还是远远不够的，所以我决定使用框架作为底层提供出一个为私有企业定制的一套部署平台，也就是说你可以直接在这个平台上部署一些虚拟化的App，同时可以支持直接在平台上实现App相关的配置。也就是说这个服务平台的作用是当框架开发完成若干APP，可以直接使用这个平台来管理APP并实现动态部署，让开发和发布更加简单。同时这个平台也是基于<code>虚拟化-服务框架</code>进行开发的一个APP。</p>
<p>目前服务平台使用了ETCD作为配置中心来实现APP配置和部署配置。并实现了配置界面：</p>
<p>App配置主要用于限制对代码的一些权限配置和性能限制，比如不希望代码读文件则可以不添加fs模块权限。如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e836641df07a46698f72348c8d5b6b11~tplv-k3u1fbpfcp-watermark.image?" alt="appConfig.png"></p>
<p>域名配置主要用于当我们需要域名直接打到app时做的一些域名上的配置，这样访问就不需要还带有app路径。如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc59531f1c5943a88b8824aa20d33889~tplv-k3u1fbpfcp-watermark.image?" alt="hostConfig.png"></p>
<p>在使用ETCD作为平台配置组件时，中间发生了一个小插曲，在使用ETCD的时候搜索了一圈居然没有支持ETCD3.5以上的npm包😂，所以顺手简单整合封装了一波。</p>
<p>源代码传送门: <a href="https://github.com/zy445566/netcd">https://github.com/zy445566/netcd</a></p>
<p>同时使用S3文件服务的完全实现minio来作为代码文件服务的管理，包括我们需要发布一些APP也是执行<code>vaas deploy</code> 命令先上传到minio的服务上，并修改ETCD配置来完成部署。再由平台来通过校验本地代码和对比ETCD的代码地址区别来决定保证第一时间完成部署。具体架构如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc133b04ab7410d9498da0f7e043b60~tplv-k3u1fbpfcp-watermark.image?" alt="vaas-platform.png"></p>
<p>这个基本是一个最简化的serverless部署平台，实现了前后端，对于想要自己定制的，下面也开放的源码，按照自己企业要求修改即可。</p>
<p>源代码传送门:</p>
<p>后端: <a href="https://github.com/virtual-less/vaas-platform">https://github.com/virtual-less/vaas-platform</a></p>
<p>前端: <a href="https://github.com/virtual-less/vaas-platform-ui">https://github.com/virtual-less/vaas-platform-ui</a></p>
<h1>结语</h1>
<p>通过底层的虚拟化，开发层面上框架层，到最后使用层面的平台层，严格来说这其实是代码层面上的serverless的开源实现。但是比目前serveless平台来比较的话，更关注于个人或企业内部的使用，而不是对外开放使用。同时在代码使用方式和开放部署流程上的一些优化与提升。在服务架构上来说未来不一定说一定会朝着虚拟化这个方向前进，但一定会是一个必经之路。</p>







标题：记一次 Next.js 样式异常的排查与 pr 修复
作者：xiaoxiaojx
发布日期：发布于 6 个月前
文章内容：<p>原文地址: <a href="https://github.com/xiaoxiaojx/blog/issues/46">https://github.com/xiaoxiaojx/blog/issues/46</a></p>
<h2>问题简述</h2>
<p><img src="https://user-images.githubusercontent.com/23253540/199200650-85f5596d-66d8-45dd-8d4b-3c65071aaed6.png" alt="">
开发同学反馈 Next.js 项目 next dev 命令启动后浏览器访问页面 css 样式有丢失，表现为 style 标签的内容不是 css 样式而是一个 url 😨</p>
<pre class="prettyprint language-html"><code>&lt;style&gt;/_next/static/media/globals.23a96686.css&lt;/style&gt;
</code></pre><p>面对这个略显奇葩的问题该如何排查了 ?</p>
<h2>问题排查</h2>
<h3>Step1 确认是否配置了错误的 loader</h3>
<ul>
<li>分析: 给 css 文件设置错了 loader 造成结果不符合预期也说得过去</li>
<li>结论: ❌ 没有发现可疑的 loader, 经过查看 webpackConfig 发现会命中红圈 oneOf 数组索引为 6 的规则, 即 css 文件会依次被 postcss-loader &gt; css-loader &gt; next-style-loader 来依次处理, 看上去没有任何问题</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/23253540/199277342-3d4c27bf-f3c8-4f57-a7dd-27f4e0d662fd.png" alt=""></p>
<blockquote>
<p><a href="https://webpack.js.org/configuration/module/#ruleoneof">Rule.oneOf</a> : An array of Rules from which only the first matching Rule is used when the Rule matches.</p>
</blockquote>
<p>同时根据 Rule.oneOf 的定义确认了只会从 oneOf 数组中找到一个匹配到的规则就会停止, 那么 loader 应该是都被正确设置了</p>
<h3>Step2 处理 css 文件的 loader 有 bug ?</h3>
<ul>
<li>分析: 确认了没有奇怪的 loader 掺杂进来, 那么是不是命中的 loader 有 bug 了</li>
<li>结论: ✅ 果然有 bug</li>
</ul>
<p>loader 正常是按从下到上, 从右到左的顺序执行, 即如上配置会按从 postcss-loader &gt; css-loader &gt; next-style-loader 来依次处理。</p>
<pre class="prettyprint language-js"><code>// packages/next/build/webpack/loaders/next-style-loader/index.js

import path from 'path'
import isEqualLocals from './runtime/isEqualLocals'
import { stringifyRequest } from '../../stringify-request'

const loaderApi = () =&gt; {}

loaderApi.pitch = function loader(request) {
// ...
}

module.exports = loaderApi
</code></pre><p>但是由于 next-style-loader 导出了 pitch 属性, loader 的顺序将会变成首先运行 pitch 函数, 相关文档见 <a href="https://webpack.js.org/api/loaders/#pitching-loader">Pitching Loader</a></p>
<pre class="prettyprint language-bash"><code>|- next-style-loader `pitch`
      |- requested module is picked up as a dependency
    |- postcss-loader normal execution
  |- css-loader normal execution
|- next-style-loader normal execution
</code></pre><p>那么我们先从 next-style-loader 的 pitch 函数开始排查, 然后发现了如下语句</p>
<pre class="prettyprint language-js"><code>// packages/next/build/webpack/loaders/next-style-loader/index.js

var content = require(${stringifyRequest(this, `!!${request}`)});
</code></pre><p>上面语句补充上变量的值后相当于如下</p>
<pre class="prettyprint language-js"><code>var content = require('!!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css')
</code></pre><p>♻️ 这里的依赖关系先简单理一下, 比如 _app.tsx 引用了 globals.css</p>
<pre class="prettyprint language-js"><code>// pages/_app.tsx

import '../styles/globals.css'
</code></pre><p>globals.css 模块的内容被 next-style-loader 处理后的内容类似于下面这样</p>
<pre class="prettyprint language-js"><code>// styles/globals.css

var content = require('!!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css')

const style = document.createElement('style');
style.appendChild(document.createTextNode(content));
document.head.append(style)
</code></pre><p>所以 style 标签里面的 content 的源头其实是 require 的 !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css 模块提供</p>
<pre class="prettyprint language-js"><code>// !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css

module.exports = ?
</code></pre><p>那么对于 !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css 这个路径上带有 loader 的模块其文件后缀依然为 .css, 那么不还得命中 oneOf 数组索引为 6 的规则么 🤔 ?</p>
<p>经过 debug webpack 的代码发现结果是意外的 ❌, 它命中的是 oneOf 数组索引为 8 的规则</p>
<p><img src="https://user-images.githubusercontent.com/23253540/199278617-be6d6cfc-bde7-4035-b11f-1da0fb97e7a6.png" alt=""></p>
<blockquote>
<p><a href="https://webpack.js.org/configuration/module/#ruleissuer">Rule.issuer</a>: A Condition to match against the module that issued the request. In the following example, the issuer for the a.js request would be the path to the index.js file.</p>
</blockquote>
<blockquote>
<p>关于 Rule.issuer: 比如 pages/_app.tsx 文件里面 import 或者 require 了 globals.css, 那么对于 globals.css 而言, 它的 issuer 为 pages/_app.tsx</p>
</blockquote>
<p>让我们回头查看一下为什么没有命中索引为 6 的规则, 发现索引为 6 规则非常重要的一点是要求引用该文件的 issuer 必须只能是 pages/_app.tsx, 见下图红圈的 issuer.and 字段
<img src="https://user-images.githubusercontent.com/23253540/199280476-6e978a9b-26c8-4e9e-b86d-9bf34d01a3ad.png" alt=""></p>
<p>而 !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css 模块其实是被 next-style-loader 代理后的 globals.css 所 require, 所以它的 issuer 竟然为 styles/globals.css 🤯</p>
<p>至此 !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css 模块经过 postcss-loader &gt; css-loader 处理后, 最后还要被 webpack 内置的文件类型 asset/resource 处理（相当于 file-loader）, 最终处理完成它的 module.exports 其实为如下👇</p>
<pre class="prettyprint language-js"><code>// '!!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css'

module.exports = "/_next/static/media/globals.23a96686.css"
</code></pre><p>所以被 next-style-loader 处理后的 styles/globals.css 模块最后 append 了一个 url 字符串到了 style 标签中造成了本次 css 样式的异常 !!!</p>
<pre class="prettyprint language-js"><code>// styles/globals.css

var content = require('!!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css')

const style = document.createElement('style');
style.appendChild(document.createTextNode(content));
document.head.append(style)
</code></pre><h2>疑惑解答</h2>
<h3>为什么 Rule.oneOf 貌似 pick 了多次规则?</h3>
<p>对于 styles/globals.css 模块而言只选择了一次即 oneOf 数组索引为 6 的规则, 而经过 next-style-loader 的代理修改后的 require 语句又产生了新的模块 !!xxx/css-loader/src/index.js??xxx/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[6].use[2]!./globals.css, 于是新的模块又进行了一次规则 pick, 所以并不算违背了 Rule.oneOf 的定义
<img src="https://user-images.githubusercontent.com/23253540/199288932-e4aade71-1f44-45d3-b220-64a53e829df6.png" alt=""></p>
<blockquote>
<p>即便新的模块又命中了 oneOf 数组索引为 6 的规则, 由于新的模块路径前缀已经包含了 postcss-loader 与 css-loader 也会因为如上图红圈的 if 条件判断不满足而不会被添加重复的 loader</p>
</blockquote>
<h3>Next.js 的 oneOf 数组索引为 8 的规则真实意图是干什么的?</h3>
<p>根据如下 Next.js 对应的代码可知, Next.js 的预期是 issuer 为 *.css 的模块将要被 asset/resource（类似于 file-loader) 给处理, 比如 globals.css 有一行代码为 background-image: url("./xxx.png"), 那么此时 xxx.png 就要被 asset/resource 给处理</p>
<pre class="prettyprint language-js"><code>// next/dist/build/webpack/config/blocks/css/index.js

markRemovable({
    // This should only be applied to CSS files
    issuer: regexLikeCss,
    // Exclude extensions that webpack handles by default
    exclude: [
        /\.(js|mjs|jsx|ts|tsx)$/,
        /\.html$/,
        /\.json$/,
        /\.webpack\[[^\]]+\]$/, 
    ],
    // `asset/resource` always emits a URL reference, where `asset`
    // might inline the asset as a data URI
    type: 'asset/resource'
}), 
</code></pre><h2>问题解决</h2>
<p>Next.js 没想到被 next-style-loader 修改后还存在 .css 文件 require .css 文件的情况, .css 文件被 asset/resource 处理后返回一个 url 就导致了本次的 bug 🐛</p>
<p>其实 .css 中 require 的图片、字体等文件被 asset/resource 处理是符合预期, 如果被 require 的是 .css 文件就得排除, 更多见 <a href="https://github.com/vercel/next.js/pull/42283">pr</a></p>
<pre class="prettyprint language-diff"><code>            issuer: regexLikeCss,
            // Exclude extensions that webpack handles by default
            exclude: [
+              /\.(css|sass|scss)$/,
              /\.(js|mjs|jsx|ts|tsx)$/,
              /\.html$/,
              /\.json$/,
</code></pre>






标题：现在美国大部分地区已进入 10 月 25 日，为何 Node.js v18 LTS 还不发布？
作者：enzeberg
发布日期：发布于 6 个月前
文章内容：<p>现在是北京时间 10 月 25 日 15:09 .</p>







标题：在一套代码中同时实现“后台管理系统”和“前台应用”
作者：zhennann
发布日期：发布于 6 个月前
文章内容：<h2><strong>微信一起点菜</strong></h2>
<p>一个月紧张而愉快的开发又过去了。在这个月，开发了一个<code>微信一起点菜</code>项目，用来再次验证<code>CabloyJS全栈</code>框架定制开发的灵活性和扩展性。实践再次证明，使用CabloyJS全栈框架开发项目确实可以做到<code>多快好省</code>。因为：</p>
<ol>
<li>
<p>只需一套代码，即可同时实现“后台管理系统”和“前台应用”</p>
</li>
<li>
<p>只需一套代码，即可同时跨端pc、mobile。mobile端是接近原生体验</p>
</li>
</ol>
<p>下面就以<code>微信一起点菜</code>为例：</p>
<ol>
<li>
<p>前台点菜应用：<a href="https://test.cabloy.com/?appKey=diancai-h5%3AappDianCaiWechatH5&amp;appIsolate=true">https://test.cabloy.com/?appKey=diancai-h5%3AappDianCaiWechatH5&amp;appIsolate=true</a></p>
</li>
<li>
<p>后台商家管理系统：<a href="https://test.cabloy.com/">https://test.cabloy.com/</a></p>
</li>
<li>
<p>以上两个链接可以分别用pc和mobile打开。<code>全新交互体验，全新架构设计，试过便知</code></p>
</li>
</ol>
<h2><strong>截图</strong></h2>
<h3><strong>后台商家管理系统</strong></h3>
<p>PC端</p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/75cfb17801d8421f84a5595186cebba3.png" alt="dian-back-pc"></p>
<p>Mobile端</p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/72ccc0e5680f4370b77bc50e46d6e53b.png" alt="dian-back-mobile"></p>
<h3><strong>前台点菜应用</strong></h3>
<p>PC端</p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/61b84c84071a4242b2af17cd36de1950.png" alt="dian-front-pc"></p>
<p>Mobile端</p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/87302575434146e587d14b4048973e83.png" alt="dian-front-mobile-1"></p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/8c47557558794085b41a6c5b51f48bc0.png" alt="dian-front-mobile-2"></p>
<p><img src="https://admin.cabloy.com/api/a/file/file/download/7a348332b1e84177a8b1f9041f43a729.png" alt="dian-front-mobile-3"></p>







标题：使用node.exe 运行.js 文件时，报错，求指教
作者：dengwl
发布日期：发布于 6 个月前
文章内容：<p>运行node.exe xx.js文件时，出现下面这个错误，现在一头雾水，求大神指教。
assertion failed:&lt;r&gt;==&lt;0&gt;,file srccaress_wrap.cc,line 1283
运行环境 ：
	操作系统：winXP 2002 Service Pack3
	node 版本： 5.12.0</p>







标题：【模块联邦sdk hel-micro教程2】本地联调远程js库
作者：fantasticsoul
发布日期：发布于 6 个月前
文章内容：<p><a href="https://github.com/tnfe/hel"><strong>hel-micro</strong></a>，模块联邦sdk化，免构建、热更新、工具链无关的微模块方案 ，欢迎关注与了解</p>
<h2>💻 hel-micro 教学视频来了</h2>
<p>hel-micro 教学视频来了，为了帮助更多小伙伴快速上手sdk化模块联邦 hel-micro ，会持续推出一系列教学视频，期待大家观看后能够学到有用的知识并提出相关改进意见，<strong>本期为第二期视频教程</strong>。</p>
<h2>👅 本地联调远程js库</h2>
<p>本期主讲内容为：学会 <a href="https://www.bilibili.com/video/BV1Dd4y1y7Wj/?vd_source=51bc50bf5f860e0d778c49b00d192cee">本地联调基于hel-micro开发的远程js库</a> （点击左侧链接打开视频教程）</p>
<blockquote>
<p>附：视频<a href="https://codesandbox.io/s/my-xx-lib-l7wnhj?file=/src/index.js">演示项目</a></p>
</blockquote>
<p>往期视频：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV15t4y1u7i5/?vd_source=51bc50bf5f860e0d778c49b00d192cee">发布和使用远程js库</a></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b312668ba704413db6add2b548e977b3~tplv-k3u1fbpfcp-watermark.image?" alt="v2-cover.png"></p>
<h2>📦了解更多</h2>
<p>欢迎入群了解更多，由于微信讨论群号 200 人已满，需加作者微信号或 qq 群号，再邀请你如<code>hel-micro</code>讨论群（加号时记得备注 hel 哦）</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/104a737b0aa64e2cbef45a3c707502f5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>







标题：【模块联邦sdk hel-micro教程1】发布和使用远程js库
作者：fantasticsoul
发布日期：发布于 6 个月前
文章内容：<p><a href="https://github.com/tnfe/hel"><strong>hel-micro</strong></a>，模块联邦sdk化，免构建、热更新、工具链无关的微模块方案 ，欢迎关注与了解</p>
<h2>💻 hel-micro 教学视频来了</h2>
<p>hel-micro 教学视频来了，为了帮助更多小伙伴快速上手sdk化模块联邦 hel-micro ，会持续推出一系列教学视频，期待大家观看后能够学到有用的知识并提出相关改进意见，<strong>本期为第一期视频教程</strong>。</p>
<h2>👅 发布和使用远程js库</h2>
<p>本期主讲内容为：学会基于hel-micro <a href="https://www.bilibili.com/video/BV15t4y1u7i5/?vd_source=51bc50bf5f860e0d778c49b00d192cee">发布和使用远程js库</a></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbe8d4916fc84cfca130e59fa79c7821~tplv-k3u1fbpfcp-watermark.image?" alt="out-v1-logo.png"></p>
<h2>📦了解更多</h2>
<p>欢迎入群了解更多，由于微信讨论群号 200 人已满，需加作者微信号或 qq 群号，再邀请你如<code>hel-micro</code>讨论群（加号时记得备注 hel 哦）</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/104a737b0aa64e2cbef45a3c707502f5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>







标题：谁知道 nodejs v18.xx.xxx LTS 版本啥时候发布
作者：qq271492257
发布日期：发布于 6 个月前
文章内容：<p>就等着统一升级了，生产还是12版本，升不是，不升又不是</p>







标题：oracle查询中文字段时如何解决乱码问题？
作者：Web-Kevin
发布日期：发布于 7 个月前
文章内容：<p>单位的oracle服务器不归我们管理，编码使用的是 us7ascii</p>
<p>刚开始查询是通过表内的非中文字段查询的，拿到结果后中文字段的乱码问题通过编码转换获取正常文字</p>
<p>但现在需要通过表内的中文字段查询，每次获取的结果都是空</p>







标题：基于声网 iOS SDK 实现视频直播应用
作者：kylezhang
发布日期：发布于 6 个月前
文章内容：<p>视频互动直播是当前比较热门的玩法，我们经常见到有PK 连麦、直播答题、一起 KTV、电商直播、互动大班课、视频相亲等。本文将演示如何通过声网视频 SDK 在 iOS 端实现一个视频直播应用。话不多说，我们开始动手实操。</p>
<h1>前提准备</h1>
<p>在声网开发者控制台 Console <a href="https://console.agora.io">https://console.agora.io</a> 注册声网开发者账号后，需要获取项目 AppID。另外，开发者每个月可获得 10000 分钟的免费使用额度，可实现各类实时音视频场景。</p>
<h1>一、 通过开源Demo，体验视频直播</h1>
<p>可能有些人，还不了解我们要实现的功能最后是怎样的。所以声网在 GitHub上提供一个开源的基础视频直播 Demo 项目，在开始开发之前你可以通过该示例项目体验视频直播的体验效果。</p>
<h4>Demo 源码地址</h4>
<ul>
<li>Github Swift 版本：<a href="https://github.com/AgoraIO/Basic-Video-Broadcasting/tree/master/OpenLive-iOS">https://github.com/AgoraIO/Basic-Video-Broadcasting/tree/master/OpenLive-iOS</a></li>
<li>Github Objective-C 版本：<a href="https://github.com/AgoraIO/Basic-Video-Broadcasting/tree/master/OpenLive-iOS-Objective-C">https://github.com/AgoraIO/Basic-Video-Broadcasting/tree/master/OpenLive-iOS-Objective-C</a></li>
</ul>
<h4>效果截图</h4>
<p><img src="https://img-blog.csdnimg.cn/f0fa7d6c2cfc4e81972f11ef34de0a27.png#pic_center" alt=""></p>
<h1>二、 视频直播的技术原理</h1>
<p>我们在这里要实现的是视频直播，声网的视频直播可以实现互动效果，所以也经常叫互动直播。你可以理解为是多个用户通过加入同一个频道，实现的音视频的互通，而这个频道的数据，会通过声网的 SD-RTN 实时网络来进行低延时传输的。</p>
<p>需要特别说明的是，声网互动直播不同于视频直播。视频通话不区分主播和观众，所有用户都可以发言并看见彼此；而互动直播的用户分为主播和观众，只有主播可以自由发言，且被其他用户看见。</p>
<h4>下图展示在 App 中集成声网互动直播的基本工作流程</h4>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b083f0ec2d9481ba8981c7c252f0e26.png#pic_center" alt="在这里插入图片描述"></p>
<h4>如上图所示，实现视频直播的步骤如下：</h4>
<ol>
<li>获取 Token：当 app 客户端加入频道时，你需要使用 Token 验证用户身份。在测试或生产环境中，从 app 服务器中获取 Token。</li>
<li>加入频道：调用 joinChannel 创建并加入频道。使用同一频道名称的 app 客户端默认加入同一频道。频道可理解为专用于传输实时音视频数据的通道。</li>
<li>在频道内发布和订阅音视频流：加入频道后，app 客户端均可以在频道内发布和订阅音视频。</li>
</ol>
<h4>App 客户端加入频道需要以下信息：</h4>
<ol>
<li>App ID：声网后台随机生成的字符串，用于识别你的 App，可从<a href="https://console.agora.io">声网控制台</a>获取.</li>
<li>用户 ID：用户的唯一标识。你需要自行设置用户 ID，并确保它在频道内是唯一的。</li>
<li>Token：在测试或生产环境中，app 客户端从你的服务器中获取 Token。在本文介绍的流程中，你可以从可从<a href="https://console.agora.io">声网控制台</a>获取获取临时 Token。临时 Token 的有效期为 24 小时。</li>
<li>频道名称：用于标识视频直播频道的字符串。</li>
</ol>
<h1>三、 开发环境</h1>
<p>声网 SDK 的兼容性良好，对硬件设备和软件系统的要求不高，开发环境和测试环境满足以下条件即可：
• Xcode 9.0或以上版本
• 支持语音和视频功能的真机
• App 要求支持iOS 8.0或以上版本的iOS设备</p>
<h4>以下是本文的开发环境和测试环境：</h4>
<h5>开发环境</h5>
<p>• macOS 11.6版本
• Xcode Version 13.1</p>
<h5>测试环境</h5>
<p>• iPhone7 (iOS 15.3)</p>
<p><strong><em>如果你此前还未接触过声网 SDK，那么你还需要做以下准备工作</em></strong>
• 注册一个<a href="https://console.agora.io">声网账号</a>，进入后台创建 AppID、获取 Token，
• 下载声网官方最新的视频直播 SDK；</p>
<h1>四、 项目设置</h1>
<h4>1. 实现视频直播之前，参考如下步骤设置你的项目</h4>
<p>a) 如需创建新项目, Xcode里，打开 Xcode 并点击 Create a new Xcode project。（创建 iOS项目链接：<a href="https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app">https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app</a>）</p>
<p>b) 选择平台类型为 iOS、项目类型为 Single View App，并点击 Next。</p>
<p>c) 输入项目名称（Product Name）、开发团队信息（Team）、组织名称（Organization Name）和语言（Language）等项目信息，并点击 Next。</p>
<p><em>注意：如果你没有添加过开发团队信息，会看到 Add account… 按钮。点击该按钮并按照屏幕提示登入 Apple ID，完成后即可选择你的 Apple 账户作为开发团队。</em></p>
<p>d) 选择项目存储路径，并点击 Create。</p>
<h4>2. 集成SDK</h4>
<p>两种方法集成声网 SDK，选择如下任意一种方式获取声网 iOS SDK。</p>
<h5>方法一：使用 CocoaPods 获取 SDK</h5>
<p>a) 开始前确保你已安装 Cocoapods。参考 Getting Started with CocoaPods 安装说明。（Getting Started with CocoaPods 安装说明链接：<a href="https://guides.cocoapods.org/using/getting-started.html#getting-started%EF%BC%89">CocoaPods Guides - Getting Started</a></p>
<p>b) 在终端里进入项目根目录，并运行 pod init 命令。项目文件夹下会生成一个 Podfile 文本文件。</p>
<p>c) 打开 Podfile 文件，修改文件为如下内容。注意将 Your App 替换为你的 Target 名称。</p>
<pre class="prettyprint"><code>platform :ios, '9.0'
target 'Your App' do
    pod 'AgoraRtcEngine_iOS'
end
</code></pre><h5>方法二：从官网获取 SDK</h5>
<p>a) 前往 <a href="https://docs.agora.io/cn/video-legacy/downloads?platform=iOS">SDK 下载页面</a>，获取最新版的声网 iOS SDK，然后解压。</p>
<p>b) 根据你的需求，将 libs 文件夹中的动态库复制到项目的 ./project_name 文件夹下（project_name 为你的项目名称）。</p>
<p>c) 打开 Xcode，进入 TARGETS &gt; Project Name &gt; Build Phases &gt; Link Binary with Libraries 菜单，点击 + 添加如下库（如：）。在添加 AgoraRtcEngineKit.framework 文件时，还需在点击 + 后点击 Add Other…，找到本地文件并打开。</p>
<p>共需要添加11个库文件：</p>
<pre class="prettyprint"><code>i. AgoraRtcEngineKit.framework
ii. Accelerate.framework
iii. AudioToolbox.framework
iv. AVFoundation.framework
v. CoreMedia.framework
vi. CoreML.framework
vii. CoreTelephony.framework
viii. libc++.tbd
ix. libresolv.tbd
x. SystemConfiguration.framework
xi. VideoToolbox.framework
</code></pre><p>**注意1：**如需支持 iOS 9.0 或更低版本的设备，请在 Xcode 中将对 CoreML.framework 的依赖设为 Optional。</p>
<p>d) 打开 Xcode，进入 TARGETS &gt; Project Name &gt; General &gt; Frameworks, Libraries, and Embedded Content 菜单。</p>
<p>e) 点击 + &gt; Add Other… &gt; Add Files 添加对应动态库，并确保添加的动态库 Embed 属性设置为 Embed &amp; Sign。添加完成后，项目会自动链接所需系统库。</p>
<p><strong>注意2：</strong> 根据 Apple 官方要求，app 的 Extension 中不允许包含动态库。如果项目中的 Extension 需要集成 SDK，则添加动态库时需将文件状态改为 Do Not Embed。
· 声网 SDK 默认使用 libc++ (LLVM)，如需使用 libstdc++ (GNU)，请联系 <a href="mailto:sales@agora.io">sales@agora.io</a>。SDK 提供的库是 FAT Image，包含 32/64 位模拟器、32/64 位真机版本。</p>
<h4>3. 权限设置</h4>
<p>1） Xcode进入 TARGETS &gt; Project Name &gt; General &gt; Signing 菜单，选择 Automatically manage signing，并在弹出菜单中点击 Enable Automatic。
<img src="https://img-blog.csdnimg.cn/b7079fc237a24256beb67f2bebcdd14c.png" alt="在这里插入图片描述"></p>
<p>2）添加媒体设备权限
根据场景需要，在 info.plist 文件中，点击 + 图标开始添加如下内容，获取相应的设备权限：
<img src="https://img-blog.csdnimg.cn/img_convert/cff84da3c62eefc28893590aa6db7a3b.png#pic_center" alt="在这里插入图片描述">
<img src="https://img-blog.csdnimg.cn/img_convert/0362d84e91c6a2407c8f31f72e420b36.jpeg#pic_center" alt="在这里插入图片描述"></p>
<h4>4. 导入声网相关的类</h4>
<p>在项目中导入 AgoraRtcEngineKit 类：</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 导入 AgoraRtcKit 类
// 自 3.0.0 版本起，AgoraRtcEngineKit 类名更换为 AgoraRtcKit
// 如果获取的是 3.0.0 以下版本的 SDK，请改用 #import &lt;AgoraRtcEngineKit/AgoraRtcEngineKit.h&gt;
#import &lt;AgoraRtcKit/AgoraRtcEngineKit.h&gt;
// 声明 AgoraRtcEngineDelegate，用于监听回调
@interface ViewController : UIViewController &lt;AgoraRtcEngineDelegate&gt;
// 定义 agoraKit 变量
@property (strong, nonatomic) AgoraRtcEngineKit *agoraKit;
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 导入 AgoraRtcKit 类
// 自 3.0.0 版本起，AgoraRtcEngineKit 类名更换为 AgoraRtcKit
// 如果获取的是 3.0.0 以下版本的 SDK，请改用 import AgoraRtcEngineKit
import AgoraRtcKit
class ViewController: UIViewController {
    ...
    // 定义 agoraKit 变量
    var agoraKit: AgoraRtcEngineKit?
}
</code></pre><h4>5. 设置声网账号信息</h4>
<p>在 KeyCenter.swift 文件中，将你的AppID填写到对应位置，可替换“Your App ID”;
<strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>//  Objective-C
//  AppID.m
//  声网 iOS Tutorial 
NSString *const appID = &lt;#Your App ID#&gt;;
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>//  Swift
// AppID.swift
//  声网 iOS Tutorial
Static let AppID: String = Your App ID
</code></pre><h1>五、 客户端实现</h1>
<p>本节介绍如何使用声网视频 SDK 在你的 App 里实现视频直播的几个小贴士。</p>
<h4>1. 创建用户界面</h4>
<p>根据场景需要，为你的项目创建视频直播的用户界面。我们推荐你在项目中添加元素：本地视频窗口、远端视频窗口。</p>
<p>你可以参考以下代码创建一个基础的用户界面。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint language-Objective-C"><code>// Objective-C
// 导入 UIKit
#import &lt;UIKit/UIKit.h&gt;
@interface ViewController ()
// 定义 localView 变量
@property (nonatomic, strong) UIView *localView;
// 定义 remoteView 变量
@property (nonatomic, strong) UIView *remoteView;
@end
@implementation ViewController
...
- (void)viewDidLoad {
    [super viewDidLoad];
    // 调用初始化视频窗口函数
    [self initViews];
    // 后续步骤调用声网 API 使用的函数
    [self initializeAgoraEngine];
    [self setChannelProfile];
    [self setClientRole];
    [self setupLocalVideo];
    [self joinChannel];
}
// 设置视频窗口布局
- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.remoteView.frame = self.view.bounds;
    self.localView.frame = CGRectMake(self.view.bounds.size.width - 90, 0, 90, 160);
}
- (void)initViews {
    // 初始化远端视频窗口。只有当远端用户为主播时，才会显示视频画面
    self.remoteView = [[UIView alloc] init];
    [self.view addSubview:self.remoteView];
    // 初始化本地视频窗口。只有当本地用户为主播时，才会显示视频画面
    self.localView = [[UIView alloc] init];
    [self.view addSubview:self.localView];
}
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 导入 UIKit
import UIKit
class ViewController: UIViewController {
    ...
    // 定义 localView 变量
    var localView: UIView!
    // 定义 remoteView 变量
    var remoteView: UIView!
     override func viewDidLoad() {
        super.viewDidLoad()
        // 调用初始化视频窗口函数
        initView()
       // 后续步骤调用声网 API 使用的函数
        initializeAgoraEngine()
        setChannelProfile()
        setClientRole()
        setupLocalVideo()
        joinChannel()  
    }
    // 设置视频窗口布局
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        remoteView.frame = self.view.bounds
        localView.frame = CGRect(x: self.view.bounds.width - 90, y: 0, width: 90, height: 160)
    }
    func initView() {
        // 初始化远端视频窗口。只有当远端用户为主播时，才会显示视频画面
        remoteView = UIView()
        self.view.addSubview(remoteView)
        // 初始化本地视频窗口。只有当本地用户为主播时，才会显示视频画面
        localView = UIView()
        self.view.addSubview(localView)
    }
}
</code></pre><h4>2. 实现视频直播逻辑</h4>
<p>现在，我们已经将声网 iOS SDK 集成到项目中了。接下来我们要在 ViewController 中调用声网 iOS SDK 提供的核心 API 实现基础的视频直播功能。</p>
<h5>API 调用时序见下图</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fe7eee11f01872cfed2d25870b5e5847.png#pic_center" alt="在这里插入图片描述">
<strong>参考上图，按照以下步骤实现该逻辑</strong></p>
<h5>a) 初始化AgoraRtcEngineKit对象</h5>
<p>在调用其他声网 API 前，需要创建并初始化 AgoraRtcEngineKit 对象。调用 sharedEngineWithAppId 方法，传入获取到的 App ID，即可初始化 AgoraRtcEngineKit 。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 输入 App ID 并初始化 AgoraRtcEngineKit 类。
- (void) viewDidLoad{
self.rtcEngine = [AgoraRtcEngineKit sharedEngineWithAppId:[KeyCenter AppId] delegate:self];
}
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 输入 App ID 并初始化 AgoraRtcEngineKit 类。
private lazy var agoraKit: AgoraRtcEngineKit = {
        let engine = AgoraRtcEngineKit.sharedEngine(withAppId: KeyCenter.AppId, delegate: nil)
        return engine
    }()
</code></pre><p>你还可以根据场景需要，在初始化时注册想要监听的回调事件，如本地用户加入频道，及解码远端用户视频首帧等。</p>
<h5>b) 设置频道场景</h5>
<p>调用 setChannelProfile 方法，将频道场景设为直播。一个 AgoraRtcEngineKit 只能使用一种频道场景。如果想切换为其他频道场景，需要先调用 destroy 方法销毁当前的 AgoraRtcEngineKit 对象，然后使用 sharedEngineWithAppId 方法创建一个新的对象，再调用setChannelProfile 设置新的频道场景。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 设置频道场景为直播模式
[self.rtcEngine setChannelProfile:AgoraChannelProfileLiveBroadcasting];
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 设置频道场景为直播模式
agoraKit.setChannelProfile(.liveBroadcasting)
</code></pre><h5>c) 设置用户角色</h5>
<p>直播频道有两种用户角色：主播和观众，其中默认的角色为观众。设置频道场景为直播后，你可以在 app 中参考如下步骤设置用户角色：</p>
<p>让用户选择自己的角色是主播还是观众；
调用 setClientRole 方法，然后使用用户选择的角色进行传参。
注意，直播频道内的用户，只能看到主播的画面、听到主播的声音。加入频道后，如果你想切换用户角色，也可以调用 setClientRole 方法。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 设置用户角色
- (IBAction)doBroadcastPressed:(UIButton *)sender {
if (self.isBroadcaster) {
		// 设置用户角色为主播
        self.clientRole = AgoraClientRoleAudience;
        if (self.fullSession.uid == 0) {
            self.fullSession = nil;
        }
} else {
		// 设置用户角色为观众
        self.clientRole = AgoraClientRoleBroadcaster;
    }
    
    [self.rtcEngine setClientRole:self.clientRole];
    [self updateInterfaceWithAnimation:YES];
}
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 选择用户角色
@IBAction func doBroadcasterTap(_ sender: UITapGestureRecognizer) {
// 选择用户角色为主播
        selectedRoleToLive(role: .broadcaster)
    }
    
@IBAction func doAudienceTap(_ sender: UITapGestureRecognizer) 
// 选择用户角色为观众
selectedRoleToLive(role: .audience)

// 设置用户角色
agoraKit.setClientRole(settings.role)
// 设置为主播角色时
if settings.role == .broadcaster {
            addLocalSession()
            agoraKit.startPreview()
        }

//设置为观众角色时
let isHidden = settings.role == .audience
</code></pre><h5>d) 设置本地视图</h5>
<p>成功初始化 AgoraRtcEngineKit 对象后，需要在加入频道前设置本地视图，以便在通话中看到本地图像。参考以下步骤设置本地视图：
· 调用 enableVideo 方法启用视频模块。
· 调用 setupLocalVideo 方法设置本地视图。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 启用视频模块。
[self.rtcEngine enableVideo];
// 设置本地视图。
- (void)addLocalSession {
    VideoSession *localSession = [VideoSession localSession];
[self.videoSessions addObject:localSession];
// 设置本地视图。
    [self.rtcEngine setupLocalVideo:localSession.canvas];
    [self updateInterfaceWithAnimation:YES];
}

// VideoSession部分
//  VideoSession.m
#import "VideoSession.h"
@implementation VideoSession
- (instancetype)initWithUid:(NSUInteger)uid {
    if (self = [super init]) {
        self.uid = uid;
        
        self.hostingView = [[UIView alloc] init];
        self.hostingView.translatesAutoresizingMaskIntoConstraints = NO;
        
        self.canvas = [[AgoraRtcVideoCanvas alloc] init];
        self.canvas.uid = uid;
        self.canvas.view = self.hostingView;
        self.canvas.renderMode = AgoraVideoRenderModeHidden;
    }
    return self;
}

+ (instancetype)localSession {
    return [[VideoSession alloc] initWithUid:0];
}
@end
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 启用视频模块。
agoraKit.enableVideo()
// 设置本地视图。
agoraKit.setupLocalVideo(videoCanvas)


// VideoSession部分
// VideoSession.swift
hostingView = VideoView(frame: CGRect(x: 0, y: 0, width: 100, height: 100))
hostingView.translatesAutoresizingMaskIntoConstraints = false
canvas = AgoraRtcVideoCanvas()
canvas.uid = uid
canvas.view = hostingView.videoView
canvas.renderMode = .hidden
</code></pre><h5>e) 加入频道</h5>
<p>频道是人们在同一个视频直播中的公共空间。完成初始化和设置本地视图后（视频直播场景），你就可以调用 joinChannelByToken 方法加入频道。你需要在该方法中传入如下参数：</p>
<ol>
<li>channelId: 传入能标识频道的频道 ID。输入频道 ID 相同的用户会进入同一个频道。</li>
<li>token: 传入能标识用户角色和权限的 Token。你可以设置如下值：</li>
</ol>
<ul>
<li>nil 。</li>
<li>控制台中生成的临时 Token。一个临时 Token 的有效期为 24 小时，详情见获取临时 Token。</li>
<li>你的服务器端生成的正式 Token。适用于对安全要求较高的生产环境，详情见生成 Token。若项目已启用 App 证书，请使用 Token。</li>
<li>uid: 本地用户的 ID。数据类型为整型，且频道内每个用户的 uid 必须是唯一的。若将 uid 设为 0，则 SDK 会自动分配一个 uid ，并在 joinSuccessBlock 回调中报告。</li>
<li>joinSuccessBlock：成功加入频道回调。 joinSuccessBlock 优先级高于 didJoinChannel ，2 个同时存在时， didJoinChannel 会被忽略。需要有 didJoinChannel 回调时，请将 joinSuccessBlock 设置为 nil 。</li>
</ul>
<p>更多的参数设置注意事项请参考 joinChannelByToken 接口中的参数描述。
<strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 加入频道。
self.rtcEngine joinChannelByToken:[KeyCenter Token] channelId:self.roomName info:nil uid:0 joinSuccess:nil 
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 加入频道。
agoraKit.joinChannel(byToken: KeyCenter.Token, channelId: channelId, info: nil, uid: 0, joinSuccess: nil)
</code></pre><h5>f) 设置远端视图</h5>
<p>视频互动直播中，通常你也需要看到其他主播。远端主播成功加入频道后，SDK 会触发 didJoinedOfUid 回调，该回调中会包含这个远端主播的 uid 信息。在该回调中调用 setupRemoteVideo 方法，传入获取到的 uid，设置远端主播的视图。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 监听 didJoinedOfUid 回调
// 远端主播加入频道时，会触发该回调
- (void)rtcEngine:(AgoraRtcEngineKit *)engine didJoinedOfUid:(NSUInteger)uid elapsed:(NSInteger)elapsed {
    AgoraRtcVideoCanvas *videoCanvas = [[AgoraRtcVideoCanvas alloc] init];
    videoCanvas.uid = uid;
    videoCanvas.renderMode = AgoraVideoRenderModeHidden;
    videoCanvas.view = self.remoteView;
    // 设置远端视图
    [self.agoraKit setupRemoteVideo:videoCanvas];
}
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
//需要在额外添加以下代码
extension LiveRoomViewController: AgoraRtcEngineDelegate {
    // 监听 didJoinedOfUid 回调
    // 远端主播加入频道时，会触发该回调
    func rtcEngine(_ engine: AgoraRtcEngineKit, didJoinedOfUid uid: UInt, elapsed: Int) {
        guard videoSessions.count &lt;= maxVideoSession else {
            return
        }
        let userSession = videoSession(of: uid)
		// 设置远端视图
        agoraKit.setupRemoteVideo(userSession.canvas)
    }
  }
</code></pre><h5>g) 离开频道</h5>
<p>根据场景需要，如结束通话、关闭 App 或 App 切换至后台时，调用 leaveChannel 离开当前通话频道。</p>
<p><strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 离开频道的步骤
- (void)leaveChannel {
    [self setIdleTimerActive:YES];
[self.rtcEngine setupLocalVideo:nil]; // nil means unbind
// 离开频道。
    [self.rtcEngine leaveChannel:nil];    // leave the channel, callback = nil
    if (self.isBroadcaster) {
        [self.rtcEngine stopPreview];
    }
    
    for (VideoSession *session in self.videoSessions) {
        [session.hostingView removeFromSuperview];
    }
    [self.videoSessions removeAllObjects];
    
    if ([self.delegate respondsToSelector:@selector(liveVCNeedClose:)]) {
        [self.delegate liveVCNeedClose:self];
    }
}
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 离开频道的步骤
func leaveChannel() {
        // Step 1, release local AgoraRtcVideoCanvas instance
        agoraKit.setupLocalVideo(nil)
        // Step 2, leave channel and end group chat
        agoraKit.leaveChannel(nil)
        
        // Step 3, if current role is broadcaster,  stop preview after leave channel
        if settings.role == .broadcaster {
            agoraKit.stopPreview()
        }
        setIdleTimerActive(true)
        navigationController?.popViewController(animated: true)
    }
</code></pre><h5>h) 销毁AgoraRtcEngineKit对象</h5>
<p>最后，离开频道，我们需要调用 destroy 销毁 AgoraRtcEngineKit 对象，释放声网 SDK 使用的所有资源。
<strong>Objective-C 版本</strong></p>
<pre class="prettyprint"><code>// Objective-C
// 将以下代码填入你定义的函数中
[AgoraRtcEngineKit destroy];
</code></pre><p><strong>Swift 版本</strong></p>
<pre class="prettyprint"><code>// Swift
// 将以下代码填入你定义的函数中
AgoraRtcEngineKit.destroy()
</code></pre><p><img src="https://img-blog.csdnimg.cn/5eab9b1b900746d5afcab461397afa36.png" alt="在这里插入图片描述">
至此，完成声网视频 SDK 的集成，运行看看效果。拿两部手机安装编译好的App，加入同一个频道名，分别选择主播角色和观众角色，如果2个手机都能看见同一个自己，说明你成功了。</p>
<p>如果你在集成开发过程中遇到问题，可以访问 <a href="https://www.agora.io/cn/community/">RTE 开发者社区</a> 吐槽与声网工程师交流。</p>







标题：找回密码功能，显示邮件已发送，一直收不到呀
作者：tfx919
发布日期：发布于 6 个月前
文章内容：<p>找回密码功能，显示邮件已发送，一直收不到呀</p>







标题：hel-micro 模块联邦新革命
作者：fantasticsoul
发布日期：发布于 6 个月前
文章内容：<blockquote>
<p><a href="https://github.com/tnfe/hel"><strong>hel-micro</strong></a>，模块联邦sdk化，免构建、热更新、工具链无关的微模块方案 ，欢迎关注与了解</p>
</blockquote>
<table>
<thead>
<tr>
<th>示例名称/功能</th>
<th>使用示范</th>
<th>模板地址</th>
<th>模板描述</th>
<th>托管位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>远程ts库</td>
<td><a href="https://codesandbox.io/s/hel-lodash-zf8jh8">codesandbox</a></td>
<td><a href="https://github.com/hel-eco/hel-tpl-remote-lib">hel-lodash</a></td>
<td>webpack开发与打包</td>
<td><a href="https://unpkg.com/hel-lodash">unpkg meta</a></td>
</tr>
<tr>
<td>远程 react js 组件</td>
<td><a href="https://codesandbox.io/s/demo-load-remote-react-comp-2bnpl0">codesandbox</a></td>
<td><a href="https://github.com/hel-eco/hel-tpl-remote-react-comp">remote-react-comp</a></td>
<td>webpack开发与打包</td>
<td><a href="https://unpkg.com/hel-tpl-remote-react-comps">unpkg meta</a></td>
</tr>
<tr>
<td>远程 react ts 组件</td>
<td><a href="https://codesandbox.io/s/demo-load-remote-react-comp-2bnpl0">codesandbox</a></td>
<td><a href="https://github.com/hel-eco/hel-tpl-remote-react-comp-ts">remote-react-comp-ts</a></td>
<td>webpack开发与打包</td>
<td><a href="https://unpkg.com/hel-tpl-remote-react-comps-ts">unpkg meta</a></td>
</tr>
<tr>
<td>远程 vue2 js 组件</td>
<td><a href="https://codesandbox.io/s/demo-load-remote-vue-comp-st0295">codesandbox</a></td>
<td><a href="https://github.com/hel-eco/hel-tpl-remote-vue-comp">remote-vue-comp</a></td>
<td>webpack开发与打包</td>
<td><a href="https://unpkg.com/hel-tpl-remote-vue-comps">unpkg meta</a>、<a href="https://hel-eco.github.io/hel-tpl-remote-vue-comp/index.html">github.io index.html</a> 、<a href="https://unpkg.com/hel-tpl-remote-vue-comps@1.1.3/hel_dist/index.html">unpkg index.html</a></td>
</tr>
<tr>
<td>远程 vue3 ts 组件</td>
<td><a href="https://codesandbox.io/s/demo-load-remote-vue3-comp-2fd34s?file=/src/main.js">codesandbox</a></td>
<td><a href="https://github.com/hel-eco/hel-tpl-remote-vue3-comps-ts">remote-vue3-comps-ts</a></td>
<td>vite 或 webpack开发，webpack打包</td>
<td><a href="https://unpkg.com/hel-tpl-remote-vue3-comps-ts">unpkg meta</a></td>
</tr>
</tbody>
</table>
<h2>模块联邦之缘起</h2>
<p>自谷歌<code>chrome</code>浏览器异军突起，并在2008年9月2号 正式官宣发布 <code>v8</code> js引擎之后，它以极高的运行效率席卷了网络世界，同时也捕获了大量用户，这种不可阻挡的势头让其他各大科技公司（apple、moliza、microsoft）感受到了巨大的杀气，  随即大家都开始招兵买马、磨刀赫赫准备杀出一条血路，从此js引擎进入了军备竞赛时期，这其中微软甚至不惜自废<code>IE</code>并开始力推背后携带了微软无数心血的全新js引擎 <code>Chakra</code>的<code>edge</code>浏览器，可想而知大家对js引擎这块蛋糕的重视程度有多高，而<code>v8</code>的诞生催化了大量的著名开源作品，让js生态一直保持着非常强劲的活力，这其中最著名的就是 2009 年诞生的<code>nodejs</code>，一个基于<code>v8</code>的服务端js运行时，让js这门语言开始从前台到后台遍地生花，以至于以下一句很早诞生的调侃话语至今还在流传：</p>
<pre class="prettyprint"><code>Any application that can be written in JavaScript, willeventually be written in JavaScript.
</code></pre><h3>模块化规范</h3>
<p><code>nodejs</code>将<code>commonjs</code>模块化带到了服务器端，让大型js工程组织起来更加有条不紊，同时也带了<code>npm</code>这个超级杀手锏，让模块分发与共享效率提高到了前所未有的高度。</p>
<p>而前端应用也随着网络应用的复杂度成倍提升，导致进入代码体积进入了高速膨胀时期，这个时候急需一个有效的模块化方案来解决如何优雅拆分模块，如何提高代码复用性和可维护性等一系列问题。</p>
<p>此时两大主流模块化方案<code>amd</code>和<code>cmd</code>开始在前端这里竞相角逐并最后各自站稳了一份很大的地盘，他们的代表实现分别是<code>requirejs</code>和<code>seajs</code>，相信不少小伙伴都了解或使用过。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4072c8629442278450f7055a1a2eb2~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p>
<h3>工程化体系</h3>
<p>尽管<code>requirejs</code>和<code>seajs</code>为前端带来了模块化规范的实现并给大型js工程注入了稳固的根基，但是仅靠模块化规范，依然不能解决如何和<code>npm</code>生态互通，如何管理日趋复杂的模块依赖关系，如果兼容新的js特性等一系列问题，归根结底，这里面涉及到一个关键词<strong>工程化体系</strong>，之后<code>webpack</code>和<code>babel</code>便诞生了，他们目标非常明确，解决了以下图中的4大问题</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79b6612199be4bed822661890465e3a9~tplv-k3u1fbpfcp-zoom-1.image" alt="2.png"></p>
<p>随即成为了前端开始工程化体系开发的事实上的基建标配。</p>
<p><code>webpack</code>依靠优秀的插件和加载器机制，让其围绕它的生态得以不停地做大做强，干掉了过程其他更偏向于工具的<code>gulp</code>，<code>grunt</code>等一众对手</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6406a87db77948b287624285dadff97f~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p>
<h3>npm 的魔咒</h3>
<p><code>webpack</code>和<code>npm</code>几乎形成了完美搭档的状态，但前端原本从<code>cdn</code>获取的资源改由打包工具合并到一个包体里带来了致命的更新和部署效率问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa760d446954a9db3df76c8cdf18971~tplv-k3u1fbpfcp-zoom-1.image" alt="4.png"></p>
<p>在某些需要需要动态更新的场景，这种<code>all in one</code>的打包机制让包体的部署效率大打折扣，这本不是<code>webpack</code>和<code>npm</code>的问题，而是人们天生对web环境需要快速迭代、快递实验的高要求带来的典型场景需求。</p>
<blockquote>
<p>注：externals 本身不能彻底解决动态更新的诉求，只适合于将底层公关依赖包体外链到cdn</p>
</blockquote>
<h3>bundless 来袭</h3>
<p>同时<code>webpack</code>随着项目体积日趋庞大，新的问题诸如开发体验差（热更新慢）、包体加大、构建速度慢（node_modules黑洞）等问题也诞生了，此时新生代的开发工具<code>snow</code>和<code>vite</code>以不打包的名义开始蚕食<code>webpack</code>的市场。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aad6f55f69e4d9497b2178fe194ff51~tplv-k3u1fbpfcp-zoom-1.image" alt="5.png"></p>
<p>他们都利用了浏览器的原生模块化能力<code>esm</code>，跳过<code>webpack</code>的需要的依赖分析和打包流程，在此设计下做到了毫秒级的调试启动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d308b88adfbd42b897ac6600f60768dc~tplv-k3u1fbpfcp-zoom-1.image" alt="6.png"></p>
<p>但它们带来的极致快体验并不能动摇整个<code>webpack</code>生态的深厚围城，事实上大家都是处于调试基于<code>vite</code>而生产打包还是用<code>webpack</code>的双擎驱动模式，毕竟<code>esm</code>普及还需要时间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1f8f4343554e51bc44b57381bb845a~tplv-k3u1fbpfcp-zoom-1.image" alt="7.png"></p>
<h3>模块联邦吹响反攻号角</h3>
<p>既然大家都吐槽<code>wepack</code>构建慢，那么可不可以有一种方式既能跳过构建步骤又能让用户可以按自己的方式组合多层次依赖模块呢？</p>
<p>当然有的，那就是走<strong>预构建</strong>这条道路</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee694db2a0b64c7fb44bb5d17e08d357~tplv-k3u1fbpfcp-zoom-1.image" alt="8.png"></p>
<p><code>模块联邦</code>因此诞生了，它的伟大之处在于保持当前前端开发模块化、组件化、工程化的高效率体系下，允许模块独立开发、独立部署，通过 CDN 直接共享，从而挣脱npm包体无法动态更新的桎梏，从而推动整个前端界开发和运行体验上升到一个新高度。</p>
<p>只要有越多的模块能提升到联邦里，本地启动速度将越快！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b72dc38bbfbe4dfdbcb04b8462113ca6~tplv-k3u1fbpfcp-zoom-1.image" alt="9.png"></p>
<p>而且联邦模块天生具有双重身份，即可以是模块消费者，也可以是模块提供者，这让模块联邦应用之间形成了天然的网格关系，模块分发效率、部署效率、共享效率都得到了前所未有的提升！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ebe3e064759447bab25ce1f467d3ea5~tplv-k3u1fbpfcp-zoom-1.image" alt="a1.png"></p>
<h3>模块联邦的阿喀琉斯之踵</h3>
<p><code>webpack 5</code>或者其他工具带来的模块联邦实现真的完美了吗？它的确解决了<code>免构建</code>、<code>动态更新</code>、<code>跨项目共享模块</code>的问题</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a65153584d46be905de37277948bdf~tplv-k3u1fbpfcp-zoom-1.image" alt="a2.png"></p>
<p>但基于现有的编译时插件化机制去实现，无法规避<code>工具链强绑定</code>，<code>编译时确定才能远程模块消费关系</code>的难题</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fd5a185e79e466e8ac9bbc00dc3e298~tplv-k3u1fbpfcp-zoom-1.image" alt="a3.png"></p>
<p>试想一下，你需要使用模块联邦这么技术，需要做的前置条件有多重，需要升级真个工具链！而且不同工具链之前的联邦模块是互相不通的！模块的流通性绑定在了你选择的工具链上。</p>
<h2>模块联邦新革命</h2>
<p>破除这两大难题的唯一解就是将其<code>sdk化</code>，这是<code>hel-micro</code>对模块联邦实现的全新思考，也是发起模块联邦新革命的秘密武器。</p>
<p><code>sdk化</code>后，任何技术栈、任何工具链均可无损、无痛接入模块联邦技术。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0feb6cb8034715a9b7b4011cdcaef9~tplv-k3u1fbpfcp-zoom-1.image" alt="a4.png"></p>
<h3>运行时的模块消费关系</h3>
<p>从工具链回归到js语言本身，意味着模块消费关系从编译时提升到运行时，将极大提高动态载入远程模块的灵活性，为更复杂的业务赋能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de085c3e6eda4c88b30761137b0ab759~tplv-k3u1fbpfcp-zoom-1.image" alt="a5.png"></p>
<h3>降维打击</h3>
<p>对比依赖工具插件实现的模块联邦，<code>hel-micro</code>从语言层面的实现将对其他模块联邦实现造成降维打击。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94bcd3524b224a16bcf5a47b9c069b7b~tplv-k3u1fbpfcp-zoom-1.image" alt="a6.png"></p>
<p>相比传统的npm共享方式，<code>hel-micro</code>也具有更高效的代码共享能力（运行时共享）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f37d38bdbfd24dfe9559b10239b04cb8~tplv-k3u1fbpfcp-zoom-1.image" alt="a7.png"></p>
<h2>解密 sdk 化核心实现</h2>
<p>要实现sdk化，意味着我们必须挖掘出js语言本身的隐含能力，并跳出传统的打包流程思维，才能达到我们的最终目标</p>
<h3>异步import暗藏的能力</h3>
<p>通常我们都会在头文件使用<code>import</code>关键字静态导入其他模块，但其实<code>import</code>可以作为函数调用，异步的导入一个模块，并返回一个promise对象</p>
<pre class="prettyprint language-ts"><code> const mod = await import('./some-mod');
</code></pre><p>所以我们可以通过微调模块的加载顺序，来达到为一个模块被其他模块静态导入之前能够为它注入新代码的效果</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89fe540758704e1eb7526f4f0d7fdacb~tplv-k3u1fbpfcp-zoom-1.image" alt="a8.png"></p>
<p>而这个异步import带来的提前注入效果成为了<code>hel-micro</code>为模块代理对象注入远程运行时代码的关键实现点，让<code>hel-micro</code>可以位用户提供懒加载和预加载两种加载方式。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec058bcc61c34133908038f41ff1b273~tplv-k3u1fbpfcp-zoom-1.image" alt="a9.png"></p>
<p>上图里两个核心接口：<code>libReady</code>接口负责暴露模块，<code>preFetchLib</code>接口负责拉取模块，通过调用接口的行为让每一个模块都表现为提供方或者消费者。</p>
<h3>运行时依赖分析</h3>
<p><code>hel-micro</code>通过内部维护的<code>事件总线</code>、<code>模块池</code>、<code>样式池</code>、<code>元数据池</code>四个数据结构，让有多级依赖层次的远程模块得以高效并安全有序的加载。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1a3b0661854ec5bcfe0d99aa14d97b~tplv-k3u1fbpfcp-zoom-1.image" alt="b1.png"></p>
<p>其中<code>模块池</code>能保证模块不被重复加载并被上层各方调用者重复使用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968f664d6a3e4f86bf9884e1a6676059~tplv-k3u1fbpfcp-zoom-1.image" alt="b2.png"></p>
<h3>元数据-模块的灵魂</h3>
<p>模块的实质是构建产物文件的集合，<code>hel-micro</code>通过提供构建时的插件，收集好产物的网络路径并按sdk规定的协议存储起来，得以后续可以在网络让sdk可以下载并执行所有的远程模块。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27b28589f2bb44d59ffcc40b374af5cd~tplv-k3u1fbpfcp-zoom-1.image" alt="b3.png"></p>
<h3>双构建机制</h3>
<p><code>hel-micro</code>使用<code>rollup</code>打包本地可静态导入的代理文件，使用<code>webpack</code>打包远程注入的实际运行代码，来达成可以本地静态导入<code>node_modules</code>里的代理模块对象得到完整的类型提示，让用户能得到像使用本地模块一样地使用远程模块的极致开发体验</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2409cac51b3e45f3a42d70e0428644d2~tplv-k3u1fbpfcp-zoom-1.image" alt="b4.png"></p>
<p>内定了4个目录<code>hel_dist</code>，<code>hel_proxy</code>，<code>hel_proxy_es</code>，<code>hel_bundle</code>来承载不同的产物，供<code>package.json</code>配置不同的入口。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce90ef65762443b58d88ee67f303bfff~tplv-k3u1fbpfcp-zoom-1.image" alt="b5.png"></p>
<p>其中<code>hel_proxy</code>，<code>hel_proxy_es</code>目录下的文件是就是我们说到的模块代理对象的入口文件，我们可以看到该文件近乎一个空壳，所以它对模块使用方的打包体积大小影响几乎可以省略不计。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc4481414c2247358019c95d02b9fcec~tplv-k3u1fbpfcp-zoom-1.image" alt="b6.png"></p>
<h2>平台与生态</h2>
<p>hel-mirco sdk主要依靠规范化的元数据格式来做远程模块加载，所以只要任意用户按照规范格式提供模块的元数据，即可被<code>hel-micro</code>加载，这将极有利于围绕hel-micro的上层生态的建设与发展。</p>
<h3>支持模块任意部署</h3>
<p>sdk与平台是解耦的，我们默认提供了和<code>hel pack</code>与<code>npm unpkg</code>的支持，但允许你可以将模块发布到网络上的任意文件服务，仅需知道其部署地址即可。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63a65491cef414489a98b86ce5505d7~tplv-k3u1fbpfcp-zoom-1.image" alt="b7.png"></p>
<p>如用户将 <code>hel-meta.json</code> 元数据保存到后台数据库（可结合devops流水线），就可很快搭出一个类似<code>hel pack</code>的中心化的模块管控平台</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0c0641321d9480f91712a7c74227567~tplv-k3u1fbpfcp-zoom-1.image" alt="b8.png"></p>
<p>中心化的模块管控平台对模块实施<strong>版本预览</strong>、<strong>灰度放量</strong>、<strong>秒级回滚</strong>等工作会特别方便，但它不妨碍sdk以去中性化的方式加载多平台包体，因为sdk天生支持同时从多个不同的平台拉取远程模块并使用，例如同时加载来自unpkg 和 hel pack2个平台的模块，平台值会被当做命名空间来隔离不同平台可能重名的模块。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b73c8ad9b07b40169e34db283242f58b~tplv-k3u1fbpfcp-zoom-1.image" alt="b9.png"></p>
<h3>上层生态建设</h3>
<p><code>hel-micro</code>本身只提供远程模块加载的能力，具体的ui适配层还需要上层封装库区实现，目前的规划如下图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/208a47039423454e947c132e0a1a4f3e~tplv-k3u1fbpfcp-zoom-1.image" alt="c1.png"></p>
<p>以 <code>hel-micro-react</code>为例，提供以<code>react</code>钩子函数的形式懒加载远程组件，并同时提供shadow dom样式隔离功能</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03a410ced5954a2f98c0acd16103bf9a~tplv-k3u1fbpfcp-zoom-1.image" alt="c2.png"></p>
<h3>何时采用hel-micro</h3>
<p>当前时刻当你遇到以下任意一种情形时，采用<code>hel-micro</code>都绝对值得你投入去尝试。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3af9b06f7d2741ceb1c33d98c3239ca2~tplv-k3u1fbpfcp-zoom-1.image" alt="c3.png"></p>
<h3>roadmap 2022~2023</h3>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0d88ead0d9841a6b4dc1a04ae2280ee~tplv-k3u1fbpfcp-zoom-1.image" alt="c4.png"></p>
<h2>结语</h2>
<p>模块联邦对于搭建超大型js工程能到如虎添翼的作用，巨型应用的模块部署效率、共享效率都将迎刃而解，同时搭配<code>微容器</code>相关框架（如wujie、rame）等，为你的隔离运行需求保驾护航，欢迎 star  <a href="https://github.com/tnfe/hel">hel-micro</a>，了解并使用。</p>
<hr>
<p>我的其他开源作品友链（欢迎关注与了解）：</p>
<p><a href="https://github.com/concentjs/concent">concent</a>，一个自带依赖收集、提供setup特性的react数据流方案</p>
<p><a href="https://github.com/tnfe/limu">limu</a>，一个比immer更高效的js不可变操作库</p>







标题：基于 React 拖动配置大屏的后台管理系统欢迎体验
作者：myfirebug
发布日期：发布于 6 个月前
文章内容：<h1>基于 React 拖动配置大屏的后台管理系统</h1>
<p>bigscreen 是一个高效的拖拽式低代码数据可视化开发平台，将图表或页面元素封装为基础组件，无需编写代码即可制作数据大屏，减少心智负担。</p>
<p>项目纯前端-Demo 地址：<a href="https://myfirebug.github.io/bigscreen/index.html#/login">https://myfirebug.github.io/bigscreen/index.html#/login</a></p>
<p>用户名：admin, 密码：123456</p>
<p><strong>工作台</strong></p>
<p><img src="https://myfirebug.github.io/example-images/bigscreen/0.jpg" alt="RUNOOB 图标"></p>
<p><strong>大屏展示</strong></p>
<p><img src="https://myfirebug.github.io/example-images/bigscreen/1.jpg" alt="RUNOOB 图标"></p>
<p><strong>主要依赖：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>react</td>
<td>18.0.0</td>
<td>react-dom</td>
<td>18.0.0</td>
</tr>
<tr>
<td>typescript</td>
<td>4.6.3</td>
<td>jsoneditor</td>
<td>9.9.0</td>
</tr>
<tr>
<td>redux</td>
<td>4.1.2</td>
<td>react-redux</td>
<td>7.2.8</td>
</tr>
<tr>
<td>react-rnd</td>
<td>10.3.7</td>
<td>redux-logger</td>
<td>3.0.6</td>
</tr>
<tr>
<td>redux-persist</td>
<td>6.0.0</td>
<td>redux-thunk</td>
<td>2.4.1</td>
</tr>
<tr>
<td>react-app-rewire</td>
<td>2.2.1</td>
<td>echarts</td>
<td>5.3.2</td>
</tr>
<tr>
<td>echarts-wordcloud</td>
<td>2.0.0</td>
<td>axios</td>
<td>0.26.1</td>
</tr>
<tr>
<td>cross-env</td>
<td>7.0.3</td>
<td>customize-cra</td>
<td>1.0.0</td>
</tr>
<tr>
<td>antd</td>
<td>4.19.3</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>开发环境</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>版本</th>
<th>名称</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>node</td>
<td>16.17.0</td>
<td>npm</td>
<td>8.15.0</td>
</tr>
</tbody>
</table>
<p><strong>已完成功能</strong></p>
<table>
<thead>
<tr>
<th>页面</th>
<th>是否完成（功能）</th>
</tr>
</thead>
<tbody>
<tr>
<td>登录</td>
<td>是</td>
</tr>
<tr>
<td>首页</td>
<td>是</td>
</tr>
<tr>
<td>报表管理</td>
<td>是</td>
</tr>
<tr>
<td>大屏配置</td>
<td>是</td>
</tr>
<tr>
<td>-</td>
<td>新增、编辑、删除页面功能（不能编辑、删除当面页面）</td>
</tr>
<tr>
<td>-</td>
<td>项目配置功能</td>
</tr>
<tr>
<td>-</td>
<td>图层管理功能</td>
</tr>
<tr>
<td>-</td>
<td>组件配置功能</td>
</tr>
<tr>
<td>-</td>
<td>数据配置功能（组组件里面的组件可以选择是否使用组的接口数据）</td>
</tr>
<tr>
<td>-</td>
<td>组件坐标功能</td>
</tr>
<tr>
<td>-</td>
<td>组组件有联动功能（配置联动功能时，先配置组组件的数据接口地址和请求参数，另只有组组才有添加表单组件的功能）</td>
</tr>
<tr>
<td>-</td>
<td>分组、拆分、复制、删除、上移、下移、左移、右移、上移一层、下移一层、置顶图层、置底图标</td>
</tr>
<tr>
<td>大屏预览</td>
<td>是</td>
</tr>
</tbody>
</table>
<p><strong>已完成的组件</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>名称</th>
<th>名称</th>
<th>名称</th>
<th>名称</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本</td>
<td>基础文本</td>
<td>时间文本</td>
<td>数字滚动</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>图片</td>
<td>图片</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>表格</td>
<td>基础表格</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>折线图</td>
<td>基础折线图</td>
<td>基础平滑折线图</td>
<td>基础面积图</td>
<td>基础纵向折线图</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>柱状图</td>
<td>基础柱状图</td>
<td>带背景色的柱状图</td>
<td>坐标轴刻度与标签对齐</td>
<td>圆角柱状图</td>
<td>纵向柱状图</td>
<td>堆积柱状图</td>
</tr>
<tr>
<td>饼图</td>
<td>基础饼图</td>
<td>圆环饼图</td>
<td>南丁格尔图</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>雷达图</td>
<td>基础雷达图</td>
<td>圆形雷达图</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>漏斗图</td>
<td>基础漏斗图</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>散点图</td>
<td>基础散点图</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>表单</td>
<td>单选</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>emap</td>
<td>基础地图（线上跨域）</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>词云</td>
<td>基础词云</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h1>依赖安装、启动、打包</h1>
<pre class="prettyprint"><code>## 克隆

## 启动开发环境（开发调试时使用）
### `npm start`

## 构建测试项目
## `npm build:test`

## 构建正式项目
### `npm build:production`

</code></pre><h1>目录结构</h1>
<pre class="prettyprint"><code>bigscreen
├── src
│   ├── assets                       // 静态资源
│   ├── components                   // 公共组件
│   ├── config                       // 配置文件
│   ├── mock                         // 模拟接口
│   ├── pages                        // 页面
│   │   ├── configuration            // 大屏配置页面
│   │   ├── frame                    // 框架页面
│   │   ├── home                     // 首页页面
│   │   ├── login                    // 登录页面
│   │   ├── preview                  // 大屏展示页面
│   │   └── report                   // 大屏列表页面
│   ├── service                      // 接口服务
│   ├── store                        // 状态
│   ├── theme                        // echarts主题
│   ├── types                        // ts基本类型
│   ├── utils                        // 工具
│   └── widget                       // 组件及其配置
</code></pre><p>欢迎<a href="https://github.com/myfirebug/bigscreen">star</a></p>







标题：开发了一个基于fabric.js和Vue的图片编辑器，可自定义字体、素材、设计模板。
作者：nihaojob
发布日期：发布于 6 个月前
文章内容：<h2>简介</h2>
<p>项目地址：<a href="https://github.com/nihaojob/vue-fabric-editor">https://github.com/nihaojob/vue-fabric-editor</a>
预览地址：<a href="https://nihaojob.github.io/vue-fabric-editor/">https://nihaojob.github.io/vue-fabric-editor/</a>
<img src="https://static.cnodejs.org/FvIBZQEfUfIeCUOu6BCi3dZMec6j" alt="demo.png"></p>
<h3>已有功能</h3>
<p>导入JSON文件
保存为PNG、SVG、JSON文件
插入SVG、图片文件
多元素水平、垂直对齐方式
组合/拆分组合
图层及顺序调整
撤销/重做
背景属性设置
外观属性/字体属性/描边/阴影
自定义字体
自定义模板素材</p>
<p>有感兴趣的大家一起来维护呀。</p>







标题：n.e is not a function 问题记录
作者：xiaoxiaojx
发布日期：发布于 7 个月前
文章内容：<p><img src="https://user-images.githubusercontent.com/23253540/192844916-1470a651-c3b1-473e-bbc1-aeafffe52415.png" alt="image">
原文链接: <a href="https://github.com/xiaoxiaojx/blog/issues/43">https://github.com/xiaoxiaojx/blog/issues/43</a></p>
<h2>问题简述</h2>
<pre class="prettyprint language-js"><code>TypeError: n.e is not a function 
</code></pre><p>a 同学说我写的 npm 包 <a href="/user/xxfe">@xxfe</a>/pkg 在 x 项目使用时发布到测试环境报了如上的错误, 但是开发环境没有报错。接着我看了一下 node_modules 中这个包的代码, 这个 Promise 都没 await 咋会被 catch 且还真的被捕获打印了错误日志 🤯, 这是什么瞎猫碰见死耗子的操作 …</p>
<pre class="prettyprint language-js"><code>// node_modules/[@xxfe](/user/xxfe)/pkg

try {
	this.aesUtilPromise = import('../aes-util')
} catch (e) {
	console.info('123  ========', e);
}
</code></pre><p>仅看 node_modules 中的代码并未发现明显的错误, 其实我们应该看的是 <a href="/user/xxfe">@xxfe</a>/pkg 打包后的代码</p>
<pre class="prettyprint language-js"><code>// dist/static/js/xxx.js

try {
	this.aesUtilPromise=n.e(3)
} catch(r) {
	console.info("123  ========",r)
}
</code></pre><p>打包后的代码就发现了错误的源头 n.e</p>
<p>熟悉 webpack 的同学就知道动态 import 函数打包后会被 <strong>webpack_require</strong>.e 函数给替换, 其原理就是通过动态创建一个 script 标签来加载一个 js, 如下即函数的代码</p>
<pre class="prettyprint language-js"><code>/******/  __webpack_require__.e = function requireEnsure(chunkId) {
/******/   var promises = [];
/******/
/******/
/******/   // JSONP chunk loading for javascript
/******/
/******/   var installedChunkData = installedChunks[chunkId];
/******/   if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/    // a Promise means "currently loading".
/******/    if(installedChunkData) {
/******/     promises.push(installedChunkData[2]);
/******/    } else {
/******/     // setup Promise in chunk cache
/******/     var promise = new Promise(function(resolve, reject) {
/******/      installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/     });
/******/     promises.push(installedChunkData[2] = promise);
/******/
/******/     // start chunk loading
/******/     var script = document.createElement('script');
/******/     var onScriptComplete;
/******/
/******/     script.charset = 'utf-8';
/******/     script.timeout = 120;
/******/     if (__webpack_require__.nc) {
/******/      script.setAttribute("nonce", __webpack_require__.nc);
/******/     }
/******/     script.src = jsonpScriptSrc(chunkId);
/******/     if (script.src.indexOf(window.location.origin + '/') !== 0) {
/******/      script.crossOrigin = "anonymous";
/******/     }
/******/     // create error before stack unwound to get useful stacktrace later
/******/     var error = new Error();
/******/     onScriptComplete = function (event) {
/******/     // ...
/******/     };
/******/     var timeout = setTimeout(function(){
/******/      onScriptComplete({ type: 'timeout', target: script });
/******/     }, 120000);
/******/     script.onerror = script.onload = onScriptComplete;
/******/     document.head.appendChild(script);
/******/    }
/******/   }
/******/   return Promise.all(promises);
/******/  };
</code></pre><h2>问题排查</h2>
<p>那么为什么代码中用到了 import 函数, webpack 却没有注入 <strong>webpack_require</strong>.e 函数的实现了 ?</p>
<p>此时我们只能看 webpack 的代码实现, 可以发现当 Object.keys(chunkMaps.hash).length 条件为 true 时, 才会注入 ${this.requireFn}.e 函数</p>
<pre class="prettyprint language-js"><code>// webpack/lib/MainTemplate.js

this.hooks.requireExtensions.tap("MainTemplate", (source, chunk, hash) =&gt; {
			const buf = [];
			const chunkMaps = chunk.getChunkMaps();
			// Check if there are non initial chunks which need to be imported using require-ensure
			if (Object.keys(chunkMaps.hash).length) {
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(`${this.requireFn}.e = function requireEnsure(chunkId) {`);
				buf.push(Template.indent("var promises = [];"));
				buf.push(
					Template.indent(
						this.hooks.requireEnsure.call("", chunk, hash, "chunkId")
					)
				);
				buf.push(Template.indent("return Promise.all(promises);"));
				buf.push("};");
			}
            // ...
}
</code></pre><p>顺着函数调用顺序发现关键是 getAllAsyncChunks 函数返回值 chunks 集合不为空即可</p>
<pre class="prettyprint language-js"><code>// webpack/lib/Chunk.js

getAllAsyncChunks() {
		const queue = new Set();
		const chunks = new Set();

		const initialChunks = intersect(
			Array.from(this.groupsIterable, g =&gt; new Set(g.chunks))
		);

		for (const chunkGroup of this.groupsIterable) {
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		for (const chunkGroup of queue) {
			for (const chunk of chunkGroup.chunks) {
				if (!initialChunks.has(chunk)) {
					chunks.add(chunk);
				}
			}
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		return chunks;
}
</code></pre><p>chunks 集合只有一处往集合增加数据的逻辑。initialChunks 可以理解为首屏 html 中 script 标签的 js, 通常是 main.js 及其运行前依赖的 js, 比如 main.js 需要依赖 react, react-dom 等 js 的前置运行。</p>
<pre class="prettyprint language-js"><code>if (!initialChunks.has(chunk)) {
	chunks.add(chunk);
}
</code></pre><p>因为业务项目 webpackConfig.optimizationa.splitChunks 的配置把 a 同学写的 <a href="/user/xxfe">@xxfe</a>/pkg 包都打入到了 xxfe_vendor 文件中, 而 <a href="/user/xxfe">@xxfe</a>/ scope 下的依赖被业务项目大量使用, 所以无疑是业务项目 main.js 前置依赖的一个 js, 故 xxfe_vendor 在首屏 html 中 script 标签的 js 中</p>
<p>所以 xxfe_vendor 是 initialChunks 中的其中一个, 故此处 if 为 false</p>
<pre class="prettyprint language-js"><code>xxfe_vendor: {
  name: 'xxfe_vendor',
  chunks: 'all',
  priority: 8,
  enforce: true,
  test: (module) =&gt; {
    const resource = getModulePath(module)
    if (/[@xxfe](/user/xxfe)(\\|\/)/.test(resource)) {
      return true
    }
    return false
  },
},
</code></pre><p>至此我们理清了导致问题的原因, <a href="/user/xxfe">@xxfe</a>/pkg 中的 import 函数引用的 js 及其自身代码由于分包的 splitChunks 设置都被打入到了 xxfe_vendor 中, 而 xxfe_vendor 又是业务项目 main.js 前置运行依赖的 js, 故 webpack 错误的认为你不需要 <strong>webpack_require</strong>.e 函数</p>
<ul>
<li>webpack 版本: 4.39.0</li>
</ul>
<blockquote>
<p>Q: 这个算谁的 bug ?</p>
<p>A: webpack 的 bug。因为不能说用户需要加载的 js 如果在首屏其中之一, 就不注入 <strong>webpack_require</strong>.e 函数的实现。业务项目通过 splitChunks 进行分包不是 npm 包的作者所能决定, 是否注入 <strong>webpack_require</strong>.e 函数的实现应该由是否有 import 函数语法来决定。</p>
<p>Q: 为什么开发环境没有报错 ?</p>
<p>A: 业务项目的 splitChunks 设置了只在生产构建生效</p>
</blockquote>
<h2>问题解决</h2>
<p>将如下的 <a href="https://webpack.js.org/plugins/split-chunks-plugin/#splitchunkschunks">chunks</a> 字段由 all 改为了 initial, 表示该分包设置将不要影响到动态 import 函数异步加载的 js (该类型为 async chunks), 使得 <a href="/user/xxfe">@xxfe</a>/pkg 将不会被合入 xxfe_vendor 文件中, 那么如上的 initialChunks 也将不包含 <a href="/user/xxfe">@xxfe</a>/pkg, 从而 webpack 也会如约注入 <strong>webpack_require</strong>.e 函数的实现</p>
<pre class="prettyprint language-js"><code>xxfe_vendor: {
  name: 'xxfe_vendor',
  chunks: 'initial',
  priority: 8,
  enforce: true,
  test: (module) =&gt; {
    const resource = getModulePath(module)
    if (/[@xxfe](/user/xxfe)(\\|\/)/.test(resource)) {
      return true
    }
    return false
  },
},
```****</code></pre>






标题：j-spring  最轻量级的IOC （TS 版本）
作者：892280082
发布日期：发布于 7 个月前
文章内容：<p>纯es6.
github:<a href="https://github.com/892280082/j-spring">j-spring</a></p>
<h1>J-SPRING</h1>
<blockquote>
<p>Spring for TS</p>
</blockquote>
<h1>install</h1>
<pre class="prettyprint language-js"><code>npm install j-spring
</code></pre><h1>Usage</h1>
<h2>example</h2>
<pre class="prettyprint language-js"><code>  import { spring } from "j-spring";

  it('autowired by special interface',()=&gt;{

    interface A {
      v():number;
    }
    
    @Component
    class A1 implements A{
      v(): number {
        return 1;
      }
    }
    
    @Component
    class A2 implements A{
      v(): number {
        return 2;
      }
    }

    @Component
    class Application {
      
      @Autowired&lt;A&gt;({clazz:A1})
      a1:A;

      @Autowired&lt;A&gt;({clazz:A2})
      a2:A;

      main(c:number){
        return this.a1.v()+this.a2.v()+c;
      }
    }

    expect(spring.getBean(Application).main(3)).toBe(6);

  })
</code></pre><h2>inject profile infomation</h2>
<pre class="prettyprint language-js"><code>import { spring } from "j-spring";

describe('resource config load test',()=&gt;{

  @Component
  class Student {
      @Value({path:'student.name',type:String})
      name:String;
      @Value({path:'student.age',type:Number})
      age:20;
      @Value({path:'student.city',type:String})
      city:String
      
      getMsg(){
          return ''+this.name+this.age+this.city;
      }
  }


  @Component
  class Application {

      @Value({path:'app.msg',type:String})
      appMsg:string;

      @Autowired({clazz:Student})
      student:Student;

      public main(){
          return this.appMsg+this.student.getMsg();
      }

  }

  it('A simple set value',()=&gt;{

      spring.loadConfig({
        'app.msg':'hello',
        student:{
            name:'lina',
            age:20,
            city:'youda'
        }
      })

      expect(spring.launch(Application)).toEqual(`hello! my name is lina and 20 years old!`)

  })

})
</code></pre><h2>aop</h2>
<pre class="prettyprint language-js"><code>it('test sample Aop',()=&gt;{

    import { spring,BeanPostProcessor } from "j-spring";

    //create Annotation
    const SupperCaseParamter = spring.methodAnnotationGenerator('SupperCaseParamter',{})

    @Component
    class SupperCaseParamterBeanProcessor implements BeanPostProcessor {
        getSort(): number {
            return 100;
        }
        postProcessBeforeInitialization(bean: any, _beanDefine: BeanDefine): Object {
            return bean;
        }
        postProcessAfterInitialization(bean: any, beanDefine: BeanDefine): Object {
            beanDefine.methodList.filter(m =&gt; m.hasAnnotation(SupperCaseParamter)).forEach(m =&gt; {
                
                const method = bean[m.name];

                bean[m.name] = function(...args:any[]){
                    return  method.apply(bean,args.map(a =&gt; {
                        return typeof a === 'string' ? (a as string).toUpperCase() : a;
                    }));
                }

            })
            return bean;
        }
        
    }

    @Component
    class Application {

        @SupperCaseParamter
        main(name:string){
            return name;
        }

    }

    expect(spring.bind(SupperCaseParamterBeanProcessor).getBean(Application).main('hello')).toEqual('HELLO');

})
</code></pre><h2>costom annotation</h2>
<pre class="prettyprint language-js"><code>import { spring, SpringContainer  } from '../src';

//diy annotation
const Controller = (path:string) =&gt; spring.classAnnotationGenerator('Controller',{path},Controller)

const ResfulApi = spring.classAnnotationGenerator('ResfulApi',{})

const Inject = (path:string) =&gt; spring.fieldAnnotationGenerator('Inject',{path},Inject);

const Get = (path:string) =&gt; spring.methodAnnotationGenerator('Get',{path},Get);

const Query = (fieldName:string) =&gt; spring.paramterAnnotationGenerator('Query',fieldName,{},Query)


describe('test custom annotation',()=&gt;{

    it('it should be work',()=&gt;{

        @Controller('/apiController')
        @ResfulApi
        class ApiController extends SpringContainer{

            @Inject('small pigBank')
            pigBank:String;
        
            @Get('/say')
            async say(@Query('user') user:string){
                return user;
            }

            main(){

                let result:any[] =[];

                this.getBeanDefineMap().forEach((_v,k) =&gt; {
                    const data = {
                        'class':k.clazz,
                        'anno-length':k.annotationList.length,
                        'anno-class':k.annotationList.map(a =&gt; a.clazz),
                        'anno-param-list':k.annotationList.map(a =&gt; a.params),
                        'field-list':k.fieldList.map(f =&gt; {
                            return {
                                'name':f.name,
                                'anno-list':f.annotationList.map(a =&gt; a.clazz),
                                'anno-param-list':f.annotationList.map(a =&gt; a.params)
                            }
                        }),
                        'method-list':k.methodList.map(m =&gt; {
                            return {
                                'name':m.name,
                                'anno-list':m.annotationList.map(m =&gt; m.clazz),
                                'anno-params':m.annotationList.map(m =&gt; m.params),
                                'field-list':m.paramterDefineList.map(pb =&gt; {
                                    return {
                                        'name':pb.name,
                                        'index':pb.index,
                                        'anno-list':pb.annotationList.map(a =&gt; a.clazz)
                                    }
                                })
                            }
                        })
                    }
                    result.push(data)
                })

                return result;
            }
        
        }

        expect(spring.launch(ApiController)).toEqual([
            {
                'class':ApiController,
                'anno-length':2,
                'anno-class':[ResfulApi,Controller],
                'anno-param-list':[{},{path:'/apiController'}],
                'field-list':[{
                    'name':'pigBank',
                    'anno-list':[Inject],
                    'anno-param-list':[{path:'small pigBank'}]
                }],
                'method-list':[
                    {
                        'name':'say',
                        'anno-list':[Get],
                        'anno-params':[{path:'/say'}],
                        'field-list':[
                            {
                                name:'user',
                                index:0,
                                'anno-list':[Query]
                            }
                        ]
                    },
                    
                ]
            }
        ])

    })

});

</code></pre><h2>replace dependence</h2>
<pre class="prettyprint language-js"><code>  it('replace autowired class',()=&gt;{
    
    @Component
    class A {
      value(){
        return 1;
      }
    }    

    @Component
    class A100 extends A {
      value(): number {
        return 100;        
      }
    }

    @Component
    class Application {

      @Autowired({clazz:A})
      a:A;

      main(){
        return this.a.value();
      }

    }

    expect(spring.replaceClass(A,A100).launch(Application)).toBe(100)

  })
</code></pre>






标题：基于声网 SDK 实现 macOS 端的一对一视频通话
作者：kylezhang
发布日期：发布于 7 个月前
文章内容：<p>音视频互动包括直播是当前比较热门的玩法，我们经常见到有 PK 连麦、直播答题、一起 KTV、电商直播、互动大班课、视频相亲等。本文将演示<code>如何通过声网 SDK 在 macOS 端实现一个视频通话应用</code>。</p>
<h2><strong>前提条件</strong></h2>
<ul>
<li>
<p>Xcode 9.0 或以上版本</p>
</li>
<li>
<p>支持 macOS 10.10 或以上版本的 macOS 设备</p>
</li>
<li>
<p>有效的<a href="https://console.agora.io/">声网账户（免费注册）</a></p>
</li>
</ul>
<p>注：如果你的网络环境部署了防火墙，请根据声网文档中心的「应用企业防火墙限制」打开相关端口。</p>
<h2><strong>准备开发环境</strong></h2>
<p>本节介绍如何创建项目，并将声网 SDK 集成至你的项目中。</p>
<h3><strong>创建 macOS 项目</strong></h3>
<p>参考以下步骤创建一个 macOS 项目。若已有 macOS 项目，可以跳脱这一步，直接查看本文「集成 SDK」小节。</p>
<ol>
<li>
<p>打开 Xcode 并点击 Create a new Xcode project。</p>
</li>
<li>
<p>选择项目类型为 Cocoa App，并点击 Next。</p>
</li>
<li>
<p>输入项目信息，如项目名称、开发团队信息、组织名称和语言，并点击 Next。</p>
</li>
</ol>
<p>如果你没有添加过开发团队信息，会看到 Add account… 按钮。点击该按钮并按照屏幕提示登入 Apple ID，完成后即可选择你的账户作为开发团队。</p>
<ol>
<li>
<p>选择项目存储路径，并点击 Create。</p>
</li>
<li>
<p>进入 TARGETS &gt; Project Name &gt; General &gt; Signing 菜单，选择 Automatically manage signing，并在弹出菜单中点击 Enable Automatic。
<img src="https://img-blog.csdnimg.cn/1ef09d7233494e95a11a6e4fc79c3a78.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3><strong>集成 SDK</strong></h3>
<p>选择如下任意一种方式将声网 SDK 集成到你的项目中。</p>
<p>方法一：使用 CocoaPods 自动集成</p>
<ol>
<li>
<p>开始前确保你已安装 Cocoapods。参考 Getting Started with CocoaPods 安装说明。</p>
</li>
<li>
<p>在 Terminal 里进入项目根目录，并运行  <code>pod init</code>  命令。项目文件夹下会生成一个 Podfile 文本文件。</p>
</li>
<li>
<p>打开 Podfile 文件，修改文件为如下内容。注意将  <code>Your App</code>  替换为你的 Target 名称。</p>
</li>
</ol>
<pre class="prettyprint"><code># platform :macOS, '10.11' use_frameworks!
target 'Your App' do
  pod 'AgoraRtcEngine_macOS'
end
</code></pre><ol>
<li>
<p>在 Terminal 内运行  <code>pod update</code>  命令更新本地库版本。</p>
</li>
<li>
<p>运行  <code>pod install</code>  命令安装声网 SDK。成功安装后，Terminal 中会显示  <code>Pod installation complete!</code> ，此时项目文件夹下会生成一个 xcworkspace 文件。</p>
</li>
<li>
<p>打开新生成的 xcworkspace 文件。</p>
</li>
</ol>
<p>方法二：手动复制 SDK 文件</p>
<ol>
<li>
<p>前往 SDK 下载页面，获取最新版的声网 SDK，然后解压。</p>
</li>
<li>
<p>将 libs 文件夹内的 AgoraRtcEngineKit.framework 文件复制到项目文件夹下。</p>
</li>
<li>
<p>打开 Xcode，进入 TARGETS &gt; Project Name &gt; Build Phases &gt; Link Binary with Libraries 菜单，点击 + 添加如下库。在添加 AgoraRtcEngineKit.framework 文件时，还需在点击 + 后点击 Add Other…，找到本地文件并打开。
<img src="https://img-blog.csdnimg.cn/273931c9e7164d358d4857ee224e7958.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>AgoraRtcEngineKit.framework</p>
</li>
<li>
<p>Accelerate.framework</p>
</li>
<li>
<p>CoreWLAN.framework</p>
</li>
<li>
<p>libc++.dylib</p>
</li>
<li>
<p>libresolv.9.tbd</p>
</li>
<li>
<p>SystemConfiguration.framework</p>
</li>
<li>
<p>VideoToolbox.framework</p>
</li>
</ol>
<h3><strong>添加媒体设备权限</strong></h3>
<ol>
<li>根据场景需要，打开 Xcode ，在 info.plist 文件中，点击 + 图标开始添加如下内容，获取相应的设备权限：
<img src="https://img-blog.csdnimg.cn/236ef650f0d644d6a74270a101bbaf3f.png#pic_center" alt="在这里插入图片描述">
<img src="https://img-blog.csdnimg.cn/d995fc35b28c4edc8842fe4bf6cde51f.jpeg#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ol>
<li>若你的项目已启用 App Sandbox 或 Hardened Runtime 设置，则需勾选如下内容，获取相应的设备权限：
<img src="https://img-blog.csdnimg.cn/7b0cfc46b0e14700b280a1c6304cba32.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/9f74f3d0b3a24694a17b39a658cf92e1.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2><strong>实现</strong><a href="https://www.agora.io/cn/game/">音视频通话</a></h2>
<p>本节介绍如何实现音视频通话。视频通话的 API 调用时序见下图：
<img src="https://img-blog.csdnimg.cn/8589a9c3faf04014a988b4195356fa99.png#pic_center" alt="在这里插入图片描述"></p>
<h3><strong>1. 创建用户界面</strong></h3>
<p>根据场景需要，为你的项目创建音视频通话的用户界面。若已有用户界面，可以直接查看导入类。</p>
<p>如果你想实现一个视频通话，我们推荐你添加如下 UI 元素：</p>
<ul>
<li>
<p>本地视频窗口</p>
</li>
<li>
<p>远端视频窗口</p>
</li>
<li>
<p>结束通话按钮</p>
</li>
</ul>
<p>当你使用示例项目中的 UI 设计时，你将会看到如下界面：
<img src="https://img-blog.csdnimg.cn/c4c80eb3322d49ffbbe8b6e83f7c49ed.png#pic_center" alt="在这里插入图片描述"></p>
<h3>2. 导入类</h3>
<p>在项目中导入  <code>AgoraRtcEngineKit</code>  类：</p>
<pre class="prettyprint"><code>// Objective-C
#import &lt;AgoraRtcEngineKit/AgoraRtcEngineKit.h&gt;
// Swift
import AgoraRtcEngineKit
</code></pre><p>声网 Native SDK 默认使用 libc++ (LLVM)，如需使用 libstdc++ (GNU)，请联系 <a href="mailto:sales@agora.io">sales@agora.io</a>。SDK 提供的库是 Fat Image，包含 32/64 位模拟器、32/64 位真机版本。</p>
<h3>3. 初始化 AgoraRtcEngineKit</h3>
<p>在调用其他声网 API 前，需要创建并初始化  <code>AgoraRtcEngineKit</code>  对象。</p>
<p>你需要在该步骤中填入项目的 App ID。请参考如下步骤在控制台创建声网项目并获取 App ID。</p>
<ol>
<li>登录<a href="https://console.agora.io/">控制台</a></li>
</ol>
<ol>
<li>
<p>点击创建，按照屏幕提示设置<code>"项目名"</code>和<code>"使用场景"</code>，鉴权机制，在测试阶段可以选择<code>“调试模式：APP ID”</code>然后点击提交。</p>
</li>
<li>
<p>在项目管理页面，你可以获取该项目的 <code>App ID</code>。</p>
</li>
</ol>
<p>调用  <code>sharedEngineWithAppId</code>  方法，传入获取到的 App ID，即可初始化  <code>AgoraRtcEngineKit</code> 。</p>
<p>你还可以根据场景需要，在初始化时注册想要监听的回调事件，如本地用户加入频道及解码远端用户视频首帧等。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)initializeAgoraEngine {
    // 输入 App ID 并初始化 AgoraRtcEngineKit 类
    self.agoraKit = [AgoraRtcEngineKit sharedEngineWithAppId:appID delegate:self];
}
</code></pre><pre class="prettyprint"><code>// Swift
func initializeAgoraEngine() {
   // 输入 App ID 并初始化 AgoraRtcEngineKit 类。
   agoraKit = AgoraRtcEngineKit.sharedEngine(withAppId: AppID, delegate: self)
}
</code></pre><h3>4. 设置本地视图</h3>
<p>如果你想实现一个语音通话，可以直接查看加入频道。</p>
<p>成功初始化  <code>AgoraRtcEngineKit</code>  对象后，需要在加入频道前设置本地视图，以便在通话中看到本地图像。参考以下步骤设置本地视图：</p>
<ul>
<li>
<p>调用  <code>enableVideo</code>  方法启用视频模块。</p>
</li>
<li>
<p>调用  <code>setupLocalVideo</code>  方法设置本地视图。</p>
</li>
</ul>
<pre class="prettyprint"><code>// Objective-C
// 启用视频模块
[self.agoraKit enableVideo];
- (void)setupLocalVideo {
    AgoraRtcVideoCanvas *videoCanvas = [[AgoraRtcVideoCanvas alloc] init];
    videoCanvas.uid = 0;
    videoCanvas.view = self.localVideo;
    videoCanvas.renderMode = AgoraVideoRenderModeHidden;
    // 设置本地视图
    [self.agoraKit setupLocalVideo:videoCanvas];
}
// Swift
// 启用视频模块
agoraKit.enableVideo()
func setupLocalVideo() {
  let videoCanvas = AgoraRtcVideoCanvas()
  videoCanvas.uid = 0
  videoCanvas.view = localVideo
  videoCanvas.renderMode = .hidden
  // 设置本地视图
  agoraKit.setupLocalVideo(videoCanvas)
}
</code></pre><h3>5. 加入频道</h3>
<p>完成初始化和设置本地视图后（视频通话场景），你就可以调用  <code>joinChannelByToken</code>  方法加入频道。你需要在该方法中传入如下参数：</p>
<ul>
<li>
<p><code>channelId</code> : 传入能标识频道的频道 ID。输入频道 ID 相同的用户会进入同一个频道。</p>
</li>
<li>
<p><code>token</code> ：传入能标识用户角色和权限的 Token。可设为如下一个值：</p>
</li>
</ul>
<p>若项目已启用 App 证书，请使用 Token。</p>
<ul>
<li>
<p><code>nil</code></p>
</li>
<li>
<p>临时 Token。临时 Token 服务有效期为 24 小时。你可以在控制台里生成一个临时 Token，详见获取临时 Token。</p>
</li>
<li>
<p>在你的服务器端生成的 Token。在安全要求高的场景下，我们推荐你使用此种方式生成的 Token，详见生成 Token。</p>
</li>
<li>
<p><code>uid</code> : 本地用户的 ID。数据类型为整型，且频道内每个用户的  <code>uid</code>  必须是唯一的。若将  <code>uid</code>  设为 0，则 SDK 会自动分配一个  <code>uid</code> ，并在  <code>joinSuccessBlock</code>  回调中报告。</p>
</li>
<li>
<p><code>joinSuccessBlock</code> ：成功加入频道回调。 <code>joinSuccessBlock</code>  优先级高于  <code>didJoinChannel</code> ，2 个同时存在时， <code>didJoinChannel</code>  会被忽略。需要有  <code>didJoinChannel</code>  回调时，请将  <code>joinSuccessBlock</code>  设置为  <code>nil</code> 。</p>
</li>
</ul>
<p>更多的参数设置注意事项请参考 joinChannelByToken 接口中的参数描述。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)joinChannel {
    // 加入频道
    [self.agoraKit joinChannelByToken:token channelId:@"demoChannel1" info:nil uid:0 joinSuccess:^(NSString *channel, NSUInteger uid, NSInteger elapsed) {
    }];
}
</code></pre><pre class="prettyprint"><code>// Swift
func joinChannel() {
    // 加入频道
    agoraKit.joinChannel(byToken: Token, channelId: "demoChannel1", info:nil, uid:0) { [unowned self] (channel, uid, elapsed) -&gt; Void in}
    self.isLocalVideoRender = true
            self.logVC?.log(type: .info, content: "did join channel")
        }
        isStartCalling = true
}
</code></pre><h3>6. 设置远端视图</h3>
<p>视频通话中，通常你也需要看到其他用户。在加入频道后，可通过调用  <code>setupRemoteVideo</code>  方法设置远端用户的视图。</p>
<p>远端用户成功加入频道后，SDK 会触发  <code>firstRemoteVideoDecodedOfUid</code>  回调，该回调中会包含这个远端用户的  <code>uid</code>  信息。在该回调中调用  <code>setupRemoteVideo</code>  方法，传入获取到的  <code>uid</code> ，设置远端用户的视图。</p>
<pre class="prettyprint"><code>// Objective-C
// 监听 firstRemoteVideoDecodedOfUid 回调。
// SDK 接收到第一帧远端视频并成功解码时，会触发该回调。
// 可以在该回调中调用 setupRemoteVideo 方法设置远端视图。
- (void)rtcEngine:(AgoraRtcEngineKit *)engine firstRemoteVideoDecodedOfUid:(NSUInteger)uid size: (CGSize)size elapsed:(NSInteger)elapsed {
    if (self.remoteVideo.hidden) {
        self.remoteVideo.hidden = NO;
    }
    AgoraRtcVideoCanvas *videoCanvas = [[AgoraRtcVideoCanvas alloc] init];
    videoCanvas.uid = uid;
    videoCanvas.view = self.remoteVideo;
    videoCanvas.renderMode = AgoraVideoRenderModeHidden;
    // 设置远端视图
    [self.agoraKit setupRemoteVideo:videoCanvas];
}
</code></pre><pre class="prettyprint"><code>// Swift
// 监听 firstRemoteVideoDecodedOfUid 回调。
// SDK 接收到第一帧远端视频并成功解码时，会触发该回调。
// 可以在该回调中调用 setupRemoteVideo 方法设置远端视图。
func rtcEngine(_ engine: AgoraRtcEngineKit, firstRemoteVideoDecodedOfUid uid:UInt, size:CGSize, elapsed:Int) {
        isRemoteVideoRender = true
        let videoCanvas = AgoraRtcVideoCanvas()
        videoCanvas.uid = uid
        videoCanvas.view = remoteVideo
        videoCanvas.renderMode = .hidden
        // 设置远端视图
        agoraKit.setupRemoteVideo(videoCanvas)
    }
</code></pre><h3>7. 离开频道</h3>
<p>根据场景需要，如结束通话、关闭 App 或 App 切换至后台时，调用  <code>leaveChannel</code>  离开当前通话频道。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)leaveChannel {
    // 离开频道。
    [self.agoraKit leaveChannel:^(AgoraChannelStats *stat)
}
// Swift
func leaveChannel() {
// 离开频道
 AgoraKit.leaveChannel(nil)
 AgoraKit.setupLocalVideo(nil)
 remoteVideo.removeFromSuperview()
 localVideo.removeFromSuperview()
 delegate?.VideoChatNeedClose(self)
 AgoraKit = nil
 view.window!.close()
 }
</code></pre><h3>示例代码</h3>
<p>你可以在 Agora-macOS-Tutorial-Objective-C-1to1/Agora-macOS-Tutorial-Swift-1to1 示例项目的 VideoChatViewController.m/VideoChatViewController.swift 文件中查看完整的源码和代码逻辑。</p>
<h2>运行/测试项目</h2>
<p>你可以在 macOS 设备中运行此项目。当成功开始视频通话时，你可以同时看到本地和远端的视图。</p>
<hr>
<p>如果遇到问题，可以在<a href="https://www.agora.io/cn/community/">RTE开发者社区</a> 发帖提问。</p>







标题：nodejs.cn 站长吃相太难看
作者：sbfkcel
发布日期：发布于 9 个月前
文章内容：<p>拿着开源的东西汉化个文档就收钱，吃相难看且恶心～～
没有开源的精神就不要参和到开源世界来
<img src="//static.cnodejs.org/Fuvnf4pAFcCE5oVHs7C49tMqE3VM" alt="Snipaste_2022-07-21_11-43-41.png"></p>







标题：想了解下并发查询数据库是否可行
作者：pwstrick
发布日期：发布于 7 个月前
文章内容：<p>我们这边有一个接口，里面会做很多的查询操作，会查各种表，单个表的查询其实并不慢，但是一旦查询的次数多了，加起来就会慢。
例如查询一个用户的信息，会连带着查相关的信息，这些信息保存在其他表里，那么现在想并发的查询这些账号的信息。
然后查好后再合并到一起。</p>







标题：rollup 如何处理动态的 require 呢？
作者：daGaiGuanYu
发布日期：发布于 7 个月前
文章内容：<p>我现在用 rollup 打包我的应用。
我的应用依赖 Knex，而 Knex 支持 mysql、sql server、oracle 等多种数据库，
因此 Knex 的代码中有 <code>require('tedious')</code>（sql server 的依赖）、<code>require('oracledb')</code>（oracle 的依赖）。
而我只需要 mysql，也只安装了 mysql。
而 rollup 打包后的文件，在最开始的地方就把 tedious、oracledb 等都导入了一遍……</p>
<p><a href="https://github.com/daGaiGuanYu/temp/tree/knex-rollup">问题复现 https://github.com/daGaiGuanYu/temp/tree/knex-rollup</a></p>







标题：使用 vue-class-setup 编写 class 风格组合式API，支持Vue2和Vue3
作者：1340641314
发布日期：发布于 7 个月前
文章内容：<h2>前言</h2>
<p>我司基于<code>vue-class-component</code>开发的项目有上百个，其中部署的 SSR 服务也接近100个，如此庞大体量的项目一开始的时候还幻想着看看是否要升级Vue3，结果调研一番下来，才发现<code>vue-class-component</code>对Vue3的支持，最后一个版本发布都过去两年了，迟迟还没有发布正式版本。目前基本上处于无人维护的状态，而且升级存在着大量的破坏性更新，对于未来是否还要继续使用Vue3现在还是持保留意见，但是不妨碍我们先把组件库做成Vue2和Vue3通用，于是就有了本文。</p>
<p>在过去的三年里，<code>vue-class-component</code>最大的问题是就是无法正确的校验组件的传参，事件类型，这给我带来了巨大的阴影，在经过一番调研后，惊喜的发现使用<code>defineComponent</code>定义的组件，在Vue2.7和3.x都可以正确的识别类型，所以先计划内部的组件库先做到同时支持Vue2和Vue3，如果后面还要继续采用Vue3就变得容易得多。</p>
<p>于是，回到了开头，调研了一番<code>vue-class-component</code>在Vue3的支持，目前最新的版本是<a href="https://www.npmjs.com/package/vue-class-component/v/8.0.0-rc.1">8.0.0-rc.1</a>，结果大失所望，目前基本上处于无人维护的状态，社区内又没有一个能满足我需求的，同时支持Vue2和Vue3的。</p>
<h2>诞生想法</h2>
<p>鉴于<code>vue-class-component</code>组件目前无法做到正确的组件类型检验，当我惊喜的发现组合式API写出来的代码可以被正确的识别类型时，诞生了一个使用 class 风格来编写组合式API的想法，于是花费一个月的实践，踩遍了所有的坑，终于诞生了<a href="https://github.com/fmfe/vue-class-setup">vue-class-setup</a>，一个使用 class 风格来编写代码的库，它gzip压缩后，1kb大小。</p>
<h2>快速开始</h2>
<pre class="prettyprint language-bash"><code>npm install vue-class-setup
</code></pre><pre class="prettyprint language-vue"><code>&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';
import { Setup, Context } from 'vue-class-setup';

// Setup 和 Context 必须一起工作
@Setup
class App extends Context {
    private _value = 0;
    public get text() {
        return String(this._value);
    }
    public set text(text: string) {
        this._value = Number(text);
    }
    public onClick() {
        this._value++;
    }
}
export default defineComponent({
    // 注入类实例的逻辑
    ...App.inject(),
});
&lt;/script&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;p&gt;{{ text }}&lt;/p&gt;
        &lt;button @click="onClick()"&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>尝试多很多种方案，最终采用了上面的形式为最佳实践，它无法做到<code>export default</code>直接导出一个类，必须使用<code>defineComponent</code> 来包装一层，因为它只是一个<code>组合类（API）</code>，并非是一个组件。</p>
<h2>最佳实践</h2>
<pre class="prettyprint language-vue"><code>&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';
import { Setup, Define } from 'vue-class-setup';

// 传入组件的 Props 和 Emit，来让组合类获取正确的 `Props` 和 `Emit` 类型
@Setup
class App extends Define&lt;Props, Emit&gt; {
    // ✨ 你可以直接这里定义Props的默认值，不需要像 vue-property-decorator 那样使用一个 Prop 装饰器来定义
    public readonly dest = '--';
    // 自动转换成 Vue 的 'computed'
    public get text() {
        return String(this.value);
    }
    public click(evt: MouseEvent) {
        // 发射事件，可以正确的识别类型
        this.$emit('click', evt);
    }
}
/**
 * 这里提供了另外一种在 setup 函数中使用的例子，默认推荐使用 `defineComponent`
 * 如果有多个类实例，也可以在 setup 中实例化类
 * &lt;script lang="ts" setup&gt;
 *      const app = new App();
 * &lt;\/script&gt;
 * &lt;template&gt;
 *      &lt;div&gt;{{ app.text }}&lt;/div&gt;
 * &lt;/template&gt;
 */
export default defineComponent({
    ...App.inject(),
});
&lt;/script&gt;
&lt;script lang="ts" setup&gt;
// 如果在 setup 中定义类型，需要导出一下
export interface Props {
    value: number;
    dest?: string;
}
export interface Emit {
    (event: 'click', evt: MouseEvent): void;
}
// 这里不再需要使用变量来接收，可以利用 Vue 的编译宏来为组件生成正确的 Props 和 Emit
// ❌ const props = defineProps&lt;Props&gt;();
// ❌ const emit = defineEmits&lt;Emit&gt;();
defineProps&lt;Props&gt;(); //  ✅
defineEmits&lt;Emit&gt;(); //  ✅

// 这种默认值的定义，也不再推荐，而是直接在类上声明
// ❌ withDefaults(defineProps&lt;Props&gt;(), { dest: '--' });
// ✅ @Setup
// ✅ class App extends Define&lt;Props, Emit&gt; {
// ✅     public readonly dest = '--'
// ✅ }

// Setup 装饰器，会在类实例化时，自动 使用 reactive 包装类，
// 如果你在 setup 手动实例化，则不需要再执行一次 reactive 
// const app = reactive(new App()); // ❌
// const app = new App();           // ✅
&lt;/script&gt;
&lt;template&gt;
    &lt;button class="btn" @click="click($event)"&gt;
        &lt;span class="text"&gt;{{ text }}&lt;/span&gt;
        &lt;span class="props-dest"&gt;{{ dest }}&lt;/span&gt;
        &lt;span class="props-value"&gt;{{ $props.value }}&lt;/span&gt;
    &lt;/button&gt;
&lt;/template&gt;
</code></pre><h2>多个类实例</h2>
<p>在一些复杂的业务时，有时需要多个实例</p>
<pre class="prettyprint language-vue"><code>&lt;script lang="ts"&gt;
import { onBeforeMount, onMounted } from 'vue';
import { Setup, Context, PassOnTo } from 'vue-class-setup';

@Setup
class Base extends Context {
    public value = 0;
    public get text() {
        return String(this.value);
    }
    @PassOnTo(onBeforeMount)
    public init() {
        this.value++;
    }
}

@Setup
class Left extends Base {
    public left = 0;
    public get text() {
        return String(`value:${this.value}`);
    }
    public init() {
        super.init();
        this.value++;
    }
    @PassOnTo(onMounted)
    public initLeft() {
        this.left++;
    }
}

@Setup
class Right extends Base {
    public right = 0;
    public init() {
        super.init();
        this.value++;
    }
    @PassOnTo(onMounted)
    public initLeft() {
        this.right++;
    }
}
&lt;/script&gt;
&lt;script setup lang="ts"&gt;
const left = new Left();
const right = new Right();
&lt;/script&gt;
&lt;template&gt;
    &lt;p class="left"&gt;{{ left.text }}&lt;/p&gt;
    &lt;p class="right"&gt;{{ right.text }}&lt;/p&gt;
&lt;/template&gt;
</code></pre><h2>PassOnTo</h2>
<p>在类实例准备就绪后，PassOnTo 装饰器，会将对应的函数，传递给回调，这样我们就可以顺利的和 <code>onMounted</code> 等钩子一起配合使用了</p>
<pre class="prettyprint language-ts"><code>import { onMounted } from 'vue';
@Setup
class App extends Define {
    @PassOnTo(onMounted)
    public onMounted() {}
}
</code></pre><h2>Watch</h2>
<p>在使用 <code>vue-property-decorator</code> 的 <code>Watch</code> 装饰器时，他会接收一个字符串类型，它不能正确的识别类实例是否存在这个字段，但是现在 <a href="https://github.com/fmfe/vue-class-setup">vue-class-setup</a> 能检查你的类型是否正确，如果传入一个类实例不存在的字段，类型将会报错</p>
<pre class="prettyprint language-vue"><code>&lt;script lang="ts"&gt;
import { Setup, Watch, Context } from 'vue-class-setup';

@Setup
class App extends Context {
    public value = 0;
    public immediateValue = 0;
    public onClick() {
        this.value++;
    }
    @Watch('value')
    public watchValue(value: number, oldValue: number) {
        if (value &gt; 100) {
            this.value = 100;
        }
    }
    @Watch('value', { immediate: true })
    public watchImmediateValue(value: number, oldValue: number | undefined) {
        if (typeof oldValue === 'undefined') {
            this.immediateValue = 10;
        } else {
            this.immediateValue++;
        }
    }
}
&lt;/script&gt;
&lt;script setup lang="ts"&gt;
const app = new App();
&lt;/script&gt;
&lt;template&gt;
    &lt;p class="value"&gt;{{ app.value }}&lt;/p&gt;
    &lt;p class="immediate-value"&gt;{{ app.immediateValue }}&lt;/p&gt;
    &lt;button @click="app.onClick()"&gt;Add&lt;/button&gt;
&lt;/template&gt;
</code></pre><h2>defineExpose</h2>
<p>在一些场景，我们希望可以暴露组件的一些方法和属性，那么就需要使用 <code>defineExpose</code> 编译宏来定义导出了，所以提供了一个<code>.use</code>的类静态方法帮你获取当前注入的类实例</p>
<pre class="prettyprint language-vue"><code>&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';
import { Setup, Context } from 'vue-class-setup';

@Setup
class App extends Context {
    private _value = 0;
    public get text() {
        return String(this._value);
    }
    public set text(text: string) {
        this._value = Number(text);
    }
    public addValue() {
        this._value++;
    }
}
export default defineComponent({
    ...App.inject(),
});
&lt;/script&gt;
&lt;script lang="ts" setup&gt;
const app = App.use();

defineExpose({
    addValue: app.addValue,
});
&lt;/script&gt;
&lt;template&gt;
    &lt;div&gt;
        &lt;p class="text"&gt;{{ text }}&lt;/p&gt;
        &lt;p class="text-eq"&gt;{{ app.text === text }}&lt;/p&gt;
        &lt;button @click="addValue"&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><h2>为什么使用 class ？</h2>
<p>其实不太想讨论这个问题，喜欢的自然会喜欢，不喜欢的自然会不喜欢，世上本无路，走的人多了，就有了路。</p>
<h2>最后</h2>
<p>不管是 选项 API 还是 组合式API，代码都是人写出来的，别人都说 Vue 无法胜任大型项目，但是在我司的实践中经受住了实践，基本上没有产生那种数千行的组件代码。</p>
<p>如果喜欢使用 class 风格来编写代码的，不妨来关注一下</p>
<ul>
<li><a href="https://github.com/fmfe/vue-class-setup">vue-class-setup</a></li>
</ul>
<p>如果你的业务复杂，需要使用 SSR 和微服务架构，不妨也关注一下</p>
<ul>
<li><a href="https://github.com/fmfe/genesis">vue-genesis</a></li>
</ul>







标题：除了在主函数调用return，还有什么办法能终止主函数继续向后执行？
作者：cd-xulei
发布日期：发布于 7 个月前
文章内容：<pre class="prettyprint language-javascript"><code>function main () {
   // other code 
  
   // 1. 目前的实现方式
   if(!validateSomethind()){
     return 
   }
  
  // 2. 期望的实现方式
  validateSomething()
  
  // other code
}

function validateSomething () {
   if("表达式"){ 
    return true
   }
   // 这里除了抛错能终止主函数像后执行，还有其他方式吗？
   return false
}
</code></pre><p>如上代码所示，类似的在业务开发中应该很常见。如果类似于validateSomething这样的方法在多处外部函数调用，多处外部函数还需要再写一次if判断。这种内外都是判断就感觉不那么好。大家对这种情况有其他见解吗？或者有什么更好的组织方式。</p>







标题：时间管理大师是如何学习的？
作者：icai
发布日期：发布于 7 个月前
文章内容：<p>内卷时间管理大师是如何学习的？</p>
<p>再上下班的通勤时间，刷一下w3cub。 一手资料，熟读说明书。</p>
<p><img src="//static.cnodejs.org/Fn95Vb5S9O5v72UUKuRC-UhVoJ32" alt="224238.png"></p>
<p><a href="https://docs.w3cub.com/">https://docs.w3cub.com/</a></p>







标题：管理后台ui，动态性非常强，我猜这个项目会火
作者：i5ting
发布日期：发布于 7 个月前
文章内容：<p><a href="https://github.com/cloudify-cosmo/cloudify-stage">https://github.com/cloudify-cosmo/cloudify-stage</a></p>
<pre class="prettyprint"><code>export function importWidgetBackend(widgetId: string, isCustom = true) {
    let widgetsFolder = userWidgetsFolder;
    if (!isCustom) {
        widgetsFolder = builtInWidgetsFolder;
    }
    const backendFile = pathlib.resolve(widgetsFolder, widgetId, getConfig().app.widgets.backendFilename);

    function importWidgetBackendFromFile(extensions: string[]): Promise&lt;any&gt; {
        if (extensions.length === 0) {
            return Promise.resolve();
        }

        const extension = extensions.pop();

        const backendFileWithExtension = `${backendFile}.${extension}`;
        if (!fs.existsSync(backendFileWithExtension)) {
            return importWidgetBackendFromFile(extensions);
        }

        logger.info(`-- initializing file ${backendFileWithExtension}`);

        try {
            const vm = new NodeVM({
                sandbox: {
                    _,
                    widgetId,
                    BackendRegistrator
                },
                require: {
                    context: 'sandbox',
                    external: true,
                    root: [backendFileWithExtension, ...allowedModulesPaths]
                },
                compiler: source =&gt; ts.transpile(source, compilerOptions),
                sourceExtensions: getConfig().app.widgets.backendFilenameExtensions
            });

            const script = `
                    import backend from '${backendFileWithExtension.replace('\\', '\\\\')}';
                    module.exports = new Promise((resolve, reject) =&gt; {
                         try {
                             if (_.isFunction(backend)) {
                                 backend(BackendRegistrator(widgetId, resolve, reject));
                             } else {
                                 reject('Backend definition must be a function (module.exports = function(BackendRegistrator) {...})');
                             }
                         } catch (error) {
                             reject(error);
                         }
                     });`;

            return vm.run(script, { filename: pathlib.resolve(`${process.cwd()}/${widgetId}`) });
        } catch (err: any) {
            logger.error('reject', backendFileWithExtension, err);
            return Promise.reject(
                `Error during importing widget backend from file ${backendFileWithExtension} - ${err.message}`
            );
        }
    }

    return importWidgetBackendFromFile([...getConfig().app.widgets.backendFilenameExtensions]);
}

</code></pre><p>通过vm2动态执行ts，不错的思路</p>







标题：nodejs 微服务快速体验
作者：cool-team-official
发布日期：发布于 10 个月前
文章内容：<p><a href="https://www.bilibili.com/video/BV1iu411r7EJ/">https://www.bilibili.com/video/BV1iu411r7EJ/</a></p>
<p>一个开源免费的后台管理快速开发框架，基于midwayjs+vue3+ts+微服务</p>
<p><img src="//static.cnodejs.org/Fsyfj4K3_SFWi9sswtHl3Zcl1WUY" alt="show (1).png"></p>
<p><a href="https://cool-js.com">文档地址</a></p>







标题：node.js中文网收费问题
作者：raoyaoiau
发布日期：发布于 9 个月前
文章内容：<p>今天想查查API，结果发现居然要收费，一年199？ ，维护个网站有那么贵吗？ 楼下有没有一起搞个api网站的，
<img src="//static.cnodejs.org/Fgkxth-JoxC0zRfKMc9F2if1W7i9" alt="image.png"></p>







标题：关于官网文档中 针对node本身模块 增加的类似 require("node:fs")有什么特殊含义
作者：cd-xulei
发布日期：发布于 7 个月前
文章内容：<pre class="prettyprint"><code>require("node:fs")
require("fs")
</code></pre><p>两者有什么区别吗？</p>







标题：基于声网 SDK 实现 iOS 端的一对一视频通话
作者：kylezhang
发布日期：发布于 7 个月前
文章内容：<p>在很多产品，加入实时视频通话已经不是新鲜事情了，尤其是近几年的疫情影响，个人公司国家对于实时音视频的需求一直在快速的增长。例如视频会议、社交应用、实时游戏，甚至也可能出现在一些元宇宙的场景中。</p>
<p>本文将教你如何通过声网视频 SDK 在 iOS 平台上实现一个视频通话应用。为此你需要先<a href="https://console.agora.io/">注册</a>一个声网开发者账号，开发者每个月可获得 10000 分钟的免费使用额度，可实现各类实时音视频场景。</p>
<h2>一、	通过开源Demo，体验视频通话</h2>
<p>可能有些人，还不了解我们要实现的功能最后是怎样的。所以我们在 GitHub上提供一个开源的基础视频通话示例项目，在开始开发之前你可以通过该示例项目体验视频通话的体验效果。</p>
<p>Agora 在 <a href="https://github.com/AgoraIO/Basic-Video-Call/tree/master/One-to-One-Video">https://github.com/AgoraIO/Basic-Video-Call/tree/master/One-to-One-Video</a> 上提供开源的实时音视频通话示例项目 Agora-iOS-Tutorial-Objective-C-1to1 与 Agora-iOS-Tutorial-Swift-1to1。
<img src="https://img-blog.csdnimg.cn/img_convert/2c394529f7455cbff5e694c8dce4ecb4.jpeg#pic_center" alt="在这里插入图片描述"></p>
<h2>二、	视频通话的技术原理</h2>
<p>我们在这里要实现的是一对一的视频通话。你可以理解为是两个用户通过加入同一个频道，实现的音视频的互通。而这个频道的数据，会通过声网的 Agora SD-RTN 实时网络来进行低延时传输的。
下图展示在 App 中集成 Agora 视频通话的基本工作流程：
<img src="https://img-blog.csdnimg.cn/img_convert/64ab394996cc571a8c46b4432e34dcd4.png#pic_center" alt="在这里插入图片描述"></p>
<h4><strong>如图所示，实现视频通话的步骤如下：</strong></h4>
<ol>
<li>获取 Token：当 app 客户端加入频道时，你需要使用 Token 验证用户身份。在测试或生产环境中，从 app 服务器中获取 Token。</li>
<li>加入频道：调用 joinChannel 创建并加入频道。使用同一频道名称的 app 客户端默认加入同一频道。频道可理解为专用于传输实时音视频数据的通道。</li>
<li>在频道内发布和订阅音视频流：加入频道后，app 客户端均可以在频道内发布和订阅音视频。</li>
</ol>
<h4><strong>App 客户端加入频道需要以下信息：</strong></h4>
<ol>
<li>App ID：Agora 随机生成的字符串，用于识别你的 App，可从 Agora 控制台获取，（Agora控制台链接：<a href="https://console.agora.io/%EF%BC%89%E3%80%82%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95%E5%8F%AF%E8%A7%81%E8%BF%99%E7%AF%87%E6%95%99%E7%A8%8B%EF%BC%88%E8%BF%99%E7%AF%87%E6%95%99%E7%A8%8B%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://www.agora.io/cn/community/blog-119-category-21344%EF%BC%89%E3%80%82">https://console.agora.io/）。详细方法可见这篇教程（这篇教程链接：https://www.agora.io/cn/community/blog-119-category-21344）。</a></li>
<li>用户 ID：用户的唯一标识。你需要自行设置用户 ID，并确保它在频道内是唯一的。</li>
<li>Token：在测试或生产环境中，app 客户端从你的服务器中获取 Token。在本文介绍的流程中，你可以从 Agora 控制台获取临时 Token。临时 Token 的有效期为 24 小时。</li>
<li>频道名称：用于标识视频通话频道的字符串。</li>
</ol>
<h2>三、	开发环境</h2>
<p>声网Agora SDK 的兼容性良好，对硬件设备和软件系统的要求不高，开发环境和测试环境满足以下条件即可：</p>
<ul>
<li>Xcode 9.0或以上版本</li>
<li>支持语音和视频功能的真机</li>
<li>App 要求支持iOS 8.0或以上版本的iOS设备</li>
</ul>
<h3>以下是本文的开发环境和测试环境：</h3>
<h4>开发环境</h4>
<p>•	macOS 11.6版本
•	Xcode Version 13.1</p>
<h4>测试环境</h4>
<p>•	iPhone7 (iOS 15.3)</p>
<h4>如果你此前还未接触过声网 Agora SDK，那么你还需要做以下准备工作：</h4>
<p>•	注册一个声网账号，进入后台创建 AppID、获取 Token，
•	下载声网官方最新的视频通话SDK；（视频通话SDK链接：<a href="https://docs.agora.io/cn/Video/downloads?platform=iOS%EF%BC%89">https://docs.agora.io/cn/Video/downloads?platform=iOS）</a></p>
<h2>四、	项目设置</h2>
<h3>1.	实现视频通话之前，参考如下步骤设置你的项目：</h3>
<p>a)	如需创建新项目, Xcode里，打开 Xcode 并点击 Create a new Xcode project。（创建 iOS项目链接：<a href="https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app%EF%BC%89">https://developer.apple.com/documentation/xcode/creating-an-xcode-project-for-an-app）</a>
b)	选择平台类型为 iOS、项目类型为 Single View App，并点击 Next。
c)	输入项目名称（Product Name）、开发团队信息（Team）、组织名称（Organization Name）和语言（Language）等项目信息，并点击 Next。
注意：如果你没有添加过开发团队信息，会看到 Add account… 按钮。点击该按钮并按照屏幕提示登入 Apple ID，完成后即可选择你的 Apple 账户作为开发团队。
d)	选择项目存储路径，并点击 Create。</p>
<h3>2.	集成SDK</h3>
<p>选择如下任意一种方式获取最新版 Agora iOS SDK。</p>
<p><strong>方法一：使用 CocoaPods 获取 SDK</strong>
a)	开始前确保你已安装 Cocoapods。参考 Getting Started with CocoaPods 安装说明。（Getting Started with CocoaPods 安装说明链接：<a href="https://guides.cocoapods.org/using/getting-started.html#getting-started%EF%BC%89">https://guides.cocoapods.org/using/getting-started.html#getting-started）</a>
b)	在终端里进入项目根目录，并运行 pod init 命令。项目文件夹下会生成一个 Podfile 文本文件。
c)	打开 Podfile 文件，修改文件为如下内容。注意将 Your App 替换为你的 Target 名称。</p>
<p><strong>方法二：从官网获取 SDK</strong>
a)	前往 SDK 下载页面，获取最新版的 Agora iOS SDK，然后解压。（视频通话SDK链接：<a href="https://docs.agora.io/cn/Video/downloads?platform=iOS%EF%BC%89">https://docs.agora.io/cn/Video/downloads?platform=iOS）</a>
b)	根据你的需求，将 libs 文件夹中的动态库复制到项目的 ./project_name 文件夹下（project_name 为你的项目名称）。
c)	打开 Xcode，进入 TARGETS &gt; Project Name &gt; Build Phases &gt; Link Binary with Libraries 菜单，点击 + 添加如下库（如：）。在添加 AgoraRtcEngineKit.framework 文件时，还需在点击 + 后点击 Add Other…，找到本地文件并打开。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RMM224bm-1663063848743)(upload://gOFc9CzhWzmOk7Ef4Dh0QVyu5kp.png)]</p>
<p>共需要添加11个库文件：
i.	AgoraRtcEngineKit.framework
ii.	Accelerate.framework
iii.	AudioToolbox.framework
iv.	AVFoundation.framework
v.	CoreMedia.framework
vi.	CoreML.framework
vii.	CoreTelephony.framework
viii.	libc++.tbd
ix.	libresolv.tbd
x.	SystemConfiguration.framework
xi.	VideoToolbox.framework
<strong>注意：</strong> 如需支持 iOS 9.0 或更低版本的设备，请在 Xcode 中将对 CoreML.framework 的依赖设为 Optional。</p>
<p>d)	打开 Xcode，进入 TARGETS &gt; Project Name &gt; General &gt; Frameworks, Libraries, and Embedded Content 菜单。
e)	点击 + &gt; Add Other… &gt; Add Files 添加对应动态库，并确保添加的动态库 Embed 属性设置为 Embed &amp; Sign。添加完成后，项目会自动链接所需系统库。</p>
<p><strong>注意：</strong></p>
<ul>
<li>根据 Apple 官方要求，app 的 Extension 中不允许包含动态库。如果项目中的 Extension 需要集成 SDK，则添加动态库时需将文件状态改为 Do Not Embed。</li>
<li>Agora SDK 默认使用 libc++ (LLVM)，如需使用 libstdc++ (GNU)，请联系 <a href="mailto:sales@agora.io">sales@agora.io</a>。SDK 提供的库是 FAT Image，包含 32/64 位模拟器、32/64 位真机版本。</li>
</ul>
<h3>3.	权限设置</h3>
<ol>
<li>
<p>Xcode进入 TARGETS &gt; Project Name &gt; General &gt; Signing 菜单，选择 Automatically manage signing，并在弹出菜单中点击 Enable Automatic。
<img src="https://img-blog.csdnimg.cn/img_convert/60a634f67612b1e43b562fb23e2b8304.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li>
<p>添加媒体设备权限
根据场景需要，在 info.plist 文件中，点击 + 图标开始添加如下内容，获取相应的设备权限：
<img src="https://img-blog.csdnimg.cn/img_convert/db1de395ccd2ac3cce21aa1877cce367.png#pic_center" alt="在这里插入图片描述">
<img src="https://img-blog.csdnimg.cn/img_convert/edf6e42d39b2ad5ddc5d6bca1f62a0bf.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3>4.	导入Agora相关的类</h3>
<h4>在项目中导入 AgoraRtcEngineKit 类：</h4>
<pre class="prettyprint"><code>// Objective-C
// ViewController.h
// 导入 AgoraRtcKit 类
// 自 3.0.0 版本起，AgoraRtcEngineKit 类名更换为 AgoraRtcKit
// 如果获取的是 3.0.0 以下版本的 SDK，请改用 #import &lt;AgoraRtcEngineKit/AgoraRtcEngineKit.h&gt;
#import &lt;AgoraRtcKit/AgoraRtcEngineKit.h&gt;
// 声明 AgoraRtcEngineDelegate，用于监听回调
@interface ViewController : UIViewController &lt;AgoraRtcEngineDelegate&gt;
// 定义 agoraKit 变量
@property (strong, nonatomic) AgoraRtcEngineKit *agoraKit;



// Swift
// ViewController.swift
// 导入 AgoraRtcKit 类
// 自 3.0.0 版本起，AgoraRtcEngineKit 类名更换为 AgoraRtcKit
// 如果获取的是 3.0.0 以下版本的 SDK，请改用 import AgoraRtcEngineKit
import AgoraRtcKit
class ViewController: UIViewController {
    ...
    // 定义 agoraKit 变量
    var agoraKit: AgoraRtcEngineKit?
}
</code></pre><h3>5.	设置Agora账号信息</h3>
<h4>在AppID.swift文件中，将你的AppID填写到let AppID，可替换“Your App ID”;</h4>
<pre class="prettyprint"><code>//  Objective-C
//  AppID.m
//  Agora iOS Tutorial Objective-C
#import &lt;Foundation/Foundation.h&gt;
NSString *const appID = &lt;#Your App ID#&gt;;

//  Swift
// AppID.swift
//  Agora iOS Tutorial
let AppID: String = Your App ID
</code></pre><h2>五、	客户端实现</h2>
<p>本节介绍如何使用Agora视频SDK在你的App里实现视频通话的几个小贴士：</p>
<h3>1.	创建用户界面</h3>
<p>根据场景需要，为你的项目创建视频通话的用户界面。我们推荐你在项目中添加元素：本地视频窗口、远端视频窗口。
你可以参考以下代码创建一个基础的用户界面。</p>
<pre class="prettyprint"><code>// Objective-C
// ViewController.m
// 导入 UIKit
#import &lt;UIKit/UIKit.h&gt;
@interface ViewController ()
// 定义 localView 变量
@property (nonatomic, strong) UIView *localView;
// 定义 remoteView 变量
@property (nonatomic, strong) UIView *remoteView;
@end
@implementation ViewController
...
- (void)viewDidLoad {
    [super viewDidLoad];
    // 调用初始化视频窗口函数
    [self initViews];
    // 后续步骤调用 Agora API 使用的函数
    [self initializeAgoraEngine];
    [self setupLocalVideo];
    [self joinChannel];
}
// 设置视频窗口布局
- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.remoteView.frame = self.view.bounds;
    self.localView.frame = CGRectMake(self.view.bounds.size.width - 90, 0, 90, 160);
}
- (void)initViews {
    // 初始化远端视频窗口
    self.remoteView = [[UIView alloc] init];
    [self.view addSubview:self.remoteView];
    // 初始化本地视频窗口
    self.localView = [[UIView alloc] init];
    [self.view addSubview:self.localView];
}

// Swift
// ViewController.swift
// 导入 UIKit
import UIKit
class ViewController: UIViewController {
    ...
    // 定义 localView 变量
    var localView: UIView!
    // 定义 remoteView 变量
    var remoteView: UIView!
     override func viewDidLoad() {
        super.viewDidLoad()
        // 调用初始化视频窗口函数
        initView()
        // 后续步骤调用 Agora API 使用的函数
        initializeAgoraEngine()
        setupLocalVideo()
        joinChannel()
     }
    // 设置视频窗口布局
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        remoteView.frame = self.view.bounds
        localView.frame = CGRect(x: self.view.bounds.width - 90, y: 0, width: 90, height: 160)
    }
    func initView() {
        // 初始化远端视频窗口
        remoteView = UIView()
        self.view.addSubview(remoteView)
        // 初始化本地视频窗口
        localView = UIView()
        self.view.addSubview(localView)
    }
}
</code></pre><h3>2.	实现视频通话逻辑</h3>
<p>现在，我们已经将 Agora iOS SDK 集成到项目中了。接下来我们要在 ViewController 中调用 Agora iOS SDK 提供的核心 API 实现基础的视频通话功能。你可以在 Agora-iOS-Tutorial-Objective-C-1to1/Agora-iOS-Tutorial-Swift-1to1 示例项目的 VideoChatViewController.m/VideoChatViewController.swift 文件中查看完整的源码和代码逻辑。</p>
<h4><strong>API 调用时序见下图：</strong></h4>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7b8020d6e2059deeb7e1faf2b84f76c6.png#pic_center" alt="在这里插入图片描述"></p>
<h4><strong>按照以下步骤实现该逻辑：</strong></h4>
<p><strong>a)	初始化AgoraRtcEngineKit对象</strong>
在调用其他 Agora API 前，需要创建并初始化 AgoraRtcEngineKit 对象。调用 sharedEngineWithAppId 方法，传入获取到的 App ID，即可初始化 AgoraRtcEngineKit 。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)initializeAgoraEngine {
    // 输入 App ID 并初始化 AgoraRtcEngineKit 类。
    self.agoraKit = [AgoraRtcEngineKit sharedEngineWithAppId:appID delegate:self];
}

// Swift
func initializeAgoraEngine() {
   // 输入 App ID 并初始化 AgoraRtcEngineKit 类。
   agoraKit = AgoraRtcEngineKit.sharedEngine(withAppId: AppID, delegate: self)
}
</code></pre><p>你还可以根据场景需要，在初始化时注册想要监听的回调事件，如本地用户加入频道，及解码远端用户视频首帧等。</p>
<p><strong>b)	设置本地视图</strong>
成功初始化 AgoraRtcEngineKit 对象后，需要在加入频道前设置本地视图，以便在通话中看到本地图像。参考以下步骤设置本地视图：
·	调用 enableVideo 方法启用视频模块。
·	调用 setupLocalVideo 方法设置本地视图。</p>
<pre class="prettyprint"><code>// Objective-C
// 启用视频模块。
[self.agoraKit enableVideo];
- (void)setupLocalVideo {
    AgoraRtcVideoCanvas *videoCanvas = [[AgoraRtcVideoCanvas alloc] init];
    videoCanvas.uid = 0;
    videoCanvas.view = self.localVideo;
    videoCanvas.renderMode = AgoraVideoRenderModeHidden;
    // 设置本地视图。
    [self.agoraKit setupLocalVideo:videoCanvas];
}

// Swift
// 启用视频模块。
agoraKit.enableVideo()
func setupLocalVideo() {
  let videoCanvas = AgoraRtcVideoCanvas()
  videoCanvas.uid = 0
  videoCanvas.view = localVideo
  videoCanvas.renderMode = .hidden
  // 设置本地视图。
  agoraKit.setupLocalVideo(videoCanvas)
}
</code></pre><p><strong>c)	加入频道</strong>
频道是人们在同一个视频通话中的公共空间。完成初始化和设置本地视图后（视频通话场景），你就可以调用 joinChannelByToken 方法加入频道。你需要在该方法中传入如下参数：</p>
<ol>
<li>channelId: 传入能标识频道的频道 ID。输入频道 ID 相同的用户会进入同一个频道。</li>
<li>token: 传入能标识用户角色和权限的 Token。你可以设置如下值：
a)	nil 。
b)	控制台中生成的临时 Token。一个临时 Token 的有效期为 24 小时，详情见获取临时 Token。
c)	你的服务器端生成的正式 Token。适用于对安全要求较高的生产环境，详情见生成 Token。若项目已启用 App 证书，请使用 Token。
d)	uid: 本地用户的 ID。数据类型为整型，且频道内每个用户的 uid 必须是唯一的。若将 uid 设为 0，则 SDK 会自动分配一个 uid ，并在 joinSuccessBlock 回调中报告。
e)	joinSuccessBlock：成功加入频道回调。 joinSuccessBlock 优先级高于 didJoinChannel ，2 个同时存在时， didJoinChannel 会被忽略。需要有 didJoinChannel 回调时，请将 joinSuccessBlock 设置为 nil 。</li>
</ol>
<p>更多的参数设置注意事项请参考 joinChannelByToken 接口中的参数描述。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)joinChannel {
    // 加入频道。
    [self.agoraKit joinChannelByToken:token channelId:@"demoChannel1" info:nil uid:0 joinSuccess:^(NSString *channel, NSUInteger uid, NSInteger elapsed) {
    }];
}

// Swift
func joinChannel() {
    // 加入频道。
    agoraKit.joinChannel(byToken: Token, channelId: "demoChannel1", info:nil, uid:0) { [unowned self] (channel, uid, elapsed) -&gt; Void in}
    self.isLocalVideoRender = true
            self.logVC?.log(type: .info, content: "did join channel")
        }
        isStartCalling = true
}
</code></pre><p><strong>d)	设置远端视图</strong>
视频通话中，通常你也需要看到其他用户。在加入频道后，可通过调用 setupRemoteVideo 方法设置远端用户的视图。</p>
<p>远端用户成功加入频道后，SDK 会触发 firstRemoteVideoDecodedOfUid 回调，该回调中会包含这个远端用户的 uid 信息。在该回调中调用setupRemoteVideo 方法，传入获取到的 uid ，设置远端用户的视图。</p>
<pre class="prettyprint"><code>
// Objective-C
// 监听 firstRemoteVideoDecodedOfUid 回调。
// SDK 接收到第一帧远端视频并成功解码时，会触发该回调。
// 可以在该回调中调用 setupRemoteVideo 方法设置远端视图。
- (void)rtcEngine:(AgoraRtcEngineKit *)engine firstRemoteVideoDecodedOfUid:(NSUInteger)uid size: (CGSize)size elapsed:(NSInteger)elapsed {
    if (self.remoteVideo.hidden) {
        self.remoteVideo.hidden = NO;
    }
    AgoraRtcVideoCanvas *videoCanvas = [[AgoraRtcVideoCanvas alloc] init];
    videoCanvas.uid = uid;
    videoCanvas.view = self.remoteVideo;
    videoCanvas.renderMode = AgoraVideoRenderModeHidden;
    // 设置远端视图。
    [self.agoraKit setupRemoteVideo:videoCanvas];
}

// Swift
// 监听 firstRemoteVideoDecodedOfUid 回调。
// SDK 接收到第一帧远端视频并成功解码时，会触发该回调。
// 可以在该回调中调用 setupRemoteVideo 方法设置远端视图。
func rtcEngine(_ engine: AgoraRtcEngineKit, firstRemoteVideoDecodedOfUid uid:UInt, size:CGSize, elapsed:Int) {
        isRemoteVideoRender = true
        let videoCanvas = AgoraRtcVideoCanvas()
        videoCanvas.uid = uid
        videoCanvas.view = remoteVideo
        videoCanvas.renderMode = .hidden
        // 设置远端视图。
        agoraKit.setupRemoteVideo(videoCanvas)
    }
</code></pre><p><strong>e)	离开频道</strong>
根据场景需要，如结束通话、关闭 App 或 App 切换至后台时，调用 leaveChannel 离开当前通话频道。</p>
<pre class="prettyprint"><code>// Objective-C
- (void)leaveChannel {
    // 离开频道。
    [self.agoraKit leaveChannel:^(AgoraChannelStats *stat)
}

// Swift
func leaveChannel() {
        // 离开频道。
        agoraKit.leaveChannel(nil)
        isRemoteVideoRender = false
        isLocalVideoRender = false
        isStartCalling = false
        self.logVC?.log(type: .info, content: "did leave channel")
    }
</code></pre><p><strong>f)	销毁AgoraRtcEngineKit对象</strong>
最后，离开频道，我们需要调用 destroy 销毁 AgoraRtcEngineKit 对象，释放 Agora SDK 使用的所有资源。</p>
<pre class="prettyprint"><code>// Objective-C
// ViewController.m
// 将以下代码填入你定义的函数中
[AgoraRtcEngineKit destroy];

// Swift
// ViewController.swift
// 将以下代码填入你定义的函数中
AgoraRtcEngineKit.destroy()
</code></pre><p>至此，完成，运行看看效果。拿两部 iOS 手机安装编译好的App，加入同一个频道名，如果2个手机都能看见本地和远端视频图像，说明你成功了。</p>
<p>如果你在开发过程中遇到问题，可以访问论坛提问与声网工程师交流<a href="https://rtcdeveloper.agora.io/">https://rtcdeveloper.agora.io/</a></p>







标题：如何像Word、Excel一样，提供内容脏标记的功能呢？
作者：zhennann
发布日期：发布于 7 个月前
文章内容：<p>中后台业务管理系统，是否也可以像Word、Excel一样，提供内容脏标记的功能呢？具体而言，就是当表单内容有变更时，如果意外关闭页面，就会有“数据未保存”的提示，从而避免意外丢失数据。<strong>这应该是刚需才对！不是吗？！</strong>
CabloyJS是一款教科书级的开源NodeJS全栈框架，提供了诸多切合实际业务场景的功能特性，其中就包括“编辑页面脏标记”。</p>
<h2>效果演示</h2>
<p>请参见知乎视频（02:55）：<a href="https://www.zhihu.com/zvideo/1552242619312435201">https://www.zhihu.com/zvideo/1552242619312435201</a></p>
<h2>如何开发</h2>
<p>请参见知乎视频（15:27）：<a href="https://www.zhihu.com/zvideo/1546807710695448576">https://www.zhihu.com/zvideo/1546807710695448576</a></p>
<h2>更多免费视频</h2>
<ul>
<li><a href="https://course.cabloy.com/zh-cn/articles/A-001.html">CabloyJS全栈框架：从入门到精通（一共48集）</a></li>
<li><a href="https://course.cabloy.com/zh-cn/articles/A-002.html">CabloyJS全栈框架：功能特性演示（已出8集）</a></li>
</ul>
<h2>相关链接</h2>
<ul>
<li>文档: <a href="https://cabloy.com/">https://cabloy.com/</a></li>
<li>演示：<a href="https://test.cabloy.com/">https://test.cabloy.com/</a></li>
<li>GitHub: <a href="https://github.com/zhennann/cabloy">https://github.com/zhennann/cabloy</a></li>
</ul>






